<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Power-law Graph Computing: Theoretical and Empirical Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Cong</forename><surname>Xie</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Comp. Sci. and Eng. Shanghai</orgName>
								<orgName type="institution">Jiao Tong University</orgName>
								<address>
									<addrLine>800 Dongchuan Road Shanghai</addrLine>
									<postCode>200240</postCode>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ling</forename><surname>Yan</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Comp. Sci. and Eng. Shanghai</orgName>
								<orgName type="institution">Jiao Tong University</orgName>
								<address>
									<addrLine>800 Dongchuan Road Shanghai</addrLine>
									<postCode>200240</postCode>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wu-Jun</forename><surname>Li</surname></persName>
							<email>liwujun@nju.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Comp. Sci. and Tech</orgName>
								<orgName type="laboratory">National Key Lab. for Novel Software Tech</orgName>
								<orgName type="institution">Nanjing University</orgName>
								<address>
									<postCode>210023</postCode>
									<settlement>Nanjing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zhihua</forename><surname>Zhang</surname></persName>
							<email>zhang-zh@cs.sjtu.edu.cn</email>
							<affiliation key="aff3">
								<orgName type="department">Dept. of Comp. Sci. and Eng. Shanghai</orgName>
								<orgName type="institution">Jiao Tong University</orgName>
								<address>
									<addrLine>800 Dongchuan Road Shanghai</addrLine>
									<postCode>200240</postCode>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Distributed Power-law Graph Computing: Theoretical and Empirical Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-25T12:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>With the emergence of big graphs in a variety of real applications like social networks, machine learning based on distributed graph-computing (DGC) frameworks has attracted much attention from big data machine learning community. In DGC frameworks, the graph partitioning (GP) strategy plays a key role to affect the performance, including the workload balance and communication cost. Typically, the degree distributions of natural graphs from real applications follow skewed power laws, which makes GP a challenging task. Recently, many methods have been proposed to solve the GP problem. However, the existing GP methods cannot achieve satisfactory performance for applications with power-law graphs. In this paper, we propose a novel vertex-cut method, called degree-based hashing (DBH), for GP. DBH makes effective use of the skewed degree distributions for GP. We theoretically prove that DBH can achieve lower communication cost than existing methods and can simultaneously guarantee good workload balance. Furthermore, empirical results on several large power-law graphs also show that DBH can outperform the state of the art.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent years have witnessed the emergence of big graphs in a large variety of real applications, such as the web and social network services. Furthermore, many machine learning and data mining algorithms can also be modeled with graphs <ref type="bibr" target="#b12">[13]</ref>. Hence, machine learning based on distributed graph-computing (DGC) frameworks has attracted much attention from big data machine learning community <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b6">7]</ref>. To perform distributed (parallel) graph-computing on clusters with several machines (servers), one has to partition the whole graph across the machines in a cluster. Graph partitioning (GP) can dramatically affect the performance of DGC frameworks in terms of workload balance and communication cost. Hence, the GP strategy typically plays a key role in DGC frameworks. The ideal GP method should minimize the cross-machine communication cost, and simultaneously keep the workload in every machine approximately balanced.</p><p>Existing GP methods can be divided into two main categories: edge-cut and vertex-cut methods. Edge-cut tries to evenly assign the vertices to machines by cutting the edges. In contrast, vertex-cut tries to evenly assign the edges to machines by cutting the vertices. Figure <ref type="figure" target="#fig_0">1</ref> illustrates the edgecut and vertex-cut partitioning results of an example graph. In Figure <ref type="figure" target="#fig_0">1</ref> (a), the edges (A,C) and (A,E) are cut, and the two machines store the vertex sets {A,B,D} and {C,E}, respectively. In Figure <ref type="figure" target="#fig_0">1</ref> (b), the vertex A is cut, and the two machines store the edge sets {(A,B), (A,D), (B,D)} and {(A,C), (A,E), (C,E)}, respectively. In edge-cut, both machines of a cut edge should maintain a ghost (local replica) of the vertex and the edge data. In vertex-cut, all the machines associated with a cut vertex should maintain a mirror (local replica) of the vertex. The ghosts and mirrors are shown in shaded vertices in Figure <ref type="figure" target="#fig_0">1</ref>. In edge-cut, the workload of a machine is determined by the number of vertices located in that machine, and the communication cost of the whole graph is determined by the number of edges spanning different machines. In vertex-cut, the workload of a machine is determined by the number of edges located in that machine, and the communication cost of the whole graph is determined by the number of mirrors of the vertices. Most traditional DGC frameworks, such as GraphLab <ref type="bibr" target="#b12">[13]</ref> and Pregel <ref type="bibr" target="#b14">[15]</ref>, use edge-cut methods <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref> for GP. Very recently, the authors of PowerGraph <ref type="bibr" target="#b5">[6]</ref> find that the vertex-cut methods can achieve better performance than edge-cut methods, especially for power-law graphs. Hence, vertex-cut has attracted more and more attention from DGC research community. For example, PowerGraph <ref type="bibr" target="#b5">[6]</ref> adopts a random vertex-cut method and two greedy variants for GP.</p><p>GraphBuilder <ref type="bibr" target="#b7">[8]</ref> provides some heuristics, such as the grid-based constrained solution, to improve the random vertex-cut method.</p><p>Large natural graphs usually follow skewed degree distributions like power-law distributions, which makes GP challenging. Different vertex-cut methods can result in different performance for powerlaw graphs. For example, Figure <ref type="figure" target="#fig_1">2</ref> (a) shows a toy power-law graph with only one vertex having much higher degree than the others. Hence, the power-law degree distribution can be used to facilitate GP. Unfortunately, existing vertexcut methods, including those in PowerGraph and GraphBuilder, make rarely use of the power-law degree distribution for GP. Hence, they cannot achieve satisfactory performance in natural powerlaw graphs. PowerLyra <ref type="bibr" target="#b3">[4]</ref> tries to combine both edge-cut and vertex-cut together by using the power-law degree distribution. However, it is lack of theoretical guarantee.  In this paper, we propose a novel vertex-cut GP method, called degree-based hashing (DBH), for distributed power-law graph computing. The main contributions of DBH are briefly outlined as follows:</p><p>• DBH can effectively exploit the power-law degree distributions in natural graphs for vertexcut GP. • Theoretical bounds on the communication cost and workload balance for DBH can be derived, which show that DBH can achieve lower communication cost than existing methods and can simultaneously guarantee good workload balance. • DBH can be implemented as an execution engine for PowerGraph <ref type="bibr" target="#b5">[6]</ref>, and hence all PowerGraph applications can be seamlessly supported by DBH. • Empirical results on several large real graphs and synthetic graphs show that DBH can outperform the state-of-the-art methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Formulation</head><p>Let G = (V, E) denote a graph, where V = {v 1 , v 2 , . . . , v n } is the set of vertices and E ⊆ V × V is the set of edges in G. Let |V | denote the cardinality of the set V , and hence |V | = n. v i and v j are called neighbors if (v i , v j ) ∈ E. The degree of v i is denoted as d i , which measures the number of neighbors of v i . Please note that we only need to consider the GP task for undirected graphs because the workload mainly depends on the number of edges no matter directed or undirected graphs the computation is based on. Even if the computation is based on directed graphs, we can also use the undirected counterparts of the directed graphs to get the partitioning results.</p><p>Assume we have a cluster of p machines. Vertex-cut GP is to assign each edge with the two corresponding vertices to one of the p machines in the cluster. The assignment of an edge is unique, while vertices may have replicas across different machines. For DGC frameworks based on vertex-cut GP, the workload (amount of computation) of a machine is roughly linear in the number of edges located in that machine, and the replicas of the vertices incur communication for synchronization. So the goal of vertex-cut GP is to minimize the number of replicas and simultaneously balance the number of edges on each machine.</p><p>Let M (e) ∈ {1, . . . , p} be the machine edge e ∈ E is assigned to, and A(v) ⊆ {1, . . . , p} be the span of vertex v over different machines. Hence, |A(v)| is the number of replicas of v among different machines. Similar to PowerGraph <ref type="bibr" target="#b5">[6]</ref>, one of the replicas of a vertex is chosen as the master and the others are treated as the mirrors of the master. We let M aster(v) denote the machine in which the master of v is located. Hence, the goal of vertex-cut GP can be formulated as follows:</p><formula xml:id="formula_0">min A 1 n n i=1 |A(v i )| s.t. max m |{e ∈ E | M (e) = m}| &lt; λ |E| p ,<label>and</label></formula><formula xml:id="formula_1">max m |{v ∈ V | M aster(v) = m}| &lt; ρ n p ,</formula><p>where m ∈ {1, . . . , p} denotes a machine, λ ≥ 1 and ρ ≥ 1 are imbalance factors. We de- The degrees of natural graphs usually follow skewed power-law distributions <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b0">1]</ref>:</p><formula xml:id="formula_2">fine 1 n n i=1 |A(v i )| as replication factor, p |E| max m |{e ∈ E | M (e) =</formula><formula xml:id="formula_3">Pr(d) ∝ d −α ,</formula><p>where Pr(d) is the probability that a vertex has degree d and the power parameter α is a positive constant. The lower the α is, the more skewed a graph will be. This power-law degree distribution makes GP challenging <ref type="bibr" target="#b5">[6]</ref>. Although vertex-cut methods can achieve better performance than edge-cut methods for power-law graphs <ref type="bibr" target="#b5">[6]</ref>, existing vertex-cut methods, such as random method in PowerGraph and grid-based method in GraphBuilder <ref type="bibr" target="#b7">[8]</ref>, cannot make effective use of the powerlaw distribution to achieve satisfactory performance.</p><p>3 Degree-Based Hashing for GP</p><p>In this section, we propose a novel vertex-cut method, called degree-based hashing (DBH), to effectively exploit the power-law distribution for GP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Hashing Model</head><p>We refer to a certain machine by its index idx, and the idxth machine is denoted as P idx . We first define two kinds of hash functions: vertex-hash function idx = vertex hash(v) which hashes vertex v to the machine P idx , and edge-hash function idx = edge hash(e) or idx = edge hash(v i , v j ) which hashes edge e = (v i , v j ) to the machine P idx .</p><p>Our hashing model includes two main components:</p><p>• Master-vertex assignment: The master replica of v i is uniquely assigned to one of the p machines with equal probability for each machine by some randomized hash function vertex hash(v i ).</p><p>• Edge assignment: Each edge e = (v i , v j ) is assigned to one of the p machines by some hash function edge hash(v i , v j ).</p><p>It is easy to find that the above hashing model is a vertex-cut GP method. The master-vertex assignment can be easily implemented, which can also be expected to achieve a low vertex-imbalance score. On the contrary, the edge assignment is much more complicated. Different edge-hash functions can achieve different replication factors and different edge-imbalance scores. Please note that replication factor reflects communication cost, and edge-imbalance reflects workload-imbalance.</p><p>Hence, the key of our hashing model lies in the edge-hash function edge hash(v i , v j ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Degree-Based Hashing</head><p>From the example in Figure <ref type="figure" target="#fig_1">2</ref>, we observe that in power-law graphs the replication factor, which is defined as the total number of replicas divided by the total number of vertices, will be smaller if we cut vertices with relatively higher degrees. Based on this intuition, we define the edge hash(v i , v j ) as follows:</p><formula xml:id="formula_4">edge hash(v i , v j ) = vertex hash(v i ) if d i &lt; d j , vertex hash(v j ) otherwise.<label>(1)</label></formula><p>It means that we use the vertex-hash function to define the edge-hash function. Furthermore, the edge-hash function value of an edge is determined by the degrees of the two associated vertices. More specifically, the edge-hash function value of an edge is defined by the vertex-hash function value of the associated vertex with a smaller degree. Hence, our method is called degree-based hashing (DBH). DBH can effectively capture the intuition that cutting vertices with higher degrees will get better performance.</p><p>Our DBH method for vertex-cut GP is briefly summarized in Algorithm 1, where [n] = {1, . . . , n}. Hash each edge in parallel:</p><p>4:</p><formula xml:id="formula_5">if d i &lt; d j then 5:</formula><p>M (e) ← vertex hash(v i )</p><p>6: M (e) ← vertex hash(v j )</p><p>8:</p><p>end if 9: end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Theoretical Analysis</head><p>In this section, we present theoretical analysis for our DBH method. For comparison, the random vertex-cut method (called Random) of PowerGraph <ref type="bibr" target="#b5">[6]</ref> and the grid-based constrained solution (called Grid) of GraphBuilder <ref type="bibr" target="#b7">[8]</ref> are adopted as baselines. Our analysis is based on randomization. Moreover, we assume that the graph is undirected and there are no duplicated edges in the graph. We mainly study the performance in terms of replication factor, edge-imbalance and verteximbalance defined in Section 2. Due to space limitation, we put the proofs of all theoretical results into the supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Partitioning Degree-fixed Graphs</head><p>Firstly, we assume that the degree sequence {d i } n i=1 is fixed. Then we can get the following expected replication factor produced by different methods.</p><p>Random assigns each edge evenly to the p machines via a randomized hash function. The result can be directly got from PowerGraph <ref type="bibr" target="#b5">[6]</ref>. Lemma 1. Assume that we have a sequence of n vertices {v i } n i=1 and the corresponding degree sequence D = {d i } n i=1 . A simple randomized vertex-cut on p machines has the expected replication factor:</p><formula xml:id="formula_6">E 1 n n i=1 |A(v i )| D = p n n i=1 1 − 1 − 1 p di .</formula><p>By using the Grid hash function, each vertex has √ p rather than p candidate machines compared to</p><p>Random. Thus we simply replace p with √ p to get the following corollary.</p><p>Corollary 1. By using Grid for hashing, the expected replication factor on p machines is:</p><formula xml:id="formula_7">E 1 n n i=1 |A(v i )| D = √ p n n i=1 1 − 1 − 1 √ p di .</formula><p>Using DBH method in Section 3.2, we obtain the following result by fixing the sequence {h i } n i=1 , where h i is defined as the number of v i 's adjacent edges which are hashed by the neighbors of v i according to the edge-hash function defined in (1). Theorem 1. Assume that we have a sequence of n vertices {v i } n i=1 and the corresponding degree sequence D = {d i } n i=1 . For each v i , d i − h i adjacent edges of it are hashed by v i itself. Define H = {h i } n i=1 . Our DBH method on p machines has the expected replication factor:</p><formula xml:id="formula_8">E 1 n n i=1 |A(v i )| H, D = p n n i=1 1 − 1 − 1 p hi+1 ≤ p n n i=1 1 − 1 − 1 p di , where h i ≤ d i − 1 for any v i .</formula><p>This theorem says that our DBH method has smaller expected replication factor than Random of PowerGraph <ref type="bibr" target="#b5">[6]</ref>.</p><p>Next we turn to the analysis of the balance constraints. We still fix the degree sequence and have the following result for our DBH method. Theorem 2. Our DBH method on p machines with the sequences {v i } n i=1 , {d i } n i=1 and {h i } n i=1 defined in Theorem 1 has the edge-imbalance:</p><formula xml:id="formula_9">max m |{e ∈ E | M (e) = m}| |E|/p = n i=1 hi p + max j∈[p] vi∈Pj (d i − h i ) 2|E|/p .</formula><p>Although the master vertices are evenly assigned to each machine, we want to show how the randomized assignment is close to the perfect balance. This problem is well studied in the model of uniformly throwing n balls into p bins when n p(ln p) 3 <ref type="bibr" target="#b16">[17]</ref>.</p><p>Lemma 2. The maximum number of master vertices for each machine is bounded as follows:</p><formula xml:id="formula_10">Pr[M axLoad &gt; k a ] = o(1) if a &gt; 1, Pr[M axLoad &gt; k a ] = 1 − o(1) if 0 &lt; a &lt; 1.</formula><p>Here M axLoad = max </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Partitioning Power-law Graphs</head><p>Now we change the sequence of fixed degrees into a sequence of random samples generated from the power-law distribution. As a result, upper-bounds can be provided for the above three methods, which are Random, Grid and DBH. Theorem 3. Let the minimal degree be d min and each d ∈ {d i } n i=1 be sampled from a power-law degree distribution with parameter α ∈ (2, 3). The expected replication factor of Random on p machines can be approximately bounded by:</p><formula xml:id="formula_11">E D p n n i=1 1 − 1 − 1 p di ≤ p 1 − 1 − 1 p Ω ,</formula><p>where</p><formula xml:id="formula_12">Ω = d min × α−1 α−2 .</formula><p>This theorem says that when the degree sequence is under power-law distribution, the upper bound of the expected replication factor increases as α decreases. This implies that Random yields a worse partitioning when the power-law graph is more skewed.</p><p>Like Corollary 1, we replace p with √ p to get the similar result for Grid.</p><p>Corollary 2. By using Grid method, the expected replication factor on p machines can be approximately bounded by:</p><formula xml:id="formula_13">E D √ p n n i=1 1 − 1 − 1 √ p di ≤ √ p 1 − 1 − 1 √ p Ω ,</formula><p>where</p><formula xml:id="formula_14">Ω = d min × α−1 α−2 . Note that √ p 1 − 1 − 1 √ p Ω ≤ p 1 − 1 − 1 p Ω</formula><p>. So Corollary 2 tells us that Grid can reduce the replication factor but it is not motivated by the skewness of the degree distribution. Theorem 4. Assume each edge is hashed by our DBH method and h i ≤ d i − 1 for any v i . The expected replication factor of DBH on p machines can be approximately bounded by:</p><formula xml:id="formula_15">E H,D p n n i=1 1 − 1 − 1 p hi+1 ≤ p 1 − 1 − 1 p Ω ,</formula><p>where</p><formula xml:id="formula_16">Ω = d min × α−1 α−2 − d min × α−1 2α−3 + 1 2 .</formula><p>Note that</p><formula xml:id="formula_17">p 1 − 1 − 1 p Ω &lt; p 1 − 1 − 1 p Ω .</formula><p>Therefore, our DBH method can expectedly reduce the replication factor. The term α−1 2α−3 increases as α decreases, which means our DBH reduces more replication factor when the power-law graph is more skewed. Note that Grid and our DBH method actually use two different ways to reduce the replication factor. Grid reduces more replication factor when p grows. These two approaches can be combined to obtain further improvement, which is not the focus of this paper.</p><p>Finally, we show that our DBH methd also guarantees good edge-balance (workload balance) under power-law distributions. </p><formula xml:id="formula_18">(d i − h i )   ≤ (1 + ) 2|E| p .</formula><p>Note that any that satisfies 1/ n/p could work for this theorem, which results in a tighter bound for large n. Therefore, together with Theorem 4, this theorem shows that our DBH method can reduce the replication factor and simultaneously guarantee good workload balance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Empirical Evaluation</head><p>In this section, empirical evaluation on real and synthetic graphs is used to verify the effectiveness of our DBH method. The cluster for experiment contains 64 machines connected via 1 GB Ethernet. Each machine has 24 Intel Xeon cores and 96GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Datasets</head><p>The graph datasets used in our experiments include both synthetic and real-world power-law graphs. Each synthetic power-law graph is generated by a combination of two synthetic directed graphs. The in-degree and out-degree of the two directed graphs are sampled from the power-law degree distributions with different power parameters α and β, respectively. Such a collection of synthetic graphs is separated into two subsets: one subset with parameter α ≥ β which is shown in Table <ref type="table" target="#tab_1">1</ref>(a), and the other subset with parameter α &lt; β which is shown in Table <ref type="table" target="#tab_1">1</ref>(b). The real-world graphs are shown in Table <ref type="table" target="#tab_1">1</ref>(c). Some of the real-world graphs are the same as those in the experiment of PowerGraph. And some additional real-world graphs are from the UF Sparse Matrices Collection <ref type="bibr" target="#b4">[5]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Baselines and Evaluation Metric</head><p>In our experiment, we adopt the Random of PowerGraph <ref type="bibr" target="#b5">[6]</ref> and the Grid of GraphBuilder [8]<ref type="foot" target="#foot_0">1</ref> as baselines for empirical comparison. The method Hybrid of PowerLyra <ref type="bibr" target="#b3">[4]</ref> is not adopted for comparison because it combines both edge-cut and vertex-cut which is not a pure vertex-cut method.</p><p>One important metric is the replication factor, which reflects the communication cost. To test the speedup for real applications, we use the total execution time for PageRank which is forced to take 100 iterations. The speedup is defined as: speedup = 100% × (γ Alg − γ DBH )/γ Alg , where γ Alg is the execution time of PageRank with the method Alg. Here, Alg can be Random or Grid. Because all the methods can achieve good workload balance in our experiments, we do not report it here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Results</head><p>Figure <ref type="figure" target="#fig_9">3</ref> shows the replication factor on two subsets of synthetic graphs. We can find that our DBH method achieves much lower replication factor than Random and Grid. The replication factor of DBH is reduced by up to 80% compared to Random and 60% compared to Grid.      Figure <ref type="figure" target="#fig_15">5</ref> shows the replication factor and execution time for PageRank on Twitter graph when the number of machines ranges from 8 to 64. We can find our DBH achieves the best performance for all cases.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we have proposed a new vertex-cut graph partitioning method called degree-based hashing (DBH) for distributed graph-computing frameworks. DBH can effectively exploit the power-law degree distributions in natural graphs to achieve promising performance. Both theoretical and empirical results show that DBH can outperform the state-of-the-art methods. In our future work, we will apply DBH to more big data machine learning tasks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Two strategies for graph partitioning. Shaded vertices are ghosts and mirrors, respectively.</figDesc><graphic url="image-2.png" coords="2,315.58,257.69,118.80,59.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 (</head><label>2</label><figDesc>b) shows a partitioning strategy by cutting the vertices {E, F, A, C, D}, and Figure2(c) shows a partitioning strategy by cutting the vertices {A, E}. We can find that the partitioning strategy in Figure2 (c) is better than that in Figure2(b) because the number of mirrors in Figure2 (c) is smaller which means less communication cost. The intuition underlying this example is that cutting higher-degree vertices can result in fewer mirror vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Partition a sample graph with vertex-cut.</figDesc><graphic url="image-3.png" coords="2,176.83,595.43,96.02,112.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>m}| as edge-imbalance, and p n max m |{v ∈ V | M aster(v) = m}| as vertex-imbalance. To get a good balance of workload, λ and ρ should be as small as possible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm 1</head><label>1</label><figDesc>Degree-based hashing (DBH) for vertex-cut GP Input: The set of edges E; the set of vertices V ; the number of machines p. Output: The assignment M (e) ∈ [p] for each edge e. 1: Initialization: count the degree d i for each i ∈ [n] in parallel 2:for all e = (v i , v j ) ∈ E do 3:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>m 1 −</head><label>1</label><figDesc>|{v ∈ V | M aster(v) = m}|, and k a = n p + 2n ln p p ln ln p 2a ln p .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Experiments on two subsets of synthetic graphs. The X-axis denotes different datasets inTable 1(a)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 4 (</head><label>4</label><figDesc>Figure4(a) shows the replication factor on the real-world graphs. We can also find that DBH achieves the best performance. Figure4 (b)shows that the relative speedup of DBH is up to 60% over Random and 25% over Grid on the PageRank computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Figure4(a) shows the replication factor on the real-world graphs. We can also find that DBH achieves the best performance. Figure4 (b)shows that the relative speedup of DBH is up to 60% over Random and 25% over Grid on the PageRank computation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Experiments on real-world graphs. The number of machines is 48.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Experiments on Twitter graph. The number of machines ranges from 8 to 64.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Theorem 5. Assume each edge is hashed by the DBH method with d min , {v i } n i=1 , {d i } n i=1 and {h i } n i=1 defined above. The vertices are evenly assigned. By taking the constant 2|E|/p = = nE D [d] /p, there exists ∈ (0, 1) such that the expected edge-imbalance of DBH on p machines can be bounded w.h.p (with high probability). That is,</figDesc><table><row><cell></cell><cell>n</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>E D</cell><cell>i=1</cell><cell>d i E H,D</cell><cell> </cell><cell>n i=1</cell><cell>h i p</cell><cell>+ max j∈[p]</cell><cell>vi∈Pj</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Datasets(a) Synthetic graphs: α ≥ β</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">(b) Synthetic graphs: α &lt; β</cell><cell></cell><cell cols="2">(c) Real-world graphs</cell><cell></cell></row><row><cell>Alias</cell><cell>α</cell><cell>β</cell><cell>|E|</cell><cell>Alias</cell><cell>α</cell><cell>β</cell><cell>|E|</cell><cell>Alias</cell><cell>Graph</cell><cell>|V |</cell><cell>|E|</cell></row><row><cell>S1</cell><cell>2.2</cell><cell>2.2</cell><cell>71,334,974</cell><cell>S10</cell><cell>2.1</cell><cell>2.2</cell><cell>88,617,300</cell><cell>Tw</cell><cell>Twitter [10]</cell><cell>42M</cell><cell>1.47B</cell></row><row><cell>S2</cell><cell>2.2</cell><cell>2.1</cell><cell>88,305,754</cell><cell>S11</cell><cell>2.0</cell><cell>2.2</cell><cell>135,998,503</cell><cell>Arab</cell><cell>Arabic-2005 [5]</cell><cell>22M</cell><cell>0.6B</cell></row><row><cell>S3</cell><cell>2.2</cell><cell>2.0</cell><cell>134,881,233</cell><cell>S12</cell><cell>2.0</cell><cell>2.1</cell><cell>145,307,486</cell><cell>Wiki</cell><cell>Wiki [2]</cell><cell>5.7M</cell><cell>130M</cell></row><row><cell>S4</cell><cell>2.2</cell><cell>1.9</cell><cell>273,569,812</cell><cell>S13</cell><cell>1.9</cell><cell>2.2</cell><cell>280,090,594</cell><cell>LJ</cell><cell>LiveJournal [16]</cell><cell>5.4M</cell><cell>79M</cell></row><row><cell>S5</cell><cell>2.1</cell><cell>2.1</cell><cell>103,838,645</cell><cell>S14</cell><cell>1.9</cell><cell>2.1</cell><cell>289,002,621</cell><cell>WG</cell><cell>WebGoogle [12]</cell><cell>0.9M</cell><cell>5.1M</cell></row><row><cell>S6</cell><cell>2.1</cell><cell>2.0</cell><cell>164,602,848</cell><cell>S15</cell><cell>1.9</cell><cell>2.0</cell><cell>327,718,498</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>S7</cell><cell>2.1</cell><cell>1.9</cell><cell>280,516,909</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>S8</cell><cell>2.0</cell><cell>2.0</cell><cell>208,555,632</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>S9</cell><cell>2.0</cell><cell>1.9</cell><cell>310,763,862</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc>(a)    and Table1(b). The number of machines is 48.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">GraphLab</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1">.2 released in July 2013 has used PowerGraph as its engine, and the Grid GP method has been adopted by GraphLab 2.2 to replace the original Random GP method. Detailed information can be found at: http://graphlab.org/projects/index.html</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgements</head><p>This work is supported by the NSFC (No. 61100125, No. 61472182), the 863 Program of China (No. 2012AA011003), and the Fundamental Research Funds for the Central Universities.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Lada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernardo</forename><forename type="middle">A</forename><surname>Adamic</surname></persName>
		</author>
		<author>
			<persName><surname>Huberman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zipf&apos;s law</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="150" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The webgraph framework I: compression techniques</title>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th conference on World Wide Web (WWW)</title>
				<meeting>the 13th conference on World Wide Web (WWW)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Graph structure in the web</title>
		<author>
			<persName><forename type="first">Andrei</forename><surname>Broder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ravi</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Farzin</forename><surname>Maghoul</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prabhakar</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raymie</forename><surname>Sridhar Rajagopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Stata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janet</forename><surname>Tomkins</surname></persName>
		</author>
		<author>
			<persName><surname>Wiener</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer networks</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="309" to="320" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Powerlyra: Differentiated graph computation and partitioning on skewed graphs</title>
		<author>
			<persName><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiaxin</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanzhe</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibing</forename><surname>Guan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
		<idno>IPADSTR-2013-001</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>Institute of Parallel and Distributed Systems, Shanghai Jiao Tong University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The University of Florida sparse matrix collection</title>
		<author>
			<persName><forename type="first">Timothy</forename><forename type="middle">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yifan</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Powergraph: Distributed graph-parallel computation on natural graphs</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Joseph E Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haijie</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
				<meeting>the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">GraphX: Graph processing in a distributed dataflow framework</title>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Reynold</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ankur</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Crankshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
				<meeting>the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Graphbuilder: scalable graph etl framework</title>
		<author>
			<persName><forename type="first">Nilesh</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guangdeng</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Theodore</forename><forename type="middle">L</forename><surname>Willke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Graph Data Management Experiences and Systems</title>
				<meeting>the First International Workshop on Graph Data Management Experiences and Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multilevel graph partitioning schemes</title>
		<author>
			<persName><forename type="first">George</forename><surname>Karypis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vipin</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Parallel Processing (ICPP)</title>
				<meeting>the International Conference on Parallel Processing (ICPP)</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">What is twitter, a social network or a news media</title>
		<author>
			<persName><forename type="first">Haewoon</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hosung</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sue</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th international conference on World Wide Web (WWW)</title>
				<meeting>the 19th international conference on World Wide Web (WWW)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Graphchi: Large-scale graph computation on just a PC</title>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
				<meeting>the 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<ptr target="http://snap.stanford.edu/data/index.html" />
		<title level="m">Stanford large network dataset collection</title>
				<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">GraphLab: A new framework for parallel machine learning</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Uncertainty in Artificial Intelligence (UAI)</title>
				<meeting>the Conference on Uncertainty in Artificial Intelligence (UAI)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Distributed graphlab: A framework for machine learning in the cloud</title>
		<author>
			<persName><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Very Large Data Bases (VLDB)</title>
				<meeting>the International Conference on Very Large Data Bases (VLDB)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Pregel: a system for large-scale graph processing</title>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName><surname>Matthew H Austern</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Aart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName><surname>Czajkowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data (SIGMOD)</title>
				<meeting>the ACM SIGMOD International Conference on Management of Data (SIGMOD)</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Measurement and analysis of online social networks</title>
		<author>
			<persName><forename type="first">Alan</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Massimiliano</forename><surname>Marcon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krishna</forename><forename type="middle">P</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bobby</forename><surname>Bhattacharjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM SIGCOMM conference on Internet Measurement</title>
				<meeting>the 7th ACM SIGCOMM conference on Internet Measurement</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">balls into binsa simple and tight analysis</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Raab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelika</forename><surname>Steger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Randomization and Approximation Techniques in Computer Science</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="159" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Streaming graph partitioning for large distributed graphs</title>
		<author>
			<persName><forename type="first">Isabelle</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gabriel</forename><surname>Kliot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD)</title>
				<meeting>the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD)</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fennel: Streaming graph partitioning for massive scale graphs</title>
		<author>
			<persName><forename type="first">Charalampos</forename><surname>Tsourakakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christos</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bozidar</forename><surname>Radunovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Milan</forename><surname>Vojnovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM International Conference on Web Search and Data Mining (WSDM)</title>
				<meeting>the 7th ACM International Conference on Web Search and Data Mining (WSDM)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">How to partition a billion-node graph</title>
		<author>
			<persName><forename type="first">Lu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanghua</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bin</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Haixun</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Data Engineering (ICDE)</title>
				<meeting>the International Conference on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
