<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards long-lived robot genes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2007-09-29">29 September 2007</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Paul</forename><surname>Fitzpatrick</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Italian Institute of Technology</orgName>
								<address>
									<addrLine>Via Morego, 30</addrLine>
									<postCode>16163</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giorgio</forename><surname>Metta</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Italian Institute of Technology</orgName>
								<address>
									<addrLine>Via Morego, 30</addrLine>
									<postCode>16163</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRA-Lab</orgName>
								<orgName type="institution">University of Genoa</orgName>
								<address>
									<addrLine>Viale F. Causa, 13</addrLine>
									<postCode>16145</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lorenzo</forename><surname>Natale</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Italian Institute of Technology</orgName>
								<address>
									<addrLine>Via Morego, 30</addrLine>
									<postCode>16163</postCode>
									<settlement>Genova</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Towards long-lived robot genes</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2007-09-29">29 September 2007</date>
						</imprint>
					</monogr>
					<idno type="MD5">734E1E327E23337141BB00E84125ED94</idno>
					<idno type="DOI">10.1016/j.robot.2007.09.014</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T11:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Humanoid robotics</term>
					<term>Free software</term>
					<term>Device drivers</term>
					<term>ICub humanoid</term>
					<term>YARP</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Robot projects are often evolutionary dead ends, with the software and hardware they produce disappearing without trace afterwards. In humanoid robotics, a small field with an avid appetite for novel devices, we experience a great deal of "churn" of this nature. In this paper, we explore how best to make our projects stable and long-lasting, without compromising our ability to constantly change our sensors, actuators, processors and networks. We also look at how to encourage the propagation and evolution of hardware designs, so that we can start to build up a "gene-pool" of material to draw upon for new projects.</p><p>We advance on two fronts, software and hardware. For some time, we have been developing and using the YARP robot software architecture [Giorgio Metta, Paul Fitzpatrick, Lorenzo Natale, YARP: Yet another robot platform, International Journal on Advanced Robotics Systems 3 (2006) 43-48], which helps organize communication between sensors, processors, and actuators so that loose coupling is encouraged, making gradual system evolution much easier. YARP includes a model of communication that is transport-neutral, so that data flow is decoupled from the details of the underlying networks and protocols in use. Importantly for the long term, YARP is designed to play well with other architectures. Device drivers written for YARP can be ripped out and used without any "middleware". On the network, basic interoperation is possible with a few lines of code in any language with a socket library, and maximally efficient interoperation can be achieved by following documented protocols. These features are not normally the first things that end-users look for when starting a project, but they are crucial for longevity.</p><p>We emphasize the strategic utility of the Free Software social contract [B. Perens, The open source definition, in: Chris DiBona, Sam Ockman, Mark Stone (Eds.), Open Sources: Voices from the Open Source Revolution, O'Reilly and Associates, Cambridge, MA, 1999] to software development for small communities with idiosyncratic requirements. We also work to expand our community by releasing the design of our ICub humanoid [N.G.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Robotics development is, in some ways, like natural evolution. Consider robot software. Every piece of software has its niche: the environmental conditions within which it can be used. Within this niche it will grow and change and perhaps expand to nearby niches. Some niches are large (standard PCs), some are medium-sized (for example robots like Khepera <ref type="bibr" target="#b20">[21]</ref>, Pioneer <ref type="bibr" target="#b17">[18]</ref> and AIBO <ref type="bibr" target="#b22">[23]</ref> to mention a few), and some are tiny (a newly developed humanoid). Software evolves quickly as new technologies get proposed and hardware changes; if trapped in too narrow a niche it tends to become obsolete and die, together with the efforts of the developers who have contributed to it. Robot hardware is subject in turn to the changes in the commercial and industrial environment. In academia, software and hardware designed for robotic projects are prone to obsolescence, because although graduate students may be talented developers they are rarely experienced and disciplined system engineers. Also, usually the development of a robotic platform is not the main goal of the people who are working on it but simply a means to an end. For such researchers hardware and software development are time consuming and tedious tasks that take away time and energy that could be better spent doing research. Yet at the same time, the design of a robotic platform is a delicate and crucial task that cannot be easily delegated to untrained personnel. In research laboratories fast changing hardware and lack of human resources too often narrow the niche in which robotic platforms live.</p><p>In this paper, we are concerned about how robotics researchers can avoid being caught in tiny niches, and how to prevent "genetic isolation" from setting in. We want to find a way to avoid this trap, without sacrificing the freedom to radically change hardware and software, a freedom that will be crucial in "bleeding-edge" research for years to come.</p><p>For software development, the best long-term solution to these problems is to facilitate code reuse both in time (from past to future) and space (between geographically dispersed people and institutions). For projects of a reasonable size this means following a modular approach, where software is ideally divided in independent components, that can be developed and maintained by different people so that efforts are shared among groups having distinct competences. A modular software platform is flexible. Obsolete modules are removed and substituted for newer ones without catastrophic effects. It is difficult to take advantage of code written by other people in different contexts unless that code avoids extraneous constraints and dependencies at all levels, from the hardware architecture to the development environment and programming language. In robotics, dependencies between modules need to be minimized also from the point of view of run-time performance; as long as resources are available the addition of new components should not clash with the overall behavior of existing ones (in terms of throughput, latency, etc.). And from the hardware development point of view, the robotic platform can be seen as another factor in the equation of code reuse. Common hardware, common protocols, electrical standards, sensors, etc. can certainly make our life easier. As it does for software, modularity can play a role in the hardware design too.</p><p>In this paper we describe our efforts to build a modular humanoid robot platform (see Fig. <ref type="figure">1</ref>). We describe YARP <ref type="bibr" target="#b10">[11]</ref>, an open source library that we have developed to support software development on humanoid robotics. With YARP we try to facilitate code exchange between researchers, especially when this speeds up the time it takes to develop a platform and use it for research. We here report aspects of YARP that we hope will contribute to longevity and interoperability of software developed for robotics. Analogously for hardware, we describe our efforts to create an open robotic platform, the ICub that can be shared among several research groups worldwide.</p><p>Following the Open Source philosophy we make the code of our software and the design of our hardware available so that other researchers can better understand it and have the freedom to improve and better adapt it to their needs. We think it is relevant to any small research group, either academic or industrial, who wishes to develop novel robots (as opposed to build applications on third party robots). We want to maximize the reach of such research groups, being mindful of the fundamental tension between providing a consolidated Fig. <ref type="figure">1</ref>. Our model of a humanoid robot's "brain". We assume a set of processors, some of which may be on the robot, some of which may not be. We draw no distinction; for research purposes, it makes sense to have offboard processing to do today what robots will be able to do on-board tomorrow. We assume diversity: different devices, operating systems, processors, different languages, libraries, etc. (of course, within our own project we have standards, but we don't expect everyone using our robot to agree). We exploit key Free Software tools for smoothing over differences in operating systems, build systems, and programming languages. We develop YARP, for smoothing over differences in networking, devices details, and libraries relevant to robotics. We release YARP as Free Software and use it to support our open robot platform, the ICub humanoid, whose design will be available under free and open licensing.</p><p>system and giving enough freedom to change every single part via upgrades and replacements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A software ecology</head><p>Our initial motivation was that many robot projects are "black holes", in terms of software. A lot of software gets sucked in, but very little comes out. Once a piece of software has been adapted to a particular robot, it takes a lot of work to extricate it again and apply it to another. Obviously the answer to this problem is modularity. So there are now several architectures/middleware/frameworks for modular robot systems, YARP being one of them. A major concern for any such middleware (including YARP) should be that it not also become in turn a "black hole" -the danger is that once a piece of software has been adapted to a particular architecture/middleware/framework, it may take a lot of work to extricate it again and apply it to another. That would be somewhat self-defeating in the long run, since reuse would only be practical as long as the same middleware was in use. So modularity alone is not a solution to software reuse, since different organizing architectures, middleware, or frameworks may be mutually incompatible. It is important that modules developed can fit into a broader "ecology": the complicated, sometimes messy collection of niches world-wide in which software development occurs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">C/C++</head><p>We decided to use C++ as the main language for development. This is motivated by the fact that C++ is an object oriented language that is widely used by many developers in Fig. <ref type="figure">2</ref>. With the aid of a set of free and open source tools, a C/C++ based project like YARP can have a very wide reach. C/C++ source code is quite portable and widely supported, but the infrastructure needed to compile such programs varies a great deal. Tools like autoconf and automake have smoothed over the differences for UNIX-like systems. CMake (left) goes further and makes projects easy to compile within a wide range of integrated development environments (including UNIX-like systems, but also Microsoft Visual C++, Apple Xcode, Kdevelop, etc). For operating-system dependent functions, we use the free and open source ACE library <ref type="bibr" target="#b6">[7]</ref>. SWIG (right) takes C/C++ source code and generates "wrappers" for it, usable from many different languages (including Matlab via Java).</p><p>the world, and is well supported and portable on almost all the available platforms. Perhaps more importantly for robotics, C++ allows writing very efficient code and interfacing with the hardware at the lowest level. The drawback is that the compile process varies a lot depending on the platform and development environment. For example Linux and Cygwin developers use mostly Makefiles, whereas Microsoft Windows developers may prefer Visual Studio project files. Although C++ has reached a fairly good level of portability which allows, with a reasonable effort, writing applications that compile on all platforms, it is still very common to have to wrestle to port code that was written for one platform onto another. On the other hand, following a modular approach, we would like our software to be as flexible as possible and be adaptable to the needs of users and the platform that they work on. In YARP, unavoidable dependencies have been made as localized as possible to modules that can be compiled or not depending on the underlying system and user choices. So for example applications that require a GUI get compiled only when the supporting libraries are installed on the system, and all the essential operations of YARP are independent of GUIs. We take similar care for dependencies on mathematical and image processing libraries.</p><p>Among the tools available for automatic configuraton of software packages, we decided to use CMake <ref type="bibr" target="#b18">[19]</ref>. CMake is a cross-platform, open-source build system. It produces build files for the environment of choice (e.g. makefiles for Unix, Borland and MinGW and project files for all Microsoft compilers) starting from a language independent description. The language of CMake is powerful enough to support a flexible configuration process based on the packages that are available in the system and the preferences of the user (see Fig. <ref type="figure">2</ref>). Through CMake the build process of YARP is robust, simple and flexible. CMake is free and open-source, with a healthy community of developers. We also maintain an autoconf build procedure for those UNIX users who prefer not to use CMake. We use another free and open-source tool called SWIG to make YARP easy to use from many different languages. In all these choices, we are following the practices of large successful open-source projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Free Software</head><p>The ability to integrate software modules into a system depends not just on the technical constraints attached to their use, but also the cultural constraints (be they social, legal, or commercial) they carry. For example, whether two modules can be integrated can depend not just on their interfaces but also on the conditions under which use of the modules is permitted by their respective creators, and what conditions the integrator wishes to apply to the aggregated system. This adds a great deal of complexity to the process of integration. In general, software produced under conditions where the creator has strong opinions about how it should be used, and enforces those opinions in licensing and other measures, does not make a good module to build on. It is possible, but painful.</p><p>The Free Software model <ref type="bibr" target="#b14">[15]</ref> is an alternative that strikes a different balance between creator and integrator. It proposes a set of standard freedoms which should be granted with software. Taken together these freedoms make the software actually useful as building blocks without excessive social, legal, or commercial complexity. The freedoms are enforced using copyright law principles that apply to most of the world.</p><p>The Free Software model says nothing about the cost of software, although it does tend to contribute to commoditization, driving the cost of infrastructure-related software such as web servers and operating systems down. Free software should not be confused with "freeware". Freeware software is available without charge but may have complex social, legal and commercial terms attached, and may or usually will not grant the freedoms associated with free software.</p><p>The effectiveness of free and open software is becoming better understood from a business perspective <ref type="bibr" target="#b27">[28]</ref>. The free and open model has had a crucial effect in the field of embedded devices, a large and growing market that overlaps with robotics, spurred by the existence of embedded Linux <ref type="bibr" target="#b5">[6]</ref>. We release all our work under free and open licences, in order to encourage their use as building blocks. Historically, our "YARP" software grew and developed this way, principally through a collaboration between robotics groups at MIT and the University of Genoa (Fig. <ref type="figure">3</ref>). Fig. <ref type="figure">3</ref>. A potted history of YARP (for more details, see <ref type="bibr" target="#b10">[11]</ref>). YARP was born on Kismet <ref type="bibr" target="#b1">[2]</ref>, grew up on Cog <ref type="bibr" target="#b2">[3]</ref> and BabyBot <ref type="bibr" target="#b11">[12]</ref>, and serves as the software architecture for the iCub humanoid <ref type="bibr" target="#b24">[25]</ref>. Along the way other humanoids have also used the system. With ICub, we are trying to create some hardware "genes" that can travel along too, so each robot does not need to be designed from scratch. There are currently nine copies of the ICub head.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Interoperating</head><p>The closest project in spirit to YARP is that of the Player project <ref type="bibr" target="#b26">[27]</ref>. The Player/Stage software collection is widely used in the field of mobile robotics, and is the nucleus of a healthy, pragmatic community of developers. YARP and Player were developed independently in different robotics communities (humanoids and mobile robots respectively) over a similar time period. Both over time became open source projects; Player was registered on sourceforge (a commonly used repository for open software) in 2001, and YARP in 2002. Initially there was little overlap or mutual awareness between the projects. In 2005, YARP began refactoring its device API, influenced by a Player paper on this topic <ref type="bibr" target="#b25">[26]</ref>. In particular, the existing "thin wrapper" of the hardware was augmented with a factory and remotization procedure. At about the same time, Player's networking was refactored to be more flexible ("Player 2.0", see <ref type="bibr" target="#b3">[4]</ref>) in order to break out of a client/server communication model and allow a more flexible network and transport choices -an area where YARP has historically been strong.</p><p>Culturally, Player is biased towards mobile (wheeled) robots, with sensing and algorithms for navigation being of central importance, while YARP is biased towards humanoid robots, where there are many loosely-coupled behaviours involving different sets of sensors and actuators. In our opinion (speaking of course just for ourselves, and not the Player developers), both projects are now at a state where if either project had existed in mature form before the other was started, the other could most certainly have been built by extension rather than as a separate development. To make YARP, Player would need to have its device and networking model decoupled further, its networking model and transport interface generalized yet again, and have some new drivers developed; to make Player, YARP would need to have many new devices developed, its use of ACE and some C++ features excised, and many localization and mapping related algorithms added. The extensions would be quite a bit of work, but certainly less than beginning from zero. So what should we say to a new researcher starting a project and not sure which to use? How bad is it to be faced with a choice of systems rather than a single coherent one?</p><p>The free software ecology contains many cases of long term side-by-side projects with somewhat different cultures and goals. We see diversity at every level: the operating system (GNU/Linux, FreeBSD, etc.), the desktop environment (Gnome, KDE), the command-line shell (bash, tcsh, etc.), and so on. When licensing permits it, code flows quite freely from project to project. In any case, the projects are mutually visible, in terms of source code, mailing lists, documentation etc. There is duplication of effort, but in the long run there is a growing consensus that this diversity is proving healthy. Since choice and change at every level is expected, individual parts tend to be more modular and robust than they would otherwise be in a "monoculture".</p><p>Ideally, with free and open software, the software "genes" (abstract programmer interfaces, protocols, actual implementation code, etc.) in different projects can flow back and forth or be aggregated. Useful genes will tend to be picked up, less useful genes will tend to languish. Software trapped behind proprietary or otherwise-awkward licences is unlikely to survive the death of the organization it belongs to.</p><p>It is instructive to look at two instances of YARP/Player aggregation:</p><p>• Since 2006, Player contains a "yarpimage" driver which can accept images from a YARP Network (see acknowledgements section for credits). The motivation for the driver was that YARP can transmit data using multicast, a transport not implemented in Player. This driver let Player treat YARP as a camera, just like any of the other more regular cameras for which Player already had drivers.</p><p>• Since 2007, YARP contains a "stage" driver which gives access to a 2D robot simulator associated with the Player project from a YARP Network. This driver lets YARP treat Player/Stage as a motor control system, just like any of the other more regular control boards for which YARP already had drivers.</p><p>These instances have the property that they "scratched an itch" -they met a need that a particular developer had. They also have the property that the impact each system has on the other is well localized, to a single module. Much deeper integration would be possible, but already just by being free and open source the projects can get along for any developer who needs something from both.</p><p>In the redesign of YARP's device approach, active steps were taken to reduce the coupling between devices and networking. This was motivated by general concerns of modularity, and also to make it simpler to take YARP devices, rip them out of the YARP library, and use them in other projects. The YARP device framework mandates a very thin C++ wrapper which permits direct function calls, rather than forcing operation through a message passing framework. The value added by YARP's wrapper is to simplify the externalization of device configuration (Player also has an equivalent of this) and to factor the device into interfaces corresponding to different device families (which is just good software engineering, shared by any good implementation of a hardware abstraction layer). The key extra value added by YARP is to stop precisely there. When writing a driver for a particular device, we make no assumptions about how it will be communicated with (this is an area in which YARP differs from Player). There is no mention of message queues, buffering, etc., unless the device already has such things internally.</p><p>It seems strange to claim that not doing something adds value. But this is the fundamental point of modularity, to refrain from making a dependency if you can avoid it. The reason why one might want to intertwine devices and networking is to achieve the important ability to control and monitor a device remotely. For YARP, this ability is implemented at the device family level rather than the level of individual devices. We provide proxy devices that can wrap any devices belonging to a given family (such as cameras or motor control boards) and make them accessible remotely. These proxies use YARP networking, but there's nothing to stop someone else writing Player proxies, or proxies for standard RPC-based systems.</p><p>We are often asked why we do not use CORBA for communication. Certainly, it would be possible. But we believe CORBA is a very good example of a middleware that has overreached. Using CORBA imposes a cost in terms of complexity and learning-curve that is hard to justify or pay for in an open-source project. KDE and GNOME, two major desktop environments, began with ambitions to use CORBA, but eventually backed away from it to simpler, more specialized libraries. One of those is called D-Bus, an interprocess communication library for desktop environments. Responding to the "why not use CORBA" question in their FAQ <ref type="bibr" target="#b19">[20]</ref>, they answer that an "IPC system API should not leak all over a program; it should come into play only just before data goes over the wire". We agree with this ideal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Devices and drivers</head><p>Code reuse becomes difficult at the level where algorithms communicate with the low-level hardware. The OS layer of YARP tries to minimize dependencies between algorithms and the hardware for which we define a constant interface (threading, memory, network, filesystem). Unfortunately more specific hardware (motor control boards and frame grabbers are popular examples) requires a more sophisticated mechanism. In these cases vendors provide device drivers and a set of APIs to the user. The API comes in the form of a static or dynamic library which is linked to the user's code. Unfortunately APIs vary a lot even within devices that belong to the same family. Even worse the API of the same hardware may vary on different operating systems or change on future releases of the hardware. User code becomes dependent on the particular board for which it was initially developed and bound to the decisions and assumptions of the vendor. For example, vendor A might decide to use integers to represent the position of a motor joint, whereas vendor B might decide to use a floating point variable. Otherwise interchangeable devices may have different "initialization" procedures. Consider for example a motor control board which has a serial interface to the host computer; the API of this board will probably require that some parameters (port number, baud rate, number of data bits, etc) are specified when the device is created. Suppose now that we obtain a more recent release of the same board that now has a USB interface. In this case the parameters to initialize the board are different and we are forced to rewrite all processes that use it (the situation is represented in Fig. <ref type="figure" target="#fig_0">4</ref>).</p><p>We call devices which can only be accessed using vendor supplied material "sticky devices" because they tend to make the particular set of assumptions chosen by the vendor stick to the user's code. A logical step in such a situation is to wrap the functionality supplied by the vendor in a facade, so that source code dependencies are reduced. In YARP wrappers can be made individually, compiled and built separately and optionally used across the network. This mechanism produces a level of separation between device-specific code and user code that is effective for "quarantining" the sticky devices. This is achieved in three ways: (i) definition of interfaces for families of devices (ii) localization and separation of device initialization and creation (iii) creation of network wrappers and separation between devices and communication.</p><p>Note that when we talk about "interfaces" here we do not refer to the interface description languages (IDLs) used in CORBA and other systems, but simply to a consistent API in C++. We avoid using IDLs because they impose extra constraints on the user's toolchain. Concerns related to communication are addressed in point (iii), not (i). We keep communication and device interfaces separate, so that users can exploit one and not the other as they wish, and also code written to use a device remotely can later be made local with only a cost of a single extra virtual method call compared to calling the vendor's API directly. This is important so that users do not need to go through a painful porting process if they discover at some point that remote operation is too slow for their application -for example, an implementation of inertialdriven stabilization eye movements (the so-called vestibular- ocular reflex) might require a very tight loop between sensors and motors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Device interfaces</head><p>An interface to a YARP device is the specification of the functionalities it provides. In practice in C++ an interface is a virtual base class, whose member functions define the ensemble of functionalities a device must implement in order to provide that interface. A YARP device is a "wrapper" class which implements all methods declared in its interface. A single device can of course expose more than a single interface (in C++ this is implemented through multiple inheritance). All details specific to the hardware (vendor's API and library) are handled in the wrapper class and are hidden behind its interfaces. The idea is that changes in the hardware are caught by the wrapper class and never propagated to the user code. As a result, if interfaces are well designed, the impact on the code due to hardware change is minimized. Of course, unique features of a device can be exposed in a new interface, but without much benefit over using the vendor's code directly for that specific feature. And any code written using that novel interface will need to be reworked if another device is substituted.</p><p>As discussed previously, initialization parameters may introduce annoying dependencies in the user's code. To solve this we have defined a common interface to all devices (the DeviceDriver interface) which normalizes how devices are initialized and uninitialized, and, more importantly, how initialization parameters are passed to them. In particular this interface defines two methods:</p><p>virtual bool open(yarp::os::Searchable&amp; config)=0; virtual bool close()=0; This open method initializes the device. Initialization parameters are passed to the function as a (typically nested) list of key-value entries represented as a Searchable object. A Searchable can contain all possible parameters that devices might require for initialization. Initialization parameters for devices are stored in ".ini" files (again in the form of a list of key-value entries). A process that wants to open a device reads the file and transfers its content into a Searchable object. This class plays a role in YARP similar to that of the ConfigFile class in Player/Stage, except generalized to work for parameters expressed as command line arguments, or passed across the network, or created in a GUI, etc. -we abstract across all the possible sources of configuration settings. The configuration object is passed to the device through the open function. It is worth stressing that up to now this procedure is totally device independent, because the parameters are just copied and not interpreted by the process. It is only in the implementation of the open method (in the wrapper class of the device) where the Searchable object is parsed to extract the parameters that will be used to initialize the device. The Searchable object is designed so that it can collect information about how it is used, yielding some basic documentation about the parameters relevant to a given device.</p><p>The close method performs all the operations required to shut down the device properly and release all the resources it was using. No parameters are required by this function.</p><p>YARP also defines interfaces to board families of devices, like frame grabbers or motion control boards. Overall interfaces captures similarities among devices and allows separating device dependent code from user code. To the extent that user code uses interfaces shared by other devices, another device can be substituted later without change to that part. This includes devices with different initialization procedures, or different APIs (see Fig. <ref type="figure" target="#fig_1">5</ref>). Devices can also be nested or assembled into composite structures if necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">A factory of devices</head><p>Encouraging device access through interfaces achieves a good level of separation between vendor/device specific APIs and user level code. Interfaces alone, however, do not guarantee a complete level of separation. In practice users must still specify the type of device they want to create. Care must be taken to avoid this introducing unwanted coupling between device-specific code and user code. A common software engineering practice is to localize object creation so to minimize the amount of code that is responsible for object creation and initialization. We have seen that in YARP part of this is realized by the DeviceDriver interface, which encourages all initialization procedures to be performed inside a standard open method. We then go one step further and encourage device creation to be delegated to a factory. The factory contains a list of all devices available in YARP and the corresponding functions to call to create them. It receives a list of initialization parameters, creates the device, and initializes it through the DeviceDriver interface (this is similar to the DeviceTable in Player). If the process is successful a valid pointer to the device is returned. This pointer is the only "access point" to the device and (via dynamic casts) its interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Device remotization: Network interfaces</head><p>A final level of separation is achieved by supporting device remotization, or operation across the network via proxies. This feature is desirable for many reasons. It allows separate compilation and execution of different parts of the system, to avoid (for example) the existence of motor control libraries on just a single OS constraining you to also do image processing on that same OS. It makes distributed processing easier, letting you shift processing to extra machines when the load becomes high. Remotization is in practice one of the major benefits offered by YARP and Player. In YARP, message production is done at the level of device families. The use of standard YARP APIs for families of devices makes it straightforward to substitute in a proxy instead of a local device. By using YARP ports for communication, with their defined protocols, remotization also gives us portability across different platforms, as it naturally defines a network interface that can be used to make resources available on one platform to processes compiled and running on a different one. This decouple the compilation, build environment, libraries, operating system and language dependencies of hardware and user software.</p><p>The remotization mechanism relies on the communication layer (see Section 4) and on two Network Wrapper devices, one acting as a Server and the other acting as a Client. Both network devices implement the very same interface of the device they wrap: the only difference is that they do not connect directly to the hardware but act as network proxies, talking to each other using a predefined protocol, which involves one or more YARP Ports configured for RPC and/or streaming as the nature of the device dictates (see Fig. <ref type="figure" target="#fig_2">6</ref>).</p><p>A process that wishes to connect to the remote device using the YARP code-base creates an instance of the Client Network Wrapper (the YARP code-base could be avoided by working with the network protocol directly, as described in Section 4). This wrapper exports exactly the same interface of the "wrapped" device so the process can pretend that it is connected to a real device. The Client Network Wrapper converts calls from the process into messages, sends them to the other end of the communication link, and, in case a reply is expected, waits for data and dispatches them to the calling process. The Server Network Wrapper waits for incoming connections from the network. In addition it creates an instance of the wrapped device to which it forwards requests from the network. If requests involve a reply theses are sent back to the calling port so that they are received by the remote client. The Server Network Wrapper gains access to the local device through its interface; as such it is a total independent entity that can be reused for devices of the same family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Transporting data</head><p>A very basic problem that keeps cropping up in robotics projects is simply how to move data around between sensors, processors and actuators. There's a universe of "middleware" solutions in existence for communication (see the survey in <ref type="bibr" target="#b9">[10]</ref> and the related-work review in <ref type="bibr" target="#b3">[4]</ref>). Our own preferred solution in YARP has the following features:</p><p>We use an abstract model of communication that is transport-neutral and peer-to-peer.</p><p>The underlying transport used for each individual connection between peers can be selected independently. Choices such as network versus shared memory, tcp versus udp, unicast versus multicast, text versus binary, which of several networks to transmit on, etc can be made on a case by case basis. We encourage such details to be external configuration choices rather than properties embedded in programs.</p><p>We are careful to have one text-mode transport that is extremely easy to implement, for those who wish to interact with a YARP system without using any of the YARP libraries or executables. We believe this is very important for supporting interoperability, and providing a gentle slope to integrating YARP into an existing system or vice versa.</p><p>The model of communication is not intertwined with our ideas about how devices work or how processes should be started/stopped. Thus users can "cherry-pick" the parts that work for them.</p><p>Communication in YARP generally follows the Observer design pattern. Special port 1 objects deliver messages to any number of observers (other ports), in any number of processes, distributed across any number of machines, using any of several underlying communication protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">The YARP Network</head><p>For the purposes of YARP, communication takes place through "connections" between named entities called "ports". These form a directed graph, the "YARP Network", where ports are the nodes, and connections are the edges. Each port is assigned a unique name, such as "/icub/camera/left". Every port is registered by name with a "name server". The goal is to ensure that if you know the name of a port, that is all you need in order to be able to communicate with it from any machine. The YARP name server (YNS) is a generalization of DNS name service on the public internet for converting from domain names to IP addresses. It is not concerned just with machines but all the details necessary to make a connection with a specific resource. The YARP name server is designed to be easily used by clients who are not themselves using the YARP libraries or executables.</p><p>The purpose of ports is to move data from one thread to another (or several others) across process and machine boundaries. The flow of data can be manipulated and monitored externally (e.g. from the command-line) at run-time. It can also be accessed without using the YARP libraries or executables, since the relevant protocols are documented. If messages follow YARP guidelines, then they can be automatically converted to and from a "text mode" connection, enabling human monitoring and intervention in the system, and providing an easy way to experiment with integration with non-YARP modules.</p><p>A port can send data to any number of other ports. A port can receive data from any number of other ports.</p><p>1 Don't confuse YARP ports with TCP/IP socket port numbers. We use the word "port" to refer to the former and "port number" to refer to the latter. Fig. <ref type="figure">7</ref>. Example of a network of ports. Images are transmitted from a camera ("/camera") port to a viewer ("/viewer1") port and the input of a visual tracker ("/tracker/image"). The tracker annotates the image, for example, by placing a marker on a tracked point, and transmits that to another viewer ("/viewer2"). The tracker also sends just the tracked position from a position output port ("/tracker/position") to a input controlling head position ("/motor/position"). Every port belongs to a process. They do not need to belong to the same process or be on the same machine as each other. Every individual connection can take place using a different protocol or physical network -in the figure multicast, udp, and tcp are shown.</p><p>Connections between ports can be freely added or removed, and may use different underlying transports. The use of several different transports and protocols allows us to exploit their best characteristics. TCP is reliable, it can be used to guarantee the reception of a message. UDP can be faster than TCP, but without guarantees. Multicast is efficient for distributing the same information to large numbers of targets. Shared memory can be employed for local connections. Text-mode operation is much more human-friendly, and a good place to get started with external integration. Fig. <ref type="figure">7</ref> shows a very simple network of ports for a visual tracking application.</p><p>Connections between ports in YARP can carry replies if desired (and if the underlying protocol supports that), so conventional "RPC" (remote procedure call) style synchronous operation is possible. We encourage streaming rather than RPC whenever possible, because RPC can make a network brittle by introducing strong coupling of timing between processes. For our implementation of ports, we have broken them down into several logically separable parts:</p><p>The carrier factory (called "Carriers"); carrier is our generic name for any different transport or protocol that can carry a connection. This factory maintains a list of managers for different kinds of connection. The user can extend this list with their own custom types of connection (for example, for a kind of network we've never considered, or a different implementation of an existing carrier). The core communications module (called "Port"). This will manage connect requests, disconnects, reading, writing, and various administrative details. It defers to the carrier factory to create specific connections and knows very little about their nature.</p><p>Reader and writer buffers (called "PortReaderBuffer" and "PortWriterBuffer"). In order for communication to be efficient and avoid unnecessary copies, objects being transmitted generally need to be left untouched until communication is complete. With the variety of possible connections and options possible, the details of this can become complicated. YARP implements a certain set of policies we think are good in the reader/writer buffer classes. These are wrapped around the Port class to provide a BufferedPort class that gives both a simple interface and efficient implementation, while keeping buffering and communication separable for those with strong opinions about how one or the other should be done.</p><p>The YARP network interface (called "Network"). Provides methods for manipulating parts of the network, such as creating or removing connections between ports.</p><p>The YARP name server is a simple program using a single ordinary port as its input; in the past, it had its own special protocol but now it is just like any other YARP program. This is possible because ports can operate without access to a name server if desired; it is another separable component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Human readable/writable communication</head><p>There is a constant tension between using binary formats and human-readable formats. Binary formats can be much more efficient, but text mode formats can be easier to work with and study experimentally. The value of text formats and protocols has been seen time and time again in the short history of computing (postscript, http, html, xml, etc.). YARP is constructed so that both binary and text mode operation is possible.</p><p>The YARP communications system is written in two parts. The first part is a set of "carriers" which do the work of providing connections between ports, so that data can be faithfully transmitted from a source to a destination bytefor-byte. The second (separable) part of the communication system is a standard data format. This standard is specified independently from the carriers, so that the carriers could be reused by someone with different opinions about data representation, but helper functions and classes make it easy to meet. This format is called the "bottle" format for historical reasons. <ref type="foot" target="#foot_0">2</ref> The bottle representation is based on a nested structure of certain familiar primitive types -lists, integers, floating point numbers, strings, binary blobs and a special "vocab" type that is basically an integer in binary mode (for fast dispatching) and a string in text mode (for easy reading and writing). The important point is that binary and text representations are interchangeable. Under normal operation, ports can be sending easy-to-parse binary messages to each other, but then when a human eavesdrops on that data or tries to insert a message, they can still understand and generate the messages in text mode. Bottle-style messages can be expressed in several interchangeable representations: binary, text, command-line options, configuration files, etc. We find that under various conditions sometimes we want the same kind of data coming from file, command line options, or across the network, so it is convenient to have all the various representations mapping to a homogeneous structure.</p><p>In principle, evolution of communication protocols in YARP can be relatively painless. Since new "carriers" can be added freely, new and old versions could live side by side for a release or two. Ideally, something like today's text mode format should be honoured for a long time, as a connection protocol of last resort.</p><p>The important point about the communication protocol is that is polymorphic and allows heterogeneous usethe protocol on each connection between two ports can be controlled independently. This allows for system evolution, where new protocols are introduced, potentially mapping onto radically different physical networks, virtual networks, or external middleware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">YARP without YARP</head><p>Suppose some YARP programs are running and we want to send or receive data from them. For example, suppose there is a YARP port called "/motors" which will accept commands to move a motor. For concreteness, let's imagine we have started the following standard YARP programs (on the same or different machines):</p><p>yarp server yarpdev --device test motor --axes 2 --single port --name /motors</p><p>The "yarpdev" program here creates a port called "/motors" that can accept command to a fake set of motors (two axes or degrees of freedom), and report on their state. Normally we would interact with the motor through a device API that takes care of communication details. But if for some reason we can't use the YARP codebase, what can we do? YARP ports listen to incoming connections of a certain default initial carrier (tcp), always ready to make new connections for input or output. Suppose we can discover that "/motors" is listening on port number 10022 of our current machine (we could discover that using netstat on Linux, or by querying the YARP server as we'll see shortly). We can then connect manually to the port as follows: Everything so far would be basically the same for any YARP port. For people who have used MUDs, IRC, or serial interfaces to hardware, it should all seem vaguely familiar. Of course we don't suggest actually using telnet, it is just a placeholder for socket communications in the user's language of choice. So far all our communications have been "administrative" -we have communicated with the port but not really with the program that owns it. To do that, we send payload data. For the text-mode carrier we've chosen (determined by the eight initial bytes we sent, "CONNECT " in this case -a different "magic number" would give multicast, UDP, TCP-binary, shared memory, etc.), this is done by typing "d", hitting return, and then writing a text-mode representation of the data we want to send. <ref type="bibr">Let</ref> We have determined that there are indeed two axes available as we requested when starting yarpdev, and have set the position target for the first axis to 100.0 units. We could go on to query positions, use other interfaces, etc. We can disconnect by closing our connection (or, more politely, sending the message "q").</p><p>By default, the motor port will stream encoder readings from the motors to any reader that connects. To subscribe to this stream, we simply connect as above and then type "r" to reverse the connection. Reversing means to invert which side should take the initiative in sending data.</p><p>Suppose we wanted to send messages more efficiently? We start out the same way, connecting via TCP, and then give the "magic number" of the carrier we want to use (tcp binary, udp, mcast, shmem, etc). Understanding these carriers is a bit harder than basic text-mode operation, but they are documented.</p><p>One part we skipped at the start was how to discover how to access ports in the first place. If we know the port we want is called "/motors", how do we discover where it is? We can in fact talk to the yarp name server using exactly the same protocol that we have described here. What socket port the name server listens to is reported when it starts (and can be configured, or discovered using a broadcast protocol).</p><p>So, with a running YARP system, we can discover and communicate with running programs, sending commands and reading data, without using any YARP libraries or executables. All the steps we've gone through are trivial in any language with a basic socket library (we're not using any special features of telnet, it is just for demonstration purposes). It is important to remember, though, that while we've been communicating with the "/motors" port using text across tcp, at the same time the same port could be communicating with other programs via binary messages over udp or multicast etc. We believe the existence of the bottle format for communicating with YARP processes makes it much easier to experiment with and build bridges to in text-mode (like http for the web), while gracefully supporting switching to binary-mode communication when the situation demands it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RobotCub and ICub</head><p>RobotCub is a collaborative project funded by the European Commission under the Framework 6 programme and it is part of the Cognitive Systems effort coordinated by the Unit E5 <ref type="bibr">[30]</ref>. One of the goals of RobotCub is that of creating an open platform where many other projects could thrive by exploiting a common hardware and software infrastructure. RobotCub has also the goal of making the ICub (this is the name of the robot, see Fig. <ref type="figure" target="#fig_3">8</ref>) the platform of choice for several other research groups worldwide and, simultaneously, to advance our knowledge of natural and artificial cognitive systems.</p><p>One of the tenets of the RobotCub stance on cognition is that manipulation plays a key role in the development of cognitive capability. Consequently, the design is aimed at maximizing the number of degrees of freedom of the upper part of the body (head, torso, arms and hands). The lower body (legs) is made to support crawling on the four limbs and sitting on the ground in a stable position with smooth autonomous transition from crawling to sitting. This allows exploration of the environment, grasping and manipulation of objects lying on the floor. The total height is estimated to be around 105 cm. The total number of degrees of freedom (DOF) is 53 of which 41 in the upper body (seven for each arm, nine for each hand, six for the head and three for the torso and spine). Each leg consists of six additional degrees of freedom. The sensory system will include binocular vision and haptic, cutaneous, aural, and vestibular sensors. We cared particularly in placing the sensors as in the human body and consequently there are two moving eyes with cameras, two microphones surrounded by pinnae, the inertial sensing is located in the head and tactile sensors are planned to cover as much as possible of the robot body. Each joint is also equipped with position and temperature sensors (for safety of operation). There are plans for adding joint-level torque measurement and eventually implement force/impedance control. Functionally, the system should be able to coordinate the movement of the eyes and hands, grasp and manipulate lightweight objects of reasonable size and appearance, crawl using its arms and legs, and sit up. This allows the system to explore and interact with the environment not only by manipulating objects but also through locomotion.</p><p>The philosophy adopted by RobotCub is that of the free software movement, as codified by the General Public Licence (GPL). On the software side, the RobotCub project adopted YARP and contributed to the development of some new specific features. For the hardware, we selected the GPL licence for the sources and FDL for documentation and drawings. While it is clear how to apply these licensing schemes to source code (e.g. C++), we need to clarify how to apply them also to hardware designs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Open Source hardware</head><p>The phrase "Open Source hardware" might sound strange, but in fact it is a plain transfer of the open source philosophy to the entire design of the RobotCub platform. Open Source hardware is starting to be heard more frequently, together with its quasi-synonym of "Open Design". On the Wikipedia under the chapter "Open Design", we can read:</p><p>[...] open design may provide a framework for developing very advanced projects and technologies that might be beyond the resource of any one company or country and involve people who, without the copyleft mechanism, might not otherwise collaborate.</p><p>This sentence summarizes one important point of the RobotCub idea, that is, the development of an advanced project that requires resources beyond those available in any one laboratory and involving people that collaborate through the copyleft mechanism.</p><p>The design of the robot started from the preparation of specifications (e.g. estimation of torque, speed, etc.), a typical 3D CAD modelling, and eventually in the preparation of the executive files which are used to fabricate parts and for assembly. Without good documentation it is very complicated to build and assemble a full robot. This means that documentation (as for software) is particularly important.</p><p>The CAD files, in some sense, can be seen as the source code, since they are the "preferred form of the work for making modifications to it", in the language of the GPL. They get "compiled" into 2D drawings which represent the executive drawings that can be used by any professional and reasonably well-equipped machine shop either to program CNC machines or to manually prepare the mechanical parts. This compilation process is not fully automated and requires substantial human intervention. There is a clear dependency of the 2D drawings on the original 3D CAD model. To enable the same type of virtuous development cycle as occurs in open source software, the 3D CAD is required, since changes happen in 3D first and get propagated to 2D later. In addition, assembly diagrams, part lists and all the material produced during the design stage should be included to guarantee that the same information is available to new developers.</p><p>One difference between software and the hardware design is that there are currently no effective formats for interchange of 3D models. Proprietary systems such as SolidWorks and Pro/E can import and export a range of formats, but going from one to another is lossy, destroying information needed for production and leaving just the basic geometrical shape. So in practice, designs are tied to tools produced by a particular vendor, and interoperability between hardware design tools is limited. In RobotCub we were forced to choose a specific set of tools for mechanical and electronic CAD and future upgrades will have to strictly adhere to these standards. Due to the absence of open source professional design tools, RobotCub uses proprietary products. This is an unfortunate situation, but there is no practical alternative at the moment. The "C++" and "gcc" of CAD do not yet exist.</p><p>As a practical matter, the simple duplication of RobotCub parts does not require the use of any of these tools since we provide all executive drawings and production files (e.g. Gerber files for the PCBs). For modification, the design tools are somewhat expensive (educational discounts or educational releases exist). Free of charge viewers are currently available for all file types in question.</p><p>For RobotCub, we decided to license all the CAD sources under the GPL which seems appropriate given their nature. Associated documentation will be licensed under the FDL. These will be made available through the usual source code distribution channels (e.g. repositories, websites).</p><p>Another difference with respect to GPL on software is that the cost of duplication is significant and variable. Copying and duplicating software has a negligible cost and the copy is as functional as the original. To copy the hardware requires access to a well-equipped machine shop and to specialized machines for fabrication of the electronics. The process of assembling the parts is also non-trivial with possibly additional use of special tools and machining. Copying software is almost error-free, hardware incurs in additional cost related to mistakes and parts that needs to be brought within specs. A similar consideration applies to open source microprocessor cores although this is an area where open design might become effective quickly because of the availability of FPGAs (see for example www.opencores.org). In practice, the cost of the copy of the microprocessor core is getting reasonably low and sufficiently bug free. It is difficult to foresee though how this technology could compete in the tough market of microprocessors where it seems that performance and innovation equates with large investment. This would represent an achievement similar to Linux, which has started being used as a serious alternative base to server applications (e.g. databases, web servers).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">The design process</head><p>The design process of RobotCub has been a distributed effort as for many open source projects. Various groups developed various subcomponents and contributed in different ways to the design of the robot including mechanics, electronics, sensors, etc. In particular, a whole design cycle was carried out for the subparts (e.g. head, hand, legs) and prototypes built and debugged. The final CAD and 2D drawings were discussed and then moved to the integration stage. Clearly, communication was crucial at the initial design stage to guarantee a uniform design and a global optimization.</p><p>The distributed design broke down at the integration stage where the industrial partner 3 stepped in to carry out integration, verification and consistency checks. The design and fabrication of the control electronics was also subcontracted to a specialized company. It is important to stress the collaboration with industry for a project of this size and with these goals and requirements. For many reasons building a complete platform involves techniques and management that is better executed by applying industrial standards. One example that applies to RobotCub is the standardization of the documentation.</p><p>A further strategy used in RobotCub is that of building early. Each subsystem was built as soon as possible and copied also as soon as possible. In several cases debugging happened because the copies of the robot did not work as expected or easy to fix problems were spotted. Sometimes the documentation had to be improved. Unfortunately, this strategy was applied less extensively to some of the subparts which are or were still under design and debugging.</p><p>The design stage will be completed by the realization of ten copies of the ICub. This will further test the documentation and in general the reliability of the overall platform including software, debugging tools, electronics, etc. The first release of the ICub will be consolidated after this final fabrication stage.</p><p>The actual design of the robot had to incorporate manipulation by providing sophisticated hands, a flexible oculomotor system, and a reasonable bi-manual workspace. On top of this, the robot has to support global body movements such as crawling, sitting, etc. These many constraints were considered in preparing the specifications of the robot and later on during the whole design process.</p><p>The behaviours we set forward for representing the robot's skills generate two types of constraints:</p><p>• kinematics: about the geometrical construction of the robot;</p><p>• dynamics: about the forces and torques we require from the robot.</p><p>The possibility of achieving certain tasks is favoured by a suitable kinematics, and in particular this translates into the determination of the range of movement and the number of controllable joints (where clearly replicating the human body in detail is impossible with current technology). Kinematics is also influenced by the overall size of the robot. We decided a priori to target the size of a three and a half year old child (approximately 1 m tall). Actual dimensions were taken from studies in ergonomics and x-ray images <ref type="bibr" target="#b23">[24]</ref>. This size can be achieved with current technology. QRIO <ref type="bibr" target="#b28">[29]</ref> is an example of a robot similar in size although with less degrees of freedom. In particular, our specifications had to consider hands and moving eyes. Also, we wanted to consider the workspace and dexterity of the arms and thus a three degree of freedom shoulder was a requirement.</p><p>Considering dynamics, the most demanding requirements appear in the interaction with the environment. Impact forces, for instance, had to be considered for the crawling behavior, but also and more importantly, developing cognitive behaviours such as manipulation might require exploring the environment erratically. As a consequence, it is likely that impacts will occur with various parts of the robot structure. This turns out to require strong joints, gearboxes, and powerful actuators or alternatively passive compliance and soft materials. In order to evaluate the scale (order of magnitude) of the required forces we ran simulations of various behaviors in a reasonable model of the robot. These dynamic simulations provided data for starting the design of the robot.</p><p>At a more general level we had then to evaluate the available technology, compared to the experience of the RobotCub consortium and the targeted size of the robot: it was decided that electric motors represent the most suitable technology for the ICub, given also that it has to be ready according to a very tight schedule in the span of the RobotCub project. Other technologies (e.g. hydraulic) are left for a "technology watch" activity and they were not considered further.</p><p>In addition, given the size of the robot, and given the power density available, considerations of speed for certain joints lack significance: i.e. given the power and the torques required, speed is a consequence rather than a design parameter. In certain cases, in comparing to human data, clearly also the power density is much lower than desired (e.g. the wrists cannot possibly support the weight of the robot).</p><p>Finally, the ICub is not only about motors, sensors are equally important. Also in this case, we had to deal with and exploit the available technology as best we could. The robot has vision, audition, joint sensors, force sensors, tactile sensors -where possible -and temperature sensors in many of the motors. The robot can give feedback through a speaker. ICub will thus include a plethora of sensors as cameras, microphones, gyroscopes, linear accelerometers, encoders (or other positional sensors), temperature and current consumption sensors, force/torque and tactile sensors. The choice of these components is clearly related to the robot specifications.</p><p>To recapitulate, the constraints of size and available technology determine a good part of the design choicesi.e. our freedom in deciding which components to use. In parallel, we simulated some of the robot's behaviours to determine the required joint torques. These two pieces of information were then used in selecting the best available motors compatible in size, torque, and strength. As we mentioned earlier, speed is a consequence rather than a design parameters here, although, in simulation we examined the dependency of speed to torque for crawling.</p><p>Other design choices are related to the embedded electronics and the structure of the software. The ICub will have many sensors and actuators working in parallel. We would like to exploit this parallelism also at the computational level and, consequently, the ICub API was mapped one-to-one onto YARP.</p><p>There is a more profound and somewhat philosophical consideration to be factored in about the design of a robotic platform, especially when the claim is that it is designed to support investigation on the development of cognitive behaviours. The core of the question is whether a given structure of the body and corresponding dynamics can support certain cognitive skills: e.g. can a robot with limited manipulation abilities learn certain properties of objects? Does the lack of certain skills prevent learning certain concepts about the environment? What type of dynamics can favour behavioural and energy efficiency? This relates to the question of discovering the affordances of the environment given the agent's body. A full discussion of these issues is clearly outside the scope of this paper: for an extended treatment the reader is referred to <ref type="bibr" target="#b15">[16]</ref>.</p><p>In theory, understanding the dynamics of cognition should be eventually reflected into the design of the robot. In practice, this is a full research programme in itself. Mindful of this potential problem, the ICub has been designed following the more traditional approach discussed earlier. The truth is that there is no formalism and not to mention understanding of cognition that could support such a "complete" design process. What we propose though is that the ICub is the starting point, which supported by the open source approach, can become part of the virtuous development cycle that created Linux and support an ever growing repository of open software (e.g. sourceforge.net with more than 150.000 registered projects).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Modularity</head><p>The ICub design is modular across two dimensions, namely, the mechanical hardware and the control structure. Mechanically, the robot has a certain degree of modularity which allows for improvements without a full-blown redesign activity. The controller is modular in the sense that it is made of several layers. Each layer can be replaced with a different technology and/or implementation without much suffering.</p><p>When we consider hardware modularity, we need to strike a balance between the desirability of a global optimization and the advantages of modular and dependable design. The current design probably reflects more the desire to achieve certain functionalities, within a given size, in a constrained setting of three years dedicated to design rather than the search for the quality and maintainability of the robot in the long term. In essence, the ICub is and will remain a research platform. It cannot be considered akin to the AIBO, nor a more industrial realization like the HRP2.</p><p>In spite of these stringent requirements the ICub shows modularity and macro-subgroups can be identified in the hand plus forearm, in the arm (entire arm), in the head, the torso and the legs. These parts can be built and maintained, developed and assembled separately. Finer grained modularity is not possible because of the placement of the motors and the routing of the tendons. The electronics represent another element of complication since the control cards for certain groups are not localized within the groups (e.g. the hand controllers are in the upper arm section).</p><p>Assembly techniques have been considered for mechanical parts and details have been optimized to favour mechanical realization (e.g. tendon routing has been considered and the Fig. <ref type="figure">9</ref>. The layered structure of the ICub. The lowest level is the DSP layer which directly connects to the motors and/or sensors. The next hardware level is represented by the PC104 HUB which interfaces on one side to all data sources and controllers and on the other to the GBit Ethernet network. The next layer is a distributed computation engine made of a set of standard PCs which communicate through YARP. On top of this the RobotCub partners will develop a cognitive architecture. Communication is defined by protocols as, for example, from the DSP to the motors, from the PC104 to the DSP and from the YARP processes to the PC104. Standardization at this level favours reusability and dependability of the system. assembly sequence optimized whenever possible). Nonetheless the realization of the hands (the most complicated parts of the robot) requires considerable time and effort.</p><p>At the controller level, modularity is described by at least three layers:</p><p>• the DSP-controller level;</p><p>• the HUB-coordination level (interface);</p><p>• the control architecture.</p><p>The DSP level consists of a set of controller cards that can drive the motors directly but also by virtue of programmability enable the preparation of local sophisticated control algorithms. These controller cards were specifically designed for the ICub. They communicate through a set of four CAN bus backbones to a Pentium-based HUB card which can do both synchronization of sensorial and motoric data and run simple control loops in case they are needed to be local to the hardware (for very tight timing). The Pentium, a PC104 format CPU card, is interfaced to YARP processes through a Gbit Ethernet cable. The interface at this level is fully YARP-compatible and specified at the level of ports or device drivers. The YARP processes form the control architecture and can implement complex cognitive behaviours (as indicated in Fig. <ref type="figure">9</ref>).</p><p>Protocols are specified at each level. Electrical between the controllers and the motors (determined by the motor specifications), software and electrical (CAN) between the DSP and the PC104 HUB, also software at the level of the YARP packets that travel on the GBit Ethernet cable, and clearly software between the modules of the cognitive architecture. Replacement of components, as long as the protocols remain unchanged, is likely to require only the redesign of the appropriate layer. For example, the obsolescence of the DSP microcontroller currently in use may lead to a new version that can be made compatible with the current CAN bus specification.</p><p>A simulator is being developed for the robot (in fact, two simulators, see Fig. <ref type="figure">10</ref>). This is useful for testing algorithms prior to execution on the actual robot, to check for any gross problems. We also anticipate that it will be useful for those wishing to get to know about the platform before actually having the hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>In recent years we have seen the beginning of many new and ambitious robotic projects <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b16">17]</ref>. However, research to provide intelligence to these complicated robots is advancing at a snail's pace. Accumulating knowledge in the form of working demonstrable systems is plagued by the difficulty of forming teams, agreeing on standards and in general by the lack of a critical mass in any existing laboratory no matter the size or funding.</p><p>The problem of artificial intelligence is a deep one; since it began to be investigated, each generation of researchers has grossly underestimated the problems. For example, the Summer Vision Project of 1966 at the MIT AI Lab planned to implement figure/ground separation and object recognition on a set of objects such as balls and cylinders in the month of July, and then extend that to cigarette packs, batteries, tools and cups in August <ref type="bibr" target="#b13">[14]</ref>. As it turns out, if they had written decades rather than months, it would still have been overambitious. Significant progress can certainly be made either because of a breakthrough in our understanding of the problems or through a slower accumulation of knowledge. Or it can be Fig. <ref type="figure">10</ref>. The ICub robot has two simulators. One uses the (proprietary) Webots package, and the other uses the Open Dynamics Engine (ODE) library directly. The Webots interface is shown in the top image, and is currently the most complete simulation. The ODE simulation (lower row) is currently of the robot's upper torso. Shown from left to right: the ICub simulation tracking its hand visually; the view from the "dominant" camera used for tracking; the view from the non-dominant camera; the robot arm hitting a table, causing the blue ball to roll off. See the acknowledgements section for simulator author credits. The two simulators and the actual robot have the same interface either when viewed via the device API or across network, and so are all more or less interchangeable from a user perspective. There are of course differences in the detailed behaviour of all three, which we hope to reduce over time.</p><p>due to a combination of these two elements. We, like many others, are drawn to robotics as a way to confront the "real" problems of intelligence head on. This has the advantage of exposing unforeseen opportunities that embodiment brings with it <ref type="bibr" target="#b15">[16]</ref>, but the downside that it requires a lot of time spent building hardware. It would be beneficial to build a community that can accumulate knowledge and make effective progress, and to expand the niche of humanoid robotics and artificial intelligence to the point where it is healthy and selfsustaining.</p><p>In this respect, the parallel with the commercial PC is easily made. The success of the PC was determined, among other factors, by the definition of hardware standards that everybody could understand, copy and reimplement. From time to time new standards were required (e.g. the ISA bus slowly left space to PCI slots) but the system flourished. Under the hood, the PC is a few orders of magnitude faster and of larger storage capacity. On the software side, the benefit of a common architecture allowed the creation of operating systems and application software consisting of several millions of lines of code. Without a standard hardware things might have been more difficult. A PC of today is the modern version of the Ship of Theseus,<ref type="foot" target="#foot_1">4</ref> everything changed but the PC is still considered a PC.</p><p>Is robotics really facing the same challenges as the computer industry three decades ago <ref type="bibr" target="#b4">[5]</ref>? It is clearly difficult to foresee the future of humanoid robotics. However, a few dedicated software platforms are appearing as either commercial <ref type="bibr" target="#b21">[22]</ref> or academic <ref type="bibr" target="#b26">[27]</ref> products (see also <ref type="bibr" target="#b9">[10]</ref> for a survey). It is easier to imagine a scenario where common standards both in software and hardware will find the fertile soil to flourish when isolated breakthroughs will happen.</p><p>The problem of dealing with diverse hardware and software in robotics is a complicated one -see <ref type="bibr" target="#b12">[13]</ref> for a good description of the many and various problems. The key insight from the Free Software community is the value a common social contract, granting mutually beneficial rights that greatly reduce both the direct and organizational cost of software integration. Regardless of the technical measures we pursue, adopting such a social contract in at least a part of the humanoid robotics community would be a key advance. We believe that this will occur naturally "bottomup" through pseudo-evolutionary forces: models of software development that are long-lived and fertile will survive, other forms will die off. The rate at which this will occur is hard to say, and could be influenced by education. For example, a common fear is that such approaches are incompatible with commercial exploitation; in fact they are not, as has been learned in many other fields including embedded devices <ref type="bibr" target="#b5">[6]</ref>. They do change the rules of the game though, which is disruptive. We should welcome that disruption.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example of code dependency. (A) VABoard is a motor control board which interface to the robot through serial port. The user's code contains code to initialize the board and control the robot through the API library provided by the vendor. (B) A new motor control board is connected to the robot; this new device has a USB interface and a different API. The differences are propagated to the user's code which must be rewritten.</figDesc><graphic coords="5,315.72,66.76,242.64,154.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Interfaces allow code reuse. VABoard and VBBoard (see Fig. 4) now implement the same interfaces (through their respective wrapper classes). The user's code accesses the hardware through these interfaces and is not aware of the details of how the methods are actually implemented. The different initialization parameters are listed in configuration files and are thus separated. VABoard and VBBoard are now completely interchangeable.</figDesc><graphic coords="6,120.65,66.76,344.16,155.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Network wrappers allow device remotization. A generic Server Network Wrapper exports the YARP interface of VABoard so that it can be accessed remotely by another machine. At the other side of the communication link the Client Network Wrapper exports the same interface of the remote device so that it can be transparently accessed by the client code. The local device and the Client Network Wrapper are totally interchangeable, the only difference between the two is in term of performance (the time it takes to execute a function) and initial configuration.</figDesc><graphic coords="7,123.81,66.76,357.48,164.16" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The ICub at various stages of construction. Panel (A) shows the head of the robot with part of the embedded electronics and sensors; in (B) the upper torso showing also the left hand; (C) shows a first realization of the legs (now improved); (D) a tentative assembly of the entire robot, showing its scale; (E) a more recent assembly, showing the robot supporting its own weight passively.</figDesc><graphic coords="9,106.89,66.76,391.32,324.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>demo at tcp://127.0.0.1:10032...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="14,145.49,66.76,294.48,209.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="15,107.61,66.76,389.88,234.72" type="bitmap" /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>From YARP's online documentation: The name of this class comes from the idea of throwing a "message in a bottle" into the network and hoping it will eventually wash ashore somewhere else. In the very early days of YARP, that is what communication felt like.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_1"><p>The Ship of Theseus -the mast gets replaced, the planks get replaced, over time everything may get replaced, but it is still in some important sense the same ship ("paradox of identity").</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>YARP and ICub make heavy use of software released under free and open licences -thank you world. The authors would like to gratefully acknowledge contributions to YARP from Alessandro Scalzo, Francesco Nori, Radu Bogdan Rusu, Alexis Maldonado, Eric Mislivec, Christopher Prince, Charles C. Kemp, Julio Gomes, Alexandre Bernardino, Carlos Beltran, Jonas Ruesch, Assif Mirza, Hatice Kose-Bagci, Mike P. Blow, Lars Olsson, Jose Gaspar, Claudio Castellini, Michael Bucko, Nelson Gonc ¸alves, Marco Barbosa, Tomassino Ferrauto, Boris Duran, Mattia Castelnovi and Giacomo Spigler (if we missed anyone, please let us know). The "yarpimage" driver mentioned in Section 2.3 was written by Radu Bogdan Rusu.</p><p>We are happy to be just one set of contributors to the ICub platform amongst the larger team of the RobotCub Partners and the RobotCub Consortium. ICub software contributers include (with some overlap with YARP): Alessandro Scalzo, Alexandre Bernardino, Alexis Maldonado, Basilio Noris, David Vernon, Eric Sauser, Micha Hersch, Fabio Berton, Jonas Hornstein, Jonas Ruesch, Lijin Aryananda, Ludovic Righetti, Manuel Lopes, Julio Gomes, Plinio Moreno, Vadim Tikhanoff and the authors (if you are not listed, please check that you have correctly placed a copyright and copy-policy statement in your source code). The simulators shown in Fig. <ref type="figure">10</ref> were developed by Ludovic Righetti (Webots-based simulator) and Vadim Tikhanoff (ODE-based simulator). Our thanks to the reviewers for their constructive feedback, which made this a better paper. The authors were supported by European Union grant RobotCub (IST-2004-004370).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>His research activities are in the fields of biologically motivated and humanoid robotics and in particular in developing lifelong developing artificial systems that show some of the abilities of natural systems. His research developed in collaboration with leading European and international scientists from different disciplines like neuroscience, psychology and robotics.</p><p>He is author or co-author of approximately 90 publications. He has been working as research scientist and co-PI in several international and national funded projects. He has been reviewer for international journals and a few funding agencies. His research focuses on developmental robotics, sensorimotor learning and perception in artificial and biological systems. He is also interested in software development and integration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lorenzo Natale received his degree in Electronic</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Humanoid robots: A new kind of tool</title>
		<author>
			<persName><forename type="first">Bryan</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Breazeal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rodney</forename><forename type="middle">A</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Scassellati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Intelligent Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="25" to="31" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Active vision for sociable robots</title>
		<author>
			<persName><forename type="first">Cynthia</forename><surname>Breazeal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aaron</forename><surname>Edsinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><surname>Scassellati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics A</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="443" to="453" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Breazeal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marjanovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Scassellati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Cog project: Building a humanoid robot</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">1562</biblScope>
			<biblScope unit="page" from="52" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Player 2.0: Toward a practical robot programming framework</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Toby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruce</forename><forename type="middle">A</forename><surname>Collett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">P</forename><surname>Macdonald</surname></persName>
		</author>
		<author>
			<persName><surname>Gerkey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Australasian Conference on Robotics and Automation</title>
		<meeting>the Australasian Conference on Robotics and Automation<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-12">December 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A robot in every home</title>
		<author>
			<persName><forename type="first">B</forename><surname>Gates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific American</title>
		<imprint>
			<biblScope unit="page" from="58" to="65" />
			<date type="published" when="2007-01">January. 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Selective revealing in open innovation processes: The case of embedded Linux</title>
		<author>
			<persName><forename type="first">J</forename><surname>Henkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Research Policy</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="953" to="969" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Stephen</forename><forename type="middle">D</forename><surname>Huston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Umar</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><surname>Syyid</surname></persName>
		</author>
		<title level="m">The ACE Programmer&apos;s Guide</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The development of honda humanod robot</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hirai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hirose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Haikawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Takenaka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Robotics and Automation</title>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="1321" to="1326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Humanoid robot HRP-2</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kaneko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kanehiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kajita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hirukawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Robotics and Automation</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="1083" to="1090" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Development environments for autonomous mobile robots: A survey</title>
		<author>
			<persName><forename type="first">James</forename><surname>Kramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Scheutz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autonomous Robots</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="101" to="132" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">YARP: Yet another robot platform</title>
		<author>
			<persName><forename type="first">Giorgio</forename><surname>Metta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lorenzo</forename><surname>Natale</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal on Advanced Robotics Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="43" to="48" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Linking action to perception in a humanoid robot: A developmental approach to grasping</title>
		<author>
			<persName><forename type="first">Lorenzo</forename><surname>Natale</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-02">February 2005</date>
			<pubPlace>Genoa, Italy</pubPlace>
		</imprint>
		<respStmt>
			<orgName>DIST, University of</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Issa</surname></persName>
		</author>
		<author>
			<persName><surname>Nesnas</surname></persName>
		</author>
		<title level="m">The CLARAty project: Coping with hardware and software heterogeneity</title>
		<editor>
			<persName><forename type="first">Davide</forename><surname>Brugali</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="31" to="70" />
		</imprint>
	</monogr>
	<note>Software Engineering for Experimental Robotics</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">The summer vision project. Memo AIM-100</title>
		<author>
			<persName><forename type="first">S</forename><surname>Papert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1966-07">July 1966</date>
		</imprint>
		<respStmt>
			<orgName>MIT AI Lab</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The open source definition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Perens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Open Sources: Voices from the Open Source Revolution, O&apos;Reilly and Associates</title>
		<editor>
			<persName><forename type="first">Chris</forename><surname>Dibona</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sam</forename><surname>Ockman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Mark</forename><surname>Stone</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">How the Body Shapes the Way We Think: A New View of Intelligence</title>
		<author>
			<persName><forename type="first">Rolf</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Josh</forename><forename type="middle">C</forename><surname>Bongard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006">2006</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The intelligent ASIMO: System overview and integration</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Sakagami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Watanabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aoyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Matsunaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Higaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fujimura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS&apos;02</title>
		<meeting>of the IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS&apos;02</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="2478" to="2483" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.activrobots.com" />
		<title level="m">Internet site, Activmedia robotics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://www.cmake.com" />
		<title level="m">Internet Site, CMake cross platform make</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="dbus.freedesktop.org/doc/dbus-faq.html" />
		<title level="m">Internet Site, D-Bus FAQ</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<orgName type="collaboration">Internet Site, K-Team Corporation. www.k-team.com</orgName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<ptr target="http://msdn.microsoft.com/robotics" />
		<title level="m">Internet Site, Microsoft robotics studio</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">Internet</forename><surname>Site</surname></persName>
		</author>
		<ptr target="http://www.sonydigital-link.com/aibo" />
		<title level="m">Sony AIBO Europe -official website</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Tilley</surname></persName>
		</author>
		<title level="m">The Measure of Man and Woman: Human Factors in Design, book &amp; cd-rom</title>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2001-12">December 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">iCub -The design and realization of an open humanoid platform for cognitive and neuroscience research</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Tsagarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Metta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Sandini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vernon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Beira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Becchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Righetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Santos-Victor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">J</forename><surname>Ijspeert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Carrozza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Caldwell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Advanced Robotics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1151" to="1175" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">On device abstractions for portable, reusable robot code</title>
		<author>
			<persName><forename type="first">R</forename><surname>Vaughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gerkey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Howard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/RSJ International Conference on Intelligent Robots and Systems</title>
		<meeting><address><addrLine>Las Vegas, ND, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10">October 2003</date>
			<biblScope unit="page" from="2121" to="2427" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">T</forename><surname>Vaughan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">P</forename><surname>Gerkey</surname></persName>
		</author>
		<title level="m">Reusable robot code and the player/stage project</title>
		<editor>
			<persName><forename type="first">Davide</forename><surname>Brugali</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="267" to="289" />
		</imprint>
	</monogr>
	<note>Software Engineering for Experimental Robotics</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Eric von Hippel, The promise of research on open source software</title>
		<author>
			<persName><surname>Georg Von Krogh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management Science</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="975" to="983" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<ptr target="http://www.sony.net/SonyInfo/QRIO/" />
		<title level="m">Sony global -QRIO</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">D. in computer science from the Massachusetts Institute of Technology, USA, for work addressing developmental approaches to machine perception, implemented on the humanoid robots Cog and Kismet. He worked as a post-doctoral lecturer at MIT for two years, then had a post-doctoral post at the Laboratory for Integrated and Advanced Robotics (LIRA-Lab) at the University of Genoa and is now working at the Italian Institute of Technology. His current primary interest is the development of machine perception for object manipulation</title>
		<imprint/>
		<respStmt>
			<orgName>Paul Fitzpatrick received his MEng in computer engineering from the University of Limerick, Ireland, and his Ph</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
