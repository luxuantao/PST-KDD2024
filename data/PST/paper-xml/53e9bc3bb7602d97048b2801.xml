<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Finding Maximal Cliques in Massive Networks by H*-graph</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">James</forename><surname>Cheng</surname></persName>
							<email>j.cheng@acm.org</email>
						</author>
						<author>
							<persName><forename type="first">Yiping</forename><surname>Ke</surname></persName>
							<email>ypke@se.cuhk.edu.hk</email>
						</author>
						<author>
							<persName><forename type="first">Wai-Chee</forename><surname>Fu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jeffrey</forename><surname>Xu</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Linhong</forename><surname>Zhu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Department of Systems Engineering and Engineering Management</orgName>
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Department of Systems Engineering and Engineering Management</orgName>
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">School of Computer Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="department">SIGMOD&apos;10</orgName>
								<address>
									<addrLine>June 6-11</addrLine>
									<postCode>2010</postCode>
									<settlement>Indianapolis</settlement>
									<region>Indiana</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Finding Maximal Cliques in Massive Networks by H*-graph</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C97104D6A9D861367DDC409C63345F64</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:50+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>G.2.2 [DISCRETE MATHEMATICS]: Graph Theory-Graph algorithms Algorithms</term>
					<term>Experimentation</term>
					<term>Performance Maximal Clique Enumeration</term>
					<term>Massive Networks</term>
					<term>Scale-Free Networks</term>
					<term>H*-graph</term>
					<term>h-index</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Maximal clique enumeration (MCE) is a fundamental problem in graph theory and has important applications in many areas such as social network analysis and bioinformatics. The problem is extensively studied; however, the best existing algorithms require memory space linear in the size of the input graph. This has become a serious concern in view of the massive volume of today's fastgrowing network graphs. Since MCE requires random access to different parts of a large graph, it is difficult to divide the graph into smaller parts and process one part at a time, because either the result may be incorrect and incomplete, or it incurs huge cost on merging the results from different parts. We propose a novel notion, H * -graph, which defines the core of a network and extends to encompass the neighborhood of the core for MCE computation. We propose the first external-memory algorithm for MCE (ExtMCE) that uses the H * -graph to bound the memory usage. We prove both the correctness and completeness of the result computed by ExtMCE. Extensive experiments verify that ExtMCE efficiently processes large networks that cannot be fit in the memory. We also show that the H * -graph captures important properties of the network; thus, updating the maximal cliques in the H * -graph retains the most essential information, with a low update cost, when it is infeasible to perform update on the entire network.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Maximal clique enumeration (MCE) <ref type="bibr" target="#b3">[2,</ref><ref type="bibr" target="#b8">7]</ref> is a long-standing problem in graph theory. It is closely related to a number of fundamental graph problems, such as maximal independent sets (or minimal vertex covers) <ref type="bibr" target="#b29">[28]</ref>, graph coloring <ref type="bibr" target="#b9">[8]</ref>, maximal common induced subgraphs <ref type="bibr" target="#b20">[19]</ref>, maximal common edge subgraphs <ref type="bibr" target="#b20">[19]</ref>, etc. Its significance is not just limited to graph theory but also in numerous applications in various real-world networks, such as social network analysis <ref type="bibr" target="#b16">[15]</ref>, hierarchy detection through email networks <ref type="bibr">[10]</ref>, study of structures in behavioral and cognitive networks <ref type="bibr" target="#b4">[3]</ref>, statistical analysis of financial networks <ref type="bibr" target="#b7">[6]</ref>, clustering in dynamic networks <ref type="bibr" target="#b27">[26]</ref>, the detection of emergent patterns in terrorist networks <ref type="bibr" target="#b5">[4]</ref>, as well as various applications in computational biology <ref type="bibr" target="#b2">[1]</ref>, protein-protein interaction complex detection <ref type="bibr" target="#b30">[29]</ref>, and clustering protein sequences <ref type="bibr" target="#b24">[23]</ref>.</p><p>MCE algorithms have been extensively studied <ref type="bibr" target="#b3">[2,</ref><ref type="bibr" target="#b8">7,</ref><ref type="bibr" target="#b29">28,</ref><ref type="bibr" target="#b21">20,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b22">21,</ref><ref type="bibr" target="#b27">26,</ref><ref type="bibr" target="#b2">1,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b10">9,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b26">25]</ref>. The worst-case time complexity of inmemory algorithms have proved to be optimal recently <ref type="bibr" target="#b28">[27]</ref>; however, the best existing algorithms require space which is asymptotically linear in the size of the input graph. Unfortunately, many real-world networks have grown exceedingly large in recent years and are continuing to grow at a fast rate. For example, the Web graph has over 1 trillion webpages (Google), most social networks (e.g., Facebook, MSN) have millions to billions of users, many citation networks (e.g., DBLP, Citeseer) have millions of publications, other networks such as phone-call networks, email networks, stock-market networks, etc., are also massively large.</p><p>Despite the low cost of memory, applying in-memory algorithms is clearly infeasible on such massive data. For large graphs, external memory algorithms offer a possible recourse; however, designing such an algorithm is fraught with difficulties. MCE computations access vertices in a rather arbitrary manner. This potential random disk access requirement makes it difficult to divide the graph and process it in a part-by-part manner and perhaps suggests the reason for the current prevalence in in-memory algorithms for tackling this problem.</p><p>In this paper, we develop the first external-memory algorithm for MCE (ExtMCE) which operates on the broad class of scale-free graphs <ref type="bibr" target="#b25">[24,</ref><ref type="bibr" target="#b12">11]</ref>. Extensive studies <ref type="bibr" target="#b15">[14,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b7">6,</ref><ref type="bibr" target="#b6">5]</ref> have shown that scale-free graphs are prevalent in real-world applications. In particular, Dorogovtsev and Mendesand <ref type="bibr" target="#b12">[11]</ref> show that a wide spectrum of real-world networks are scale-free, which include the WWW, citation networks, collaboration networks, neural networks, metabolic reaction networks, genome and protein networks, ecological and food webs, word web of human language, telephone call graph, mail networks, power grids and industrial networks, electronic circuits, nets of software components, and energy landscape networks.</p><p>Given a large input graph G, ExtMCE recursively computes a portion of G at a time, such that each portion can be fit into the main memory for MCE computation. Two questions arise: <ref type="bibr" target="#b2">(1)</ref> What portion of G should be chosen at each recursive step and how? <ref type="bibr" target="#b3">(2)</ref> How to ensure that the set of maximal cliques computed locally at recursive steps is sound and complete with respect to the set of maximal cliques globally in G?</p><p>To answer the first question, we propose the novel notion of H *graph. The key component of the H * -graph is the largest set of h vertices in G that have degree at least h, called the h-vertices. This is inspired by the concept of h-index <ref type="bibr" target="#b17">[16]</ref>, which is the maximum h for a scientist who has h publications of citations at least h. The h-index is widely used to assess a scientist's publication productivity and quality. Putting into the context of a graph, the h-vertices correspond to the h publications that contribute to the h-index. The induced subgraph of G by the h-vertices constitutes the core of the H * -graph. Then, we extend from this core to their neighborhood and thus form the H * -graph.</p><p>The H * -graph is the key component in the first step of ExtMCE and sets the limit on the memory usage for all subsequent steps. To this end, we need to first make sure that the H * -graph is small enough to be kept in the memory. For a general graph, the H *graph can spread to cover a large part of the graph so that it may be too large to fit into the memory. However, we show that for scale-free graphs, the H * -graph is only a small portion of the entire graph. Furthermore, we derive bounds on the size of the H * -graph for scale-free networks, which are also bounds on the memory requirement of ExtMCE. We also devise a method to handle the case that even the H * -graph cannot be fit into the memory. Now we answer the second question. MCE computation involves random accesses to all parts of G; therefore, if we take any part of G and compute MCE on each part, then either the set of cliques computed may not be complete and may contain nonmaximal ones, or the cost of merging the results from each part and ensuring completeness is substantially high.</p><p>It is challenging in linking the MCE computation from one part of G to the other parts while ensuring the correctness and completeness of the result. Let Gi be the part of G at the i-th recursive step of ExtMCE (thus, G1 is the H * -graph). We formulate Gi in such a way that it allows smooth transition from Gi to Gi+1 so that we can compute a subset of maximal cliques in one part of G, and then move on to another part until we finish the entire G. We prove that the maximal cliques computed in each local part are indeed maximal globally in the entire graph. We then prove that the set of maximal cliques computed is also complete.</p><p>Real-world networks undergo frequent updates. However, there is only one known algorithm <ref type="bibr" target="#b27">[26]</ref> that can be applied to update the set of maximal cliques when a network is updated. Their algorithm is impractical for large networks because the set of maximal cliques in a large network is too large to be kept in the memory, while keeping them on the disk results in extremely high update cost.</p><p>We take a new approach. We show that the H * -graph captures many important properties of the original network, while the set of maximal cliques computed from the H * -graph are those that consist of the most important vertices in the network. Therefore, we propose to update only the maximal cliques in the H * -graph, which can be processed in the memory due to the much smaller number. Furthermore, we show that the portion of the updates in G that are related to the H * -graph is very small and thus by focusing the update maintenance on the H * -graph, we can significantly reduce the overall update cost. Given the up-to-date H * -graph, we then re-compute the whole set of maximal cliques in G on demand. Finally, we conduct experiments on a set of large real-world networks, with size up to about 10 million vertices and 80 million edges, collected from different domains. Our results verify that the H * -graph represents a significant portion of the original network, and it is effective to use the H * -graph to bound the memory usage in ExtMCE. We demonstrate that ExtMCE uses comparable time, but significantly less memory, as compared with the state-ofthe-art in-memory MCE algorithm <ref type="bibr" target="#b28">[27]</ref>. When the memory is not sufficient, ExtMCE still computes MCE efficiently with a bounded memory usage. Our results also verify that our approach of update maintenance is effective, and significantly more efficient than <ref type="bibr" target="#b27">[26]</ref>.</p><p>Contributions. We summarize our main contributions as follows.</p><p>• We propose ExtMCE, the first external-memory algorithm for MCE computation. We prove both the correctness and completeness of the result computed by ExtMCE.</p><p>• We propose the novel notion of the H * -graph, which is used to bound the memory usage as well as to guide the recursive steps of ExtMCE. We derive bounds on the size of the H *graph.</p><p>• We propose the first feasible solution for update maintenance of MCE in large networks. We show that by updating the maximal cliques in the H * -graph, we retain the essential information in the entire network, leading to a low update cost.</p><p>Organization. Section 2 formally defines the problem and gives the basic notations. Section 3 presents the H * -graph. Section 4 details the ExtMCE algorithm. Section 5 discusses update maintenance. Section 6 reports the experimental results. Section 7 discusses the related work. Section 8 gives the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PROBLEM DEFINITION</head><p>In this paper, we focus on large graphs whose degree distribution follows a power law, or called scale-free networks <ref type="bibr" target="#b15">[14,</ref><ref type="bibr" target="#b25">24]</ref>. Let G = (V, E) be an undirected and unlabeled graph. We define n = |V | and m = |E|. We define the size of G, denoted as |G|,</p><formula xml:id="formula_0">as |G| = m. Given S ⊆ V , we define the induced subgraph of G by S as GS = (VS = S, ES = {(u, v) : u, v ∈ S, (u, v) ∈ E}). We define the set of neighbors of a vertex v in G as nb(v) = {u : (u, v) ∈ E}, and the degree of v in G as d(v) = |nb(v)|. Simi- larly, we define nb(v, GS) = {u : (u, v) ∈ ES} and d(v, GS) = |nb(v, GS)|. A clique in G is a subset of vertices, C ⊆ V , such that the induced subgraph by C is a complete graph in G. C is called a maximal clique (max-clique for short) in G if there exists no clique C ′ in G such that C ′ ⊃ C.</formula><p>The problem of Maximal Clique Enumeration (MCE) is: given a graph G, find the set of all maximal cliques in G. In this paper, we solve the problem of MCE for large scale-free graphs that cannot be fit in the main memory.</p><p>Table <ref type="table" target="#tab_0">1</ref> shows the notations used frequently in the paper. </p><formula xml:id="formula_1">(CH ∪ CH nb ) for a clique C in G H + : CH=(C ∩ H); CH nb =(C ∩ Hnb) HNB (X)</formula><p>the set of common h-neighbors of all vertices in X, where X is a clique in GH maxCL(S)</p><p>the set of all max-cliques in GS M1, M2, M3 three disjoint subsets of M H + , defined in Lemmas 4-6 X a set of "H" parts used to form cliques in M3, see Eq. ( <ref type="formula" target="#formula_31">10</ref>) EXT (C) a set of h-neighbors used to extend C ∈ X , see Eq. ( <ref type="formula">11</ref>)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE H*-GRAPH</head><p>In this section, we introduce a novel concept of H * -graph for real-world networks. The H * -graph plays a crucial role in the first recursive step of our ExtMCE algorithm (details in Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The notion of the H*-graph</head><p>We first define the set of h-vertices which forms the core of the H * -graph.</p><formula xml:id="formula_2">Definition 1 (h-VERTICES). Given a graph G = (V, E), the set of h-vertices of G, denoted as H, is defined as H = {v : v ∈ V, d(v) ≥ h} such that |H| = h, and ∀v ∈ (V \H), d(v) ≤ h.</formula><p>Essentially, the set of h-vertices of G consists of h vertices in G that have a degree of at least h. From the h-vertices, we extend to the h-neighbors defined as follows. Note that h-neighbors are defined to be non-h-vertices.</p><p>Definition 2 (h-NEIGHBORS). The set of h-neighbors, denoted as H nb , is defined as</p><formula xml:id="formula_3">H nb = {v : v ∈ (nb(u)\H), u ∈ H}.</formula><p>We use a notation H + to denote the union of the sets of hvertices and h-neighbors. The "+" sign is used to indicate the extension from the h-vertices to the h-neighbors.</p><formula xml:id="formula_4">Definition 3. H + = H ∪ H nb .</formula><p>With the set of h-vertices H, we define the concept of H-graph in G as follows.</p><p>Definition 4 (H -GRAPH). The H-graph of a graph G, denoted as GH , is defined as the induced subgraph of G by H.</p><p>Similarly, we define the concept of H + -graph.</p><p>Definition 5 (H + -GRAPH). The H + -graph of a graph G, denoted as G H + , is defined as the induced subgraph of G by H + .</p><p>With the H-graph and the H + -graph, we now define the notion of H * -graph. Intuitively, H * -graph is a graph that "lies" between H-graph and H + -graph. </p><formula xml:id="formula_5">* = (H + , EHH ∪ EHH nb ), where EHH = {(u, v) : u, v ∈ H, (u, v) ∈ E} and EHH nb = {(u, v) : u ∈ H, v ∈ H nb , (u, v) ∈ E}.</formula><p>The H * -graph is the same as the H + -graph except that the H *graph does not contain the edges between the h-neighbors. In other words, the H * -graph contains only those edges incident to at least one h-vertex. It is easy to see that GH ⊆ GH * ⊆ G H + . The first equality holds when H nb = ∅ and the second equality holds when there is no edge between h-neighbors in G.</p><p>We use the following example to illustrate these basic concepts.</p><p>Example 1. Figure <ref type="figure" target="#fig_0">1</ref> gives an example graph G, which contains 13 vertices and 25 edges. The set of h-vertices in G is H = {a, b, c, d, e}, which means that h = 5. It can be easily checked in the figure that all the 5 vertices in H (shaded vertices) have degree at least 5 and all the remaining vertices in G have degree less than 5. The set of h-neighbors is given as H nb = {r, s, w, x, y, z}. And H + = {a, b, c, d, e, r, s, w, x, y, z}. The two vertices q and t are not in H + since they are not incident to any vertex in H. The H-graph consists of the shaded vertices and bold edges in Figure <ref type="figure" target="#fig_0">1</ref>, which is the induced subgraph of G by H. The H + -graph contains all edges in G except for the two edges incident to q and t. Finally, the H * -graph contains all edges in the H + -graph except for the edges between h-neighbors, i.e., (w, x), (s, y), and (r, z). 2</p><p>In the following two subsections, we analyze and justify why we use GH * in our ExtMCE algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Analysis of H*-graph</head><p>Our algorithm ExtMCE uses the H * -graph to estimate and control the memory usage. To this end, we need to examine two important factors: the size of H and the size of GH * .</p><p>We first discuss the size of H. Faloutsos et al. <ref type="bibr" target="#b15">[14]</ref> show that for real-world networks following a power law degree distribution:</p><formula xml:id="formula_6">d(v) = 1 n R (r(v)) R .<label>(1)</label></formula><p>In Eq. (1), r(v) is the degree rank of a vertex v, i.e., v is the (r(v))-th highest degree vertex in G, and R is the rank exponent, where R &lt; 0. By Definition 1, H is a set of h vertices having degree at least h; in other words, the lowest-degree vertex v in H has a rank of h and its degree is at least h. Thus, by substituting r(v) by h in Eq. (1) and d(v) should be at least h, we have</p><formula xml:id="formula_7">d(v) = 1 n R h R ≥ h.<label>(2)</label></formula><p>Solving the inequality, we have</p><formula xml:id="formula_8">h ≤ n R R-1 .<label>(3)</label></formula><p>Faloutsos et al. <ref type="bibr" target="#b15">[14]</ref> show that R is a constant for most realworld networks, which can be easily measured by plotting the degree distribution of the networks. The value of R measured in <ref type="bibr" target="#b15">[14]</ref> for three snapshots of the internet graph is between -0.8 and -0.7. For a graph of 1 million vertices, we have h ≤ 464 and therefore |H| ≤ 464 when R = -0.8. The value of h decreases to about 300 when R = -0.7. This shows that the number of h-vertices in a large real-world network is small.</p><p>Next, we estimate the size of GH * . By Eq. ( <ref type="formula" target="#formula_6">1</ref>), we have the following upper bound for |GH * |.</p><formula xml:id="formula_9">|GH * | ≤ h r=1 ( r n ) R .<label>(4)</label></formula><p>The right-hand side of Eq. ( <ref type="formula" target="#formula_9">4</ref>) is the sum of degrees of all the hvertices. Since the edges connecting two h-vertices (if there is any) are counted twice, we have the "&lt;" sign in Eq. ( <ref type="formula" target="#formula_9">4</ref>). The equality holds when there is no edge connecting two h-vertices; in this case, the H * -graph consists of h "stars", each centered at an h-vertex.</p><p>We can also obtain a lower bound for |GH * | as follows.</p><formula xml:id="formula_10">|GH * | ≥ h r=1 ( r n ) R - h(h -1) 2 . (<label>5</label></formula><formula xml:id="formula_11">)</formula><p>The lower bound occurs when all h-vertices are pairwise connected. In this case, all edges connecting two h-vertices are double counted and hence deducting the number of these edges from the degree sum gives the lower bound of |GH * |.</p><p>Similarly, we also obtain the size of G, which is half of the degree sum of all vertices in V , since all edges are counted twice.</p><formula xml:id="formula_12">|G| = 1 2 n r=1 ( r n ) R .<label>(6)</label></formula><p>By Eq. ( <ref type="formula" target="#formula_9">4</ref>)-( <ref type="formula" target="#formula_12">6</ref>), we have</p><formula xml:id="formula_13">2 h r=1 r R -n R h(h -1) n r=1 r R ≤ |GH * | |G| ≤ 2 h r=1 r R n r=1 r R<label>(7)</label></formula><p>For a network with R = -0.7 and 1 million vertices, |GH * | is within [12%, 15%] of the entire network, and the percentage lowers considerably when the network becomes larger: the ratio is in the range of [8%, 10%] when n increases to 10 million.</p><p>With the result of Eq. ( <ref type="formula" target="#formula_13">7</ref>), the amount of memory required for keeping GH * is reasonable. Another desirable aspect of the H *graph is that the rank exponent in Eq. ( <ref type="formula" target="#formula_8">3</ref>) is a constant for most realworld networks. This property allows us to even estimate the size of GH * when the network grows, so that we can predict the memory resource required at a certain point in the future. For many realworld networks, it is possible to predict the growth of the network based on its past growth pattern, and thus we can prepare in advance the memory resource required for our computation in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Why H*-graph?</head><p>We examine why we use GH * instead of GH or G H + . We first analyze |GH | as follows.</p><formula xml:id="formula_14">0 ≤ |GH | ≤ h(h -1) 2 .<label>(8)</label></formula><p>Eq. ( <ref type="formula" target="#formula_14">8</ref>) gives the lower and upper bounds of |GH |. Since h is small, if we use GH as the in-memory partition, it leads to too</p><formula xml:id="formula_15">Algorithm 1 Compute-H * -graph Input: G = (V, E).</formula><p>Output: The set of h-vertices of G, H, and the set of their neighbors, NB H = {nb(v) : v ∈ H}.</p><p>1. Set h ← 0 and initialize an empty min-heap, Q; 2. Let (d(v), v, nb(v)) be an element in Q, where d(v) is the key; 3. Denote the minimum key of Q by min; 4. for each v ∈ V do 5.</p><p>if</p><formula xml:id="formula_16">(h = 0 or (d(v) &gt; h and min &gt; h)) 6. insert (d(v), v, nb(v)) into Q; 7. h++; 8. else if (d(v) &gt; h and min = h) 9.</formula><p>delete-min and insert</p><formula xml:id="formula_17">(d(v), v, nb(v)) into Q; 10. return H ← {v : (d(v), v, nb(v)) ∈ Q} and NB H ← {nb(v) : (d(v), v, nb(v)) ∈ Q};</formula><p>many recursive steps in the max-clique computation and hence too many scans of G from the disk.</p><p>As for</p><formula xml:id="formula_18">|G H + |, let s = h r=1 ( r n ) R , i.e.</formula><p>, the degree sum of h-vertices. |G H + | reaches its maximum when (1) the number of h-neighbors is maximized (i.e., |H nb | = s); (2) the degrees of h-neighbors rank top among non-h-vertices (i.e., the degree rank of h-neighbors is from (h + 1) to (h + s) in G); and (3) all hneighbors connect with only vertices in H + (i.e., all edges incident to h-neighbors are in G H + ). Thus, the upper bound of</p><formula xml:id="formula_19">|G H + | is |G H + | ≤ 1 2 (s + s r=1 ( h + r n ) R ) = 1 2 h+s r=1 ( r n ) R .<label>(9)</label></formula><p>The lower bound of <ref type="bibr" target="#b10">(9)</ref> shows that G H + is too large to be kept in memory. For example, when R = -0.7 and n is 1 million, G H + can be as large as 65% of the whole graph G.</p><formula xml:id="formula_20">|G H + | is simply |GH * | since GH * ⊆ G H + . Eq.</formula><p>From the semantic point of view, GH only retains the very core of G and does not reveal much global information, while G H + may be giving too much general information and making it not much different from G. On the contrary, GH * gives the core of G as well as the relationship from the core to other parts of G. We examine empirically more properties of GH * in Section 6.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Computing the H*-graph</head><p>Algorithm 1 presents the algorithm for computing the set of hvertices H, together with the set of their neighbors NBH . A minheap Q is used to keep the h-vertices with their neighbors using the vertex degree as the key. Lines 4-9 perform a scan on the vertices in G to check whether a vertex can be added to Q as a potential h-vertex. A vertex with degree larger than the current h is either directly inserted to Q in Lines 5-7 (when h can still grow since the min-degree in Q is larger than h) or replace the min-degree vertex in Q in Lines 8-9 (if h is incremented, the min-degree vertex no longer satisfies the degree requirement and is thus discarded). Finally, the set of vertices kept in Q is returned as H. After we obtain H and their neighbor sets NBH (i.e., the adjacency lists), we essentially obtain the H * -graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THEOREM 1. Algorithm 1 correctly computes the set of h-vertices of G and the set of their neighbors in O(h log h + n) time and O(|GH * |) space, with one scan of G.</head><p>PROOF. To prove the correctness, we need to show that: let h0 be the true value of h of G, then the h computed by Algorithm 1 is equal to h0. Suppose to the contrary that h &lt; h0, which implies that there are h0 &gt; h vertices with a degree greater than h0 &gt; h. However, according to Algorithm 1, these h0 vertices must be inserted into Q at some point, since their degree is greater than h and the value of h is never decreasing in Algorithm 1. Therefore, h computed by Algorithm 1 should be at least h0 in this case. On the other hand, h cannot be larger than h0 since each increment of h (Line 7 of Algorithm 1) follows the definition of h-vertex (Line 5). Thus, we have h = h0.</p><p>We have O(h) insertions/updates, each takes O(log h) time, plus n comparisons between h and d(v) for each v ∈ V . Space is needed to keep h-vertices and their adjacency lists, which takes O(|GH * |) space. Since each vertex v ∈ V is processed only once, we only need one scan of G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">RECURSIVE CLIQUE COMPUTATION</head><p>In this section, we discuss our algorithm ExtMCE. We first give the framework of ExtMCE as follows.</p><p>• The recursive step continues until G becomes empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">H*-max-cliques and H*-max-clique tree</head><p>We start the first step by defining the notions of H * -max-cliques and H * -max-clique tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">H*-max-cliques</head><p>We first define the notion of H * -max-cliques.</p><p>Definition 7 (H * -MAX-CLIQUE). An H * -max-clique is a maxclique in GH * . The set of all H * -max-cliques is denoted as MH * .</p><p>The following lemma states two properties of H * -max-cliques. LEMMA 1. The following statements of H * -max-clique are true:</p><p>1. An H * -max-clique contains at least one h-vertex.</p><p>2. An H * -max-clique contains at most one h-neighbor.</p><p>PROOF. Since each h-neighbor in GH * is connected to at least one h-vertex and there is no edge between any two h-neighbors, an H * -max-clique containing an h-neighbor must also contain at least an incident h-vertex, which proves the first statement. The second statement holds since there is no edge among h-neighbors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">H*-max-clique tree</head><p>We now present the data structure used to keep the set of H *max-cliques. Since two cliques may share common vertices, we define a prefix-tree structure to represent common vertices in the cliques as common paths.</p><p>Definition 8 (H * -MAX-CLIQUE TREE). Given GH * of a graph, define a total order ≺ on H and H nb . Moreover, ∀u ∈ H and ∀v ∈ H nb , u ≺ v. The H * -max-clique tree, TH * , of GH * is a prefix tree defined as follows.</p><p>• The root of TH * is λ;</p><p>• The children of a vertex in TH * are ordered by ≺;</p><p>• All vertices in a path in TH * are ordered by ≺;</p><p>• The set of root-to-leaf paths in TH * has a one-to-one correspondence to the set of H * -max-cliques. A root-to-leaf path λ, u, . . . , v corresponds to an H * -max-clique {u, . . . , v}.</p><p>We define ≺ by simply assigning each vertex a unique ID and ordering them by their IDs, where the ID of an h-vertex is always smaller than that of an h-neighbor.</p><p>By Definition 8, we have the following lemma.</p><p>LEMMA 2. The following statements of TH * are true:</p><p>1. An h-neighbor can only be a leaf in TH * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">All children of λ are h-vertices.</head><p>PROOF. Lemma 1 states that an H * -max-clique contains at most one h-neighbor. By the definition of the order ≺ and the tree TH * , an h-neighbor can only be a leaf in TH * .</p><p>Similarly, all children of λ are h-vertices since an H * -max-clique contains at least one h-vertex as stated in Lemma 1 and all hvertices are ordered before h-neighbors in a path in TH * .</p><p>Most existing algorithms for computing max-cliques can be modified to construct TH * with small overhead, particularly the algorithms <ref type="bibr" target="#b8">[7,</ref><ref type="bibr" target="#b20">19,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b10">9,</ref><ref type="bibr" target="#b23">22,</ref><ref type="bibr" target="#b13">12,</ref><ref type="bibr" target="#b26">25]</ref> that adopt a backtracking search tree, which is essentially an H * -max-clique tree. It is not our focus to propose another in-memory MCE algorithm; however, we highlight two improvements that we can make by employing the unique properties of TH * .</p><p>Given a path p = λ, u, . . . , v in TH * , let S be the set of vertices that can be used to potentially grow p from v. If S ⊆ H nb , we first test if {u, . . . , v} (the corresponding clique of p), instead of {u, . . . , v, s} for some s ∈ S, is maximal. If {u, . . . , v} is maximal, by Statement 1 in Lemma 2, we directly create S as the set of children of v (we also mark v for a condition test in Line 7 of Algorithm 2). Second, unlike a normal prefix tree or a backtracking search tree, by Statement 2 in Lemma 2, we only need to construct the subtree rooted at an h-vertex that is a child of λ. These two improvements can considerably speed up the process as they save a lot of unnecessary checking and comparisons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Size estimation of H*-max-clique tree</head><p>The first step of our algorithm is critical as it sets the memory limit for the subsequent recursive steps. In Section 3.2, we give bounds on |GH * |. However, there is another element, TH * , that may take much memory. We estimate |TH * | here.</p><p>Unlike |GH * |, which can be estimated by properties of scale-free networks, |TH * | is difficult to estimate because the number and sizes of max-cliques in GH * vary greatly for different networks. The best known upper bound on the number of max-cliques is exponential <ref type="bibr" target="#b28">[27]</ref>, which is obviously too loose to be used to estimate the memory usage.</p><p>We devise an estimation strategy that borrows the concept of Knuth's method <ref type="bibr" target="#b19">[18]</ref> for estimating the size of a backtracking tree T . Let n(T ) be the number of vertices in T . The idea is to randomly probe a set of paths P in T and estimate n(T ) = AVGp∈P (n(p)), where n(p) is the size of a tree with the same root as p and using p as a building path. Let p = v1, v2, . .</p><formula xml:id="formula_21">. , v k , n(p) = (1 + f1 + f1f2 + • • • + (f1 • • • f k-2 f k-1 )</formula><p>), where fi is the number of children of vi. In the simple case that T is a complete binary tree, this method correctly estimates n(T ) as (2 k -1). It is shown that Knuth's method is unbiased and effective in practice <ref type="bibr" target="#b18">[17]</ref>.</p><p>However, Knuth's method assumes the presence of T so that one can perform random probing of paths, while TH * in our case is not yet constructed when estimating its memory usage. We propose a new method of probing paths in TH * by utilizing its unique properties, without actually constructing TH * . Each time we randomly choose a vertex u ∈ H. We consider u as a child of λ and attempt to probe randomly a path p from u as follows: we randomly choose a vertex v from the set of vertices that can be used to potentially grow p from u, and then continue the process recursively from v until the path p cannot be expanded any more (i.e., p corresponds to an H * -max-clique). Since the vertices are ordered and nb(v) is available for every v ∈ H, we can virtually probe a path even though TH * does not exist. Thus, we can compute n(p) as we move along p. Then, we estimate n(TH * ) by averaging n(p) of all the paths probed.</p><p>Our method is simple and yet does not violate the principle of random probing <ref type="bibr" target="#b19">[18]</ref>. Our empirical study shows that it gives a good estimation in practice (see Table <ref type="table" target="#tab_9">5</ref> in Section 6.1).</p><p>In the case when memory is very limited such that the available memory N is smaller than n(TH * ), we remove the lowest-degree vertices from H. The number of vertices to be removed can be approximated as h = (1 -N/n(TH * ))h. Then, we use the remaining (h -h) vertices as H and extract a smaller GH * accordingly. We re-estimate n(TH * ) for the smaller GH * until N &gt; n(TH * ). The memory limit for the subsequent recursive steps is then set to the size of the smaller GH * and the corresponding TH * . We may lose some of the nice properties of using GH * , especially for dynamic update maintenance; however, when memory is scarce, this is a necessary compromise but importantly, our recursive algorithm also handles the case of limited memory resource.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">From H*-max-cliques to global max-cliques</head><p>An H * -max-clique C may not be a real max-clique in G; that is, C is maximal locally in GH * but may not be maximal globally in G. In this subsection, we discuss how we compute global maxcliques from the H * -max-cliques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">H + -max-cliques: a subset of global max-cliques</head><p>We first define the notion of H + -max-cliques as follows.</p><formula xml:id="formula_22">Definition 9 (H + -MAX-CLIQUE). An H + -max-clique is a maxi- clique in G H + that consists of at least one h-vertex. The set of all H + -max-clique is denoted as M H + . LEMMA 3. An H + -max-clique is also a max-clique in G.</formula><p>PROOF. Proof by contradiction. Let C be an H + -max-clique and u be any h-vertex in C. Suppose that C is not maximal in G, i.e., there exists a max-clique</p><formula xml:id="formula_23">C ′ in G such that C ′ ⊃ C. Then C ′ must contain some vertex v, where v / ∈ H + (otherwise C ′ must be maximal in G H + and C is not). v / ∈ H + implies that v is not connected with u, which contradicts that C ′ is a clique. Therefore, C must be maximal in G.</formula><p>With the result of Lemma 3, we have the following theorem. THEOREM 2. Let M be the set of max-cliques in G. Let M0 be the set of max-cliques in G that consist of at least an h-vertex, i.e., M0 = {C :</p><formula xml:id="formula_24">C ∈ M, C ∩ H = ∅}. Then, M H + = M0. PROOF. First, Lemma 3 shows that M H + ⊆ M0. Next, ∀C ∈ M0, ∃u ∈ C such that u ∈ H. Since ∀v ∈ C\{u}, (u, v) ∈ E, we have either v ∈ H or v ∈ H nb , implying that C ∈ M H + and hence M0 ⊆ M H + . Thus, M H + = M0.</formula><p>Theorem 2 is important because it enables us to compute a subset of M separately on a portion of G, output it, and move on to computing another subset of M for another portion in the remaining of G, and so on recursively until we finish the whole graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Categorizing H + -max-cliques</head><p>It is infeasible to compute M H + directly from G H + , since G H + is too large (see Eq. ( <ref type="formula" target="#formula_19">9</ref>) and the analysis right after in Section 3.3). Instead, we compute M H + from TH * . We first define some notation used in the subsequent discussions.</p><p>Let MH be the set of all max-cliques in GH . Given a clique C in G H + , we define CH = (C ∩ H) and CH nb = (C ∩ H nb ). Since H + = (H ∪ H nb ), we have C = (CH ∪ CH nb ). Given a clique X in GH , we define the set of common h-neighbors of the vertices in X as</p><formula xml:id="formula_25">HNB (X) = {v : v ∈ H nb , ∀u ∈ X, (u, v) ∈ E}.</formula><p>In particular, if C is a path in TH * , HNB(CH ) defines the set of h-neighbor leaves sharing the same path CH. Finally, we define maxCL(S) to be the set of all max-cliques in GS (the induced subgraph of G by a set of vertices S).</p><p>We first identify three disjoint categories of H + -max-cliques as follows. Let C = (CH ∪ CH nb ) be an H + -max-clique.</p><p>1. "CH nb = ∅": the set of H + -max-cliques in this category is defined as</p><formula xml:id="formula_26">M 1 H + = {C : C ∈ M H + , CH nb = ∅}.</formula><p>2. "CH nb = ∅ and CH ∈ MH": the set of H + -max-cliques in this category is defined as</p><formula xml:id="formula_27">M 2 H + = {C : C ∈ M H + , CH nb = ∅, CH ∈ MH}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">"CH nb = ∅ and CH /</head><p>∈ MH": the set of H + -max-cliques in this category is defined as</p><formula xml:id="formula_28">M 3 H + = {C : C ∈ M H + , CH nb = ∅, CH / ∈ MH}.</formula><p>Recall that our objective in this subsection is to obtain M H + from TH * or equivalently from MH * . Therefore, in the remaining part of this subsection, we first define three sets of cliques M1, M2, and M3 that can be obtained from MH * . We then prove that M1, M2, and M3 are sound and complete with respect to the above-defined three categories of H + -max-cliques, respectively. We further prove that M1, M2, and M3 give the complete set of M H + in Theorem 3. Finally, we show how M H + can be computed from TH * in Theorem 4.</p><p>We first define M1. Intuitively, M1 contains the max-cliques in MH * that are also in Essentially, each C ∈ M1 corresponds to a root-to-leaf path in TH * where the leaf is an h-vertex. Thus, M1 can be readily obtained from TH * .</p><formula xml:id="formula_29">M H + . LEMMA 4. Let M1 = MH ∩ MH * . Then, M1 = M 1 H + . PROOF. (Prove M1 ⊆ M 1 H + ). Let C be a clique in M1. Since C ∈ (MH ∩ MH * ), C contains only h-vertices and is maximal in GH * , which means that the vertices in C do not have any common h-neighbors (i.e., CH nb = ∅). Since H + = (H ∪ H nb ), C is also maximal in G H + . Since CH nb = ∅, we have C ∈ M 1 H + . (Prove M 1 H + ⊆ M1). ∀C ∈ M 1 H + ,</formula><p>We now define M2. Intuitively, for each clique C in M2, its "H" part (i.e., CH ) is in MH; or equivalently, its "H" part is maximal in GH .</p><formula xml:id="formula_30">LEMMA 5. Let M2 = {C1 ∪ C2 : C1 ∈ (MH\M1), C2 ∈ maxCL(HNB (C1))}. Then, M2 = M 2 H + .</formula><p>PROOF. It is obvious that all elements in M2 are cliques by the definitions of HNB (•) and maxCL(•).</p><p>(Prove M2 ⊆ M Essentially, the CH of each C ∈ M2 is locally maximal in GH . According to Lemma 5, we can compute M2 as follows.</p><p>For each path in TH * that corresponds to each C1 ∈ MH and has at least an h-neighbor leaf (since C1 ∈ (MH \M1)), compute maxCL(HNB(C1)), and output C = (C1 ∪ C2) for each C2 ∈ maxCL(HNB(C1)). We will explain how to check whether a path in TH * corresponds to a clique in MH later in this section.</p><p>Finally, we define M3. Intuitively, for each clique C in M3, its "H" part is no longer maximal in GH but just some proper subset of a max-clique in GH . The non-maximal "H" part then forms a max-clique in G H + by taking into account its h-neighborhood.</p><p>In order to define M3, we first need to define two notations: X and EXT (•). We enumerate the proper subsets of a max-clique in MH that have at least one common h-neighbor as</p><formula xml:id="formula_31">X = {C1 : C1 ⊂ C, C ∈ MH , C1 = ∅, HNB (C1) = ∅, and ∄C ′ 1 ⊆ C ′ , C ′ ∈ MH , s.t. C1⊂ C ′ 1 , HNB (C1)=HNB(C ′ 1 )}.<label>(10)</label></formula><p>The last condition ensures that each C1 ∈ X is not subsumed by its proper superset when forming a clique with its h-neighbors. Then, for each C1 ∈ X , we use EXT (C1) to denote the set of h-neighbors that can be used to extend C1, defined as EXT (C1) = {C2 : C2 ∈ maxCL(HNB (C1)), and</p><formula xml:id="formula_32">∄C ′ ∈ M2, s.t. C ′ ⊃ (C1 ∪ C2), and ∄C ′′ 1 ∈ X , s.t. C ′′ 1 ⊃ C1, C2 ∈ EXT (C ′′ 1 )}. (11)</formula><p>The last two conditions are for the maximality checking of (C1 ∪ C2) in M2 and X , respectively. LEMMA 6. Let M3 = {C1 ∪C2 : C1 ∈ X , C2 ∈ EXT (C1)}. Then, M3 = M 3 H + . PROOF. By the definitions of X and EXT (C1), an element C ∈ M3 must be a clique.</p><p>(Prove</p><formula xml:id="formula_33">M3 ⊆ M 3 H + ). We first prove M3 ⊆ M H + by contra- diction. Suppose ∃C = (C1 ∪ C2) ∈ M3 such that C / ∈ M H + , i.e., ∃C ′ = (C ′ H ∪ C ′ H nb ) ∈ M H + such that C ′ ⊃ C. We have C ′ H ⊇ CH = C1 and C ′ H nb ⊇ CH nb = C2. Assume that C ′ H = CH , then C ′ H nb = CH nb since CH nb is maximal in G HNB (C H ) (= G HNB (C ′ H ) )</formula><p>as defined in EXT (CH). This leads to a contradiction of ∈ X , then CH must be subsumed by some element in X , contradicting to the maximality of C. Thus, CH ∈ X . We further have CH nb ∈ EXT (CH ) since CH nb is maximal in G HNB (C H ) and the maximality of C must be ensured. Thus, C ∈ M3.</p><formula xml:id="formula_34">C ′ = C to C ′ ⊃ C. Thus, C ′ H ⊃ CH ,</formula><p>Essentially, each C ∈ M3 differs from a clique in M1 or M2 in that CH is not maximal in GH. This category of H + -max-cliques is not as straightforward to compute as the first two categories. We discuss the details in Section 4.2.3.</p><p>We state the completeness and soundness of (M1 ∪ M2 ∪ M3) with respect to the whole set M H + in the following theorem.   PROOF. By Lemma 7, every C ∈ MH exists in TH * . Therefore, MH can be computed from TH * by removing all h-neighbor leaves and checking the maximality of all remaining paths (This can be incorporated into the maximality checking when constructing TH * without any extra cost). Thus, ∀C ∈ M H + , CH can be obtained from TH * . On the other hand, the set of common hneighbors, HNB(CH ), can be obtained from the h-neighbor leaves in TH * , from which the corresponding CH nb can be computed if we know the part of GH nb that gives G HNB (C H ) .</p><formula xml:id="formula_35">THEOREM 3. M H + = (M1 ∪ M2 ∪ M3),</formula><p>Example 2. Figure <ref type="figure">2</ref> gives the H * -max-clique tree TH * (with h-vertices shaded) computed from the GH * of the example graph G in Figure <ref type="figure" target="#fig_0">1</ref>. Each root-to-leaf path in TH * represents an H *max-clique and thus there are totally eight H * -max-cliques. The MH consists of only two cliques {a, b, c} and {b, c, d, e} (MH = {abc, bcde} for short), which can be obtained from TH * too.</p><p>The set of H + -max-cliques obtained from the G H + in Figure <ref type="figure" target="#fig_0">1</ref> is M H + = {abcwx , acy, bcde, cey, drz , esy}. We now compute M1, M2, and M3 from TH * (and partial GH nb ). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Computing H + -max-cliques from H*-max-cliques</head><p>We now discuss the algorithm to compute M1, M2 and M3, as shown in Algorithm 2.</p><p>It is straightforward to obtain both M1 and M2, by performing a depth-first search (DFS) on TH * (Lines 2-9). We do not store explicitly the set MH and search it to check whether C1 ∈ MH (Line 7). Instead, we mark each vertex u whose root-to-u path forms a clique in MH when we construct TH * (see the last paragraph of Section 4.1.2). Thus, we only need to check whether v k-1 is marked in Line 7. We explain how to compute maxCL(•) later.</p><p>To obtain M3, we first compute X in Line 10 as follows. We enumerate all proper subsets of each C1 ∈ MH in Line 7. We then check the conditions defined in X (see Eq. ( <ref type="formula" target="#formula_31">10</ref>)) to prune the unqualified subsets. The checking of the last in X is similar to the maximality checking when constructing TH * . Note that the set HNB (C) of a clique C can be easily obtained from TH * as the set of h-neighbor leaves of the paths containing C.</p><p>Given X , we then compute EXT (C ′ 1 ) for each C ′ 1 ∈ X (Line 12). The maximality checking defined in EXT (C ′ 1 ) (see Eq. ( <ref type="formula">11</ref>)) is done in the same way as that in X . As for the computation of maxCL(HNB(C ′ 1 )), we use an existing in-memory MCE algorithm. Since HNB (C ′ 1 ) consists of common h-neighbors of all vertices in C ′ 1 , HNB(C ′ 1 ) is small and thus it is efficient to compute maxCL(HNB(C ′ 1 )). However, in order to compute maxCL(HNB(C ′ 1 )), we need to know the induced subgraph G HNB (C ′ 1 ) . Note that once we get TH * , we remove GH * from the memory. Thus, we now have more space to keep partial GH nb . In order to avoid random access to G in the disk, we do the following. Let N be the available memory. For all h-neighbor leaves in TH * ordered by the DFS traversal, we divide them into k partitions Pi (1 ≤ i ≤ k) such that the adjacency lists of the h-neighbors in each Pi can fit into N . We then read G from the disk sequentially and for each v ∈ H nb , we write (nb(v)\H) into the partition(s) v is in. We keep the first partition in the memory, while each of the other partitions is written into consecutive disk pages. In this way, we read a partition (partial GH nb ) into Algorithm 2 Compute-H + -max-cliques Input: TH * (and partial GH nb ) </p><formula xml:id="formula_36">Output: M H + 1. Initilize M 1 = M 2 = M 3 = ∅; 2. for each path p = v 1 , . . . , v k in T H * do 3. if (v k ∈ H) 4. M 1 ← M 1 ∪ {(v 1 , . . . , v k )}; / *</formula><formula xml:id="formula_37">M 3 ← M 3 ∪ {C ′ 1 ∪ C ′ 2 : C ′ 2 ∈ EXT (C ′ 1 )}; 14. return M H + ← (M 1 ∪ M 2 ∪ M 3 );</formula><p>the memory each time when computing maxCL(HNB (C ′ 1 )) and avoid random access in the disk.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Recursive steps</head><p>Now, M H + is computed and outputted, and GH * and TH * are discarded. We are ready to move on to the remaining part of G.</p><p>Let G ′ be the remaining part of G after removing GH * , which means that we delete all h-vertices and their incident edges from G to give G ′ . The first step is to extract a subgraph of G ′ that we can compute the max-cliques from it in the memory. Can we extract another H * -graph G ′ H * from G ′ (wrt. another h ′ ) in the same way as we extract GH * from G?</p><formula xml:id="formula_38">For any vertex v in G ′ , d(v) ≤ h (otherwise v should be in GH * instead). Thus, h ′ ≤ h and |G ′ H * | ≤ h 2 .</formula><p>In this case, G ′ H * is too small and we will need to scan G many times to compute M, which is not desirable.</p><p>We propose to extract a subgraph from G ′ with a similar size to GH * as follows.</p><p>Definition 10 (L * -GRAPH). Let L be a set of vertices randomly selected from</p><formula xml:id="formula_39">G ′ = (V ′ , E ′ ) such that v∈L d(v, G ′ ) ≃ |GH * |. (<label>12</label></formula><formula xml:id="formula_40">)</formula><p>We define GL * = (L ∪ L nb , ELL ∪ ELL nb ), where</p><formula xml:id="formula_41">L nb = {v : u ∈ L, v / ∈ L, (u, v) ∈ E ′ }, ELL = {(u, v) : u, v ∈ L, (u, v) ∈ E ′ }, and ELL nb = {(u, v) : u ∈ L, v ∈ L nb , (u, v) ∈ E ′ }.</formula><p>Note that GL * is defined based on L in the same way as GH * is on H. Therefore, we can apply the method developed for GH * in Sections 4.1 and 4.2 to compute the max-cliques from GL * , by simply replacing H with L. After that, G ′ is updated by removing GL * . This process continues recursively until G ′ becomes empty.</p><p>There is a small problem in the transition from H to L. Consider the 2nd recursive step, i.e., the step right after we compute M H + . A clique C may be maximal in G L + , but C may not be maximal in G, because it is possible that</p><formula xml:id="formula_42">∃C ′ ∈ M H + such that C ′ ⊃ C and C ′ H nb = C. We remark that if C is maximal in G H + , then C is also maximal in G,</formula><p>because H only has connection with H nb while L may have connection with both H and L nb .</p><p>We address this problem as follows. For each Check the maximality of L + -max-cliques by X; 13.</p><formula xml:id="formula_43">C ∈ M H + , if |CH nb | &gt; 1, we keep CH nb in a hashtable. Let C ′ be a max-clique in G L + . If |C ′ | = 1, then C ′ = {v} is maximal in G only if d(v) = 0. If |C ′ | &gt; 1, we hash C ′ to check if C ′ exists in the hashtable. If C ′ is not in the hashtable, then C ′ is maximal in G and we also add C ′ L nb (if |C ′ L nb | &gt; 1)</formula><p>Output L + -max-cliques that are globally maximal; 14.</p><p>Update X (see the last paragraph of Section 4.3); 15. Remove G H * (or</p><formula xml:id="formula_44">G L * ) from G; 16. ExtMCE(G, k + 1, |G H * |);</formula><p>maximality checking in subsequent recursive steps. Otherwise, C ′ is not maximal and we also remove C ′ from the hashtable, since C ′ will not be computed again in subsequent steps. We also control the number of cliques kept in the hashtable as follows. After each round of max-clique computation from GL * , we delete all C in the hashtable if ∃v ∈ C such that v ∈ L, because all max-cliques containing v are generated after we finish GL * (by Theorem 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Overall Algorithm: ExtMCE</head><p>The overall recursive algorithm ExtMCE is presented in Algorithm 3. The set of all max-cliques in G can be computed by invoking ExtMCE(G, 1, 0). The second parameter k of the algorithm specifies the depth of the recursive process and the last parameter b sets a size bound on the portion of G that is under max-clique computation in each recursive step. b is set as 0 initially for the first step and as |GH * | for the following recursive steps.</p><p>We state the correctness of ExtMCE in the following theorem.</p><p>THEOREM 5. The results returned by ExtMCE is sound and complete with respect to the set of all max-cliques in G.</p><p>PROOF. We first prove the soundness. At the first recursive step, the set of H + -max-cliques is computed in Line 7 and outputted directly in Line 10 of ExtMCE. The H + -max-cliques are proved to be maximal in G in Theorem 2. Next, at each subsequent recursive step, L + -max-cliques are computed (Line 7). The maximality of the outputted L + -max-cliques is ensured by the checking in Line 12 of ExtMCE.</p><p>We now prove the completeness. At the first step, the set of H + -max-cliques is complete with respect to the max-cliques in G that contain at least one vertex in H (by Theorem 2). At the second recursive step, L + -max-cliques are computed in the same way as H + -max-cliques (Line 7). This means that the set of L +max-cliques is complete with respect to the set of max-cliques in (G\GH * ) that contain at least one vertex in L. Combining with the H + -max-cliques (computed from GH * ) that contain at least one vertex in L, it gives a complete set of max-cliques in G that contain at least one vertex in L. Similarly by recursion, a complete set of max-cliques in G that contain at least one vertex in the corresponding L is given after each recursive step. Since the recursion terminates when the graph G becomes empty (i.e., all vertices have been considered to form max-cliques), the algorithm gives a complete set of max-cliques in G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Complexity. The memory space complexity of ExtMCE is O(|GH * |</head><p>+|TH * |). We need O(|G|/|GH * |) scans of G for the entire process. We now analyze the time complexity of ExtMCE when compared with an in-memory MCE algorithm A. Let A(G) denote the algorithm A when it is applied directly to the whole graph G. If we only consider the in-memory operations, the time required for the entire recursive steps in ExtMCE is comparable to that of A(G). This is because Algorithm 2 essentially expands those paths in TH * (or TL * ) that would be generated by A(G) as well, while the computation of each maxCL(HNB(•)) is also necessary in A(G). Thus, if the memory is big enough to hold the whole graph G, ExtMCE performs comparably to A(G). However, if the memory is insufficient (a typical case for a massive graph G), A(G) would incur many random disk accesses to G, while ExtMCE has a bounded number of scans of G, which is much more efficient. These conclusions are empirically verified by our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">UPDATE IN DYNAMIC NETWORKS</head><p>We consider two types of updates: edge insertion and edge deletion. Vertex insertion/deletion can be considered as a series of edge insertions/deletions proceded/followed by the insertion/deletion of an isolated vertex, which is a rather trivial operation. Note that G is also updated, but we focus our discussion on updates directly related to the H * -max-cliques. In other words, we only maintain the H * -max-cliques to be up-to-date, while we compute the set of all max-cliques M periodically or on demand.</p><p>We first consider the insertion of a new edge e = (u, v) and the possible updates to H * -max-cliques. First, if u, v / ∈ H, we do not need to update H or TH * , unless u and/or v now becomes an h-vertex. Next, if u ∈ H and/or v ∈ H, inserting e creates new H * -max-clique(s). Let NB uv = nb(u) ∩ nb(v) denote the set of common neighbors of u and v. We find the cliques that can form larger cliques with {u, v} as S = {C : C ⊆ (C ′ ∩ NBuv ), C ′ ∈ MH * , C = ∅}, which can be obtained easily by traversing TH * . To ensure the maximality, we take away non-maximal cliques in S and get SM = {C : C ∈ S, ∄C ′ ∈ S s.t. C ′ ⊃ C}. Then, for each C ∈ SM , we insert (C ∪ {u, v}) into TH * . We also remove (C ∪ {u}) and/or (C ∪ {v}) from TH * if they are originally in the tree. Note that if S = ∅, then {u, v} is maximal and we simply insert {u, v} into TH * .</p><p>We now consider deleting an edge e = (u, v). If u, v / ∈ H, there is no update needed for H and TH * . If u ∈ H and/or v ∈ H, we need to remove from TH * all H * -max-cliques containing both u and v. Thus, we need to find S ′ = {C : u, v ∈ C, C ∈ MH * }. Assume that u ≺ v, we can obtain S ′ by finding all occurrences of v in the subtree rooted at each occurrence of u in TH * , and collecting the H * -max-cliques containing both u and v by traversing the corresponding paths. We remove each C ∈ S ′ from TH * . We also insert (C\{u}) and/or (C\{v}) if they now become maximal.</p><p>We give an analysis on the cost of the updates as well as on the frequency of the updates.</p><p>On Now we examine how frequent these updates are performed. Since we only perform updates related to the H * -max-cliques, there is no update for the insertion or deletion of an edge (u, v), where u, v / ∈ H. As shown in Section 3.2, the size of H, i.e., h, is usually very small compared to the total number of vertices in G. Therefore, the percentage of the updates in G that can "hit" an h-vertex and thus trigger an update in H * -max-cliques is very low, which is also verified in our experimental studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTAL EVALUATION</head><p>We evaluate the performance of our method, comparing with the state-of-the-art in-memory MCE algorithm <ref type="bibr" target="#b28">[27]</ref> and the only existing streaming MCE algorithm for dynamic networks <ref type="bibr" target="#b27">[26]</ref>, denoted as in-mem and streaming in our experiments. We ran all experiments on a machine with a 3.0GHz Pentium 4 CPU and 2GB RAM, running Windows XP. Datasets. We use four datasets: protein, blogs, LiveJournal (LJ), and Web. Protein is a human protein interaction network from the Human Protein Database (www.hprd.org), in which vertices are proteins and edges are protein-protein interactions. The blogs network is collected from the top-15 popular queries published by Technorati (technorati.com) every three hours from Nov 2006 to Mar 2008. In the blogs network, vertices are blogs and edges indicate that two blogs appear in the same search result. LJ is the free on-line community called Livejournal (www.livejournal.com), where vertices are members and edges represent friendship between members. The Web graph is obtained from the YAHOO webspam dataset (barcelona.research.yahoo.net/webspam), where vertices are pages and edges are hyperlinks. We give the details of each dataset (number of vertices and edges, physical storage size) as follows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Evaluation of the H*-graph</head><p>Table <ref type="table" target="#tab_7">3</ref> shows that it is very efficient to extract GH * from G. The majority of the time is used to read the graph from the disk, which is an inevitable cost. Table <ref type="table" target="#tab_8">4</ref> reports the sizes of H, H nb , GH , GH * and G H + . We also give a better perception on the sizes of GH , GH * and G H + as their ratio to G (given in parenthese in the table). For all datasets, H is small but it extends to a much larger h-neighbor set H nb . As a result, GH is too small, thus requiring many disk scans for MCE computation, while G H + is too large, thus demanding too much memory. On the contrary, GH * is much smaller than G H + but is significantly greater than GH , thus allowing more efficient MCE computation with reasonable memory usage. As seen from the size ratio, LJ has a relatively smaller GH * and G H + than other datasets, which is mainly because the vertices in LJ are less densely connected as indicated by its small |H| wrt. |V |. Table <ref type="table" target="#tab_9">5</ref> shows the average closeness of the h-vertices, the percentage of vertices in G that are reachable from the h-vertices (reachability), the number of max-cliques, and the accuracy of estimating |TH * |. The closeness of an h-vertex u is defined as AVG v∈V,dist (u,v) =∞ (dist (u, v)), where dist(u, v) is the length of the shortest path from u to v in G. The closeness shows that from the h-vertices, we can reach other vertices in G within a few steps and we are able to reach the majority of the vertices in G. This result demonstrates that GH * represents a significant portion of G and that GH * also has a close relationship with the rest part of G.</p><p>Table <ref type="table" target="#tab_9">5</ref> also reports the number of all max-cliques, the number of those max-cliques containing h-vertices and h-neighbors. The result shows that the number of max-cliques containing h-vertices is significantly smaller than that of all max-cliques. The result justifies the feasibility of our update maintenance based on a much smaller set of cliques containing h-vertices since it is much more efficient. From the h-vertices we can extend to the h-neighbors, while the result shows that the set of max-cliques containing hneighbors represents a large portion of the whole set of max-cliques.</p><p>Finally, Table <ref type="table" target="#tab_9">5</ref> shows that our method of estimating |TH * | is highly accurate. Thus, the result verifies the effectiveness of setting memory-bound at the first step of ExtMCE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance of ExtMCE</head><p>Figure <ref type="figure" target="#fig_8">3</ref> reports the total running time and peak memory consumption of finding the set of all max-cliques using ExtMCE, inmem, and streaming, respectively.</p><p>First, on the smaller networks protein and blogs, ExtMCE is as fast as in-mem, but with only 1 quarter of the memory usage of in-mem. The result verifies our assertion in Section 4.4 that the time complexity of ExtMCE is indeed comparable to that of an inmemory MCE algorithm.</p><p>On the larger networks, the advantage of ExtMCE over in-mem is immediately seen. As shown in Figure <ref type="figure" target="#fig_8">3</ref>(b), in-mem runs out of memory, while ExtMCE computes the result for all the networks with a bounded memory consumption. The corresponding running time for in-mem is thus not shown in Figure <ref type="figure" target="#fig_8">3</ref>(a) since in-mem does not complete the MCE task.</p><p>We are only able to obtain the result of streaming for the smallest protein network, which already takes many orders of magnitude more time to complete. The result is because streaming reads an  We further analyze ExtMCE by showing the number of recursions it requires for each dataset. As shown in Table <ref type="table" target="#tab_10">6</ref>, the number of recursions actually performed by ExtMCE is very close to the estimated number, |G|/|GH * |. LJ has a higher number of recursions since its H * -graph is relatively smaller as shown in Table <ref type="table" target="#tab_8">4</ref>. Table <ref type="table" target="#tab_10">6</ref> also shows that the percentage of the total running time used for the first recursive step, i.e., ExtMCE operates on GH * . It shows that a large portion of the time is spent on computing the max-cliques at the first step (except LJ), which also justifies the choice of GH * for dynamic update maintenance. We also find that the peak memory consumption indeed occurs at the first recursive step, which verifies the correctness of O(|GH * | + |TH * |) as the memory bound for ExtMCE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Performance on Update Maintenance</head><p>Table <ref type="table" target="#tab_11">7</ref> reports the results for update maintenance. We use the blogs network, whose edges are associated with a timestamp, spanning over 12 months. We average the results for every two monthperiod, shown as P1-P6 in Table <ref type="table" target="#tab_11">7</ref>. The network grows from 347K edges to 6.5M edges.</p><p>Table <ref type="table" target="#tab_11">7</ref> shows that the average time of processing an edge insertion that triggers an update in TH * , shown as "Avg. update time", is only 2 to 3 msec. The exception is P1 which requires 10 msec. This is because the initial network is not large enough and hence TH * changes considerably during P1, which is also reflected by the rapid increase in the number of h-vertices from P1 to P2.</p><p>Table <ref type="table" target="#tab_11">7</ref> also shows "# of updates in GH * ", which is the number of edge insertions that trigger an update in TH * , and "# of updates in G", which is the number of all edges inserted into the network. On average, the percentage of edges that trigger an update in TH * is only 3.8%, which is a small portion of the total updates. Thus, updating only TH * is a feasible solution to handle frequent updates.</p><p>Among the existing algorithms, streaming is the only one that updates the set of max-cliques upon each edge insertion. However, streaming is three orders of magnitude slower than our algorithm on average. We do not report the result for streaming because it takes too long to complete all updates (it has taken 190 hours to update only 40K edges at the time of writing).</p><p>The number of h-vertices increases stably as the network increases, except the initial network which is relatively small and thus unstable. We also show % of h-vertices retained, that is, the percentage of h-vertices in Pi that are also in Pi+1. The result shows that the majority of the h-vertices remains to be h-vertices.</p><p>We also show the memory consumption, which increases as the network grows. Note that the memory consumption is the same amount of memory needed for computing the set of all max-cliques by ExtMCE, since O(|GH * | + |TH * |) sets the bound for the memory usage of ExtMCE.</p><p>Finally, the last two rows of Table <ref type="table" target="#tab_11">7</ref> report the time to compute the set of all max-cliques from the dynamically maintained TH * ("Time w/ TH * ") and from scratch ("Time w/o TH * "), respectively. The result shows that it is much more efficient to compute the set of all max-cliques from the dynamically maintained TH * than from scratch from the network, thus demonstrating the benefit of update maintenance as well as the feasibility of maintaining MH * (i.e., TH * ) for M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>There is a large literature on MCE. We discuss the more prominent and recent ones, a comprehensive review can be found in <ref type="bibr" target="#b10">[9]</ref>. The first significant improvement on MCE was the algorithms <ref type="bibr" target="#b3">[2,</ref><ref type="bibr" target="#b8">7]</ref> that use the backtracking method. They take O(n 2 ) memory space. Further improvements <ref type="bibr" target="#b20">[19,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b10">9]</ref> were made by selecting good pivots to prune the backtracking search tree. The optimal worst-case time of backtracking-based MCE was shown to be O(3 n/3 ) <ref type="bibr" target="#b28">[27]</ref>. Recently, parallel algorithms <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b26">25]</ref> were proposed to enumerate max-cliques from different points of the search tree in parallel. However, all these works did not focus on reducing the memory complexity and require O(m + n) memory space in the best case. Output-sensitive MCE algorithm was also introduced <ref type="bibr" target="#b29">[28]</ref> which is based on reverse search, and recent work <ref type="bibr" target="#b22">[21]</ref> used matrix multiplication to reduce the time delay to O(d 4 max ) for sparse graphs (but with O(nm) preprocessing time), where dmax is the maximum degree of a graph. There is also algorithm that obtains a k-clique by joining two (k -1)-cliques <ref type="bibr" target="#b21">[20]</ref>. However, all these algorithms require memory space at least Ω(m + n). Stix <ref type="bibr" target="#b27">[26]</ref> proposed an algorithm that updates the set of max-cliques upon each edge insertion, and the graph is read only once. Finally, we are aware of a recent work that adopts the concept of h-index for triangle counting <ref type="bibr" target="#b14">[13]</ref>. Their work does not address the memory issue and takes O(m+n) memory, while the problem of MCE is also substantially more difficult than that of triangle counting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSIONS</head><p>We propose ExtMCE, the first external-memory algorithm for</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An Example Graph G</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>The first step: extract GH * from G, compute the set of local max-cliques in GH * , obtain and output a subset of global max-cliques from local max-cliques by linking to the remaining part of G, and update G by removing GH * ; • The i-th step: extract another subgraph Gi (of similar structure as GH * ), where |Gi| ≤ |GH * |, from G, repeat the first step (by replacing GH * with Gi);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>we have CH nb = ∅, which implies that C = CH and C ∈ MH. We have C ∈ MH * as well since CH nb = ∅. Thus, C ∈ (MH ∩ MH * ) = M1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>LEMMA 7 .</head><label>7</label><figDesc>∀C ∈ MH , there exists a path p ∈ TH * such that the set of h-vertices in p equals to C. PROOF. For each C ∈ MH , we sort the vertices in C by ≺ as C = {v1, . . . , v k }. First, if HNB (C) = ∅, since C is maximal in GH , there must exist a root-to-leaf path p = v1, . . . v k in TH * . Next, if HNB (C) = ∅, i.e., ∃u ∈ HNB(C), then p = v1, . . . , v k , u must be a root-to-leaf path in TH * (since C is maximal in GH).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>THEOREM 4 .</head><label>4</label><figDesc>M H + can be computed from TH * and GH nb .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 : 1 M2</head><label>21</label><figDesc>Figure 2: TH * of G in Figure 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>edge insertion, the cost is O(|TH * | + |S| 2 + C∈S M (|C ∪ {u, v}| log favg )) time, where favg is the average number of children of a node in TH * . Computing S takes O(|TH * |) time. Computing SM takes time less than |S| 2 since we do not need to compare cliques with the same size, or those largest cliques in S. In most cases, |S| is small because otherwise it implies that u and v are very closely related and hence the edge (u, v) is likely to already exist. Finally, inserting each (C ∪ {u, v}) takes at most O(log favg ) time at each level of TH * . On edge deletion, it takes O(|TH * | + C∈S ′ (|C| log favg )) time to obtain S ′ and delete C (as well as to insert (C\{u}) and/or (C\{v}) if they are maximal).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Performance of ExtMCE</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Notations</head><label>1</label><figDesc></figDesc><table><row><cell>Symbol</cell><cell>Description</cell></row><row><cell>n</cell><cell>Number of vertices in graph G = (V, E)</cell></row><row><cell>m</cell><cell>Number of edges in graph G = (V, E)</cell></row><row><cell>|G|</cell><cell>Size of G, defined as |G| = |E| = m</cell></row><row><cell>GS</cell><cell>Induced subgraph of G by a set of vertices S</cell></row><row><cell>nb(v); nb(v, GS)</cell><cell>The set of neighbors of a vertex v in G / GS</cell></row><row><cell>d(v); d(v, GS)</cell><cell>The degree of v in G / GS</cell></row><row><cell>H</cell><cell>The set of h-vertices in G; ∀v ∈ H, d(v) ≥ h</cell></row><row><cell>Hnb</cell><cell>The set of h-neighbors in G (non-h-vertices)</cell></row><row><cell>H +</cell><cell>H ∪ Hnb</cell></row><row><cell>GH ; G H</cell><cell></cell></row></table><note><p>+ H-graph / H + -graph; the induced subgraph of G by H / H + GH * H * -graph; GH * = (H + , EHH ∪ EHH nb ) M the set of max-cliques in the whole graph G MX the set of X-max-cliques in GX , X can be H * , H + , or H TH * H * -max-clique tree; a prefix-tree to keep MH * C=</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>2 H + ). ∀C = (C1 ∪ C2) ∈ M2, we have CH = C1 and CH nb = C2. Since CH ∈ MH , CH is maximal in GH . Since CH nb ∈ maxCL(HNB(CH )), CH nb is also maximal in G HNB (C H ) , which defines the h-neighborhood shared by all vertices in CH. Thus, C is maximal in G H + (i.e., C ∈ M H + ). Since CH / ∈ M1, we have HNB(CH ) = ∅ and thus CH nb = ∅. Since C ∈ M H + , CH ∈ MH , and CH nb = ∅, we have C ∈ M 2 H + . (Prove M 2 H + ⊆ M2). ∀C ∈ M 2 H + , CH nb = ∅ and CH ∈ MH . Thus, CH ∈ (MH\M1). Since C is maximal in H + , CH nb must be maximal in G HNB (C H ) , i.e., CH nb ∈ maxCL(HNB(CH )). Let C1 = CH and C2 = CH nb , we have C ∈ M2.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>which implies that HNB (C ′ H ) ⊆ HNB(CH ). Since C ′ H nb ⊇ CH nb and they are maximal respectively in G HNB (C ′ This contradicts to CH nb ∈ EXT (CH) since there exists C ′ ∈ M2 such that C ′ H ⊃ CH and C ′ H nb = CH nb . Thus, M3 ⊆ M H + . Finally, ∀C ∈ M3, we have CH nb = ∅ since ∅ / ∈ EXT (CH), and CH / ∈ MH since CH ∈ X and is a proper subset of some C ′′ ∈ MH . Thus, we further have M3 ⊆ M 3 H + . (Prove M 3 H + ⊆ M3). ∀C ∈ M 3 H + , CH / ∈ MH and CH nb = ∅. First, CH must be a proper subset of some C ′ ∈ MH. Assume that CH /</figDesc><table /><note><p>H ) and G HNB (C H ) , but HNB (C ′ H ) ⊆ HNB (CH), we have C ′ H nb = CH nb and HNB(C ′ H ) = HNB(CH ). Since C ′ H ⊃ CH and HNB (C ′ H ) = HNB(CH ), we have C ′ H / ∈ X (otherwise, CH / ∈ X since CH is subsumed by C ′ H ). Therefore, C ′ H can only be in MH . Since C ′ H nb = CH nb = ∅, we have C ′ ∈ M2.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>H + ) gives exactly M H + . By Lemmas 4-6, we have (M1 ∪ M2 ∪ M3) = M H + . Now we show that TH * (plus the knowledge of the edges between the h-neighbors) is sufficient to compute M H + . We only need partial GH nb but do not keep GH nb in memory (see details in Section 4.2.3). Before discussing the computation of M H + from TH * , we first show that MH can be obtained from TH * by the following lemma.</figDesc><table><row><cell>where M1, M2</cell></row><row><cell>and M3 are defined in Lemmas 4-6.</cell></row><row><cell>PROOF. By the categorization, M 1 H + , M 2 H + and M 3 H + are disjoint and (M 1 H + ∪ M 2 H + ∪ M 3</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>into the hashtable for the</figDesc><table><row><cell cols="2">Algorithm 3 ExtMCE</cell></row><row><cell cols="2">Input: G, recursive depth k, size bound b</cell></row><row><cell cols="2">Output: M</cell></row><row><cell cols="2">1. if (G is empty) return;</cell></row><row><cell cols="2">2. if (k = 1) 3. Compute-H  *  -graph (Alg. 1); / *  1st-step: compute G H  *   * /</cell></row><row><cell cols="2">4. else 5. Compute-L  *  -graph with size bounded by b (Def. 10); / *  recursive steps: compute G L  *   * /</cell></row><row><cell cols="2">6. Construct T H  *  (or T L  *  ) by an existing MCE algorithm A; 7. Compute-H + (or L + )-max-cliques (Alg. 2); 8. if (k = 1) / *  H + -max-cliques are max-cliques by Theorem 2  * /</cell></row><row><cell>9. 10.</cell><cell>Build a global hashtable X (see the last paragraph of Section 4.3); Output H + -max-cliques;</cell></row><row><cell cols="2">11. else</cell></row><row><cell>12.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 : Datasets (K = 1,000 and M = 1,000,000)</head><label>2</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">protein blogs</cell><cell>LJ</cell><cell>Web</cell></row><row><cell>n = |V |</cell><cell>20K</cell><cell>1M</cell><cell cols="2">4.8M 10M</cell></row><row><cell>m = |E|</cell><cell>40K</cell><cell cols="2">6.5M 43M</cell><cell>80M</cell></row><row><cell>Storage size (MB)</cell><cell>1</cell><cell>186</cell><cell cols="2">1310 2613</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 : Time and memory usage of extracting GH *</head><label>3</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">protein blogs</cell><cell>LJ</cell><cell>Web</cell></row><row><cell>Total time (sec)</cell><cell>0.3</cell><cell>38</cell><cell cols="2">243 524</cell></row><row><cell>Disk-read (sec)</cell><cell>0.2</cell><cell>31</cell><cell cols="2">199 405</cell></row><row><cell>Memory (MB)</cell><cell>1.2</cell><cell>8.5</cell><cell>27</cell><cell>140</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Sizes of H, H nb , GH , GH * and G H +</figDesc><table><row><cell></cell><cell>protein</cell><cell>blogs</cell><cell>LJ</cell><cell>Web</cell></row><row><cell>|H|</cell><cell>77</cell><cell>718</cell><cell>987</cell><cell>2982</cell></row><row><cell>|H nb |</cell><cell>4K</cell><cell>192K</cell><cell>441K</cell><cell>4.4M</cell></row><row><cell>|G H |</cell><cell>0.5K (1%)</cell><cell cols="3">37K (0.6%) 25K (0.06%) 29K (0.04%)</cell></row><row><cell>|G H  *  |</cell><cell cols="2">8.6K (22%) 840K (13%)</cell><cell>1.7M (4%)</cell><cell>25M (31%)</cell></row><row><cell cols="2">|G H + | 21K (54%)</cell><cell>4M (64%)</cell><cell>11M (25%)</cell><cell>54M (68%)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 5 : Closeness, reachability, # of max-cliques, and</head><label>5</label><figDesc>|TH * |</figDesc><table><row><cell></cell><cell cols="2">protein blogs</cell><cell>LJ</cell><cell>Web</cell></row><row><cell>closeness (h-vertices)</cell><cell>3.1</cell><cell>3.4</cell><cell>4.3</cell><cell>7.1</cell></row><row><cell>reachability (h-vertices)</cell><cell>47%</cell><cell>56%</cell><cell>100%</cell><cell>73%</cell></row><row><cell># of max-cliques</cell><cell>25K</cell><cell cols="3">1.1M 173M 267M</cell></row><row><cell>(contain h-vertices)</cell><cell>239</cell><cell>4K</cell><cell>69K</cell><cell>7.8M</cell></row><row><cell>(contain h-neighbors)</cell><cell>12K</cell><cell>510K</cell><cell>43M</cell><cell>146M</cell></row><row><cell>(estimated |T H  *  |)/|T H  *  |</cell><cell>1.00</cell><cell>1.01</cell><cell>0.93</cell><cell>0.97</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 6 : Actual/estimated number of recursions</head><label>6</label><figDesc></figDesc><table><row><cell></cell><cell cols="2">protein blogs</cell><cell>LJ</cell><cell>Web</cell></row><row><cell># of recursions</cell><cell>5</cell><cell>9</cell><cell>25</cell><cell>7</cell></row><row><cell>|G|/|G H  *  |</cell><cell>4.5</cell><cell>7.7</cell><cell>24.6</cell><cell>3.2</cell></row><row><cell>Time (1st recursion)</cell><cell>67%</cell><cell>36%</cell><cell>2%</cell><cell>34%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 7 : Results for update maintenance</head><label>7</label><figDesc></figDesc><table><row><cell></cell><cell>P1</cell><cell>P2</cell><cell>P3</cell><cell>P4</cell><cell>P5</cell><cell>P6</cell></row><row><cell>Avg. update time (msec)</cell><cell>10</cell><cell>3</cell><cell>2</cell><cell>2</cell><cell>2</cell><cell>3</cell></row><row><cell># of updates in G H  *</cell><cell>3K</cell><cell>11K</cell><cell>19K</cell><cell>25K</cell><cell>28K</cell><cell>28K</cell></row><row><cell># of updates in G</cell><cell cols="6">385K 457K 550K 461K 526K 670K</cell></row><row><cell># of h-vertices</cell><cell>294</cell><cell>425</cell><cell>508</cell><cell>566</cell><cell>614</cell><cell>696</cell></row><row><cell>% of h-vertices retained</cell><cell>92</cell><cell>92</cell><cell>95</cell><cell>96</cell><cell>94</cell><cell>96</cell></row><row><cell>Memory (MB)</cell><cell>418</cell><cell>427</cell><cell>436</cell><cell>443</cell><cell>451</cell><cell>463</cell></row><row><cell>Time w/ T H  *  (sec)</cell><cell>12</cell><cell>22</cell><cell>45</cell><cell>68</cell><cell>86</cell><cell>114</cell></row><row><cell>Time w/o T H  *  (sec)</cell><cell>36</cell><cell>62</cell><cell>104</cell><cell>142</cell><cell>177</cell><cell>226</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">ACKNOWLEDGMENTS</head><p>This research is supported in part by the AcRF Tier-1 Grant (M52020092) from Ministry of Education of Singapore, the Chinese University of Hong Kong (CUHK) Direct Grant No. 2050474, the RGC Research Direct Grant of the CUHK Projects 2050421 and 2150472, the CUHK Postdoctoral Fellowship Grant 2008-2009, and the RGC of the Hong Kong SAR, CUHK No. 419008.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">ExtMCE recursively processes a small part of a large graph at a time, while ensuring that the set of max-cliques computed in the local steps is correct and complete in the whole graph. ExtMCE bounds the memory usage by the H * -graph, a novel concept defined based on the notion of h-index. We test ExtMCE on large networks of up to 10 million vertices and 80 million edges and verify that the effectiveness of using the H * -graph for bounding memory usage. Our experimental results show that ExtMCE achieves comparable running time compared with the state-of-the-art in-memory MCE algorithm [27], but uses significantly less memory. For the larger networks, the inmemory algorithm [26] and show that ExtMCE is orders of magnitude more efficient</title>
		<imprint/>
	</monogr>
	<note>computation on large real-world networks. We also verify the feasibility of update maintenance on large networks based on the H * -graph</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On the relative efficiency of maximal clique enumeration algorithms, with applications to high throughput computational biology</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Abu-Khzam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">E</forename><surname>Baldwin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Langston</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Samatova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Research Trends in Science and Technology</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The enumeration of maximal cliques of large graphs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Akkoyunlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Informant accuracy in social network data iv: a comparison of clique-level structure in behavioral and cognitive network data</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">R</forename><surname>Bernard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Killworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Sailer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Social Networks</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="191" to="218" />
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Emergent clique formation in terrorist recruitment</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">M</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Smrcka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turnley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The AAAI-04 Workshop on Agent Organizations: Theory and Practice</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Emergence of large cliques in random scale-free networks</title>
		<author>
			<persName><forename type="first">G</forename><surname>Bianconi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Marsili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Europhysics Letters</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="740" to="746" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Statistical analysis of financial networks</title>
		<author>
			<persName><forename type="first">V</forename><surname>Boginski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Butenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Pardalos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Statistics &amp; Data Analysis</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="431" to="443" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Algorithm 457: finding all cliques of an undirected graph</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kerbosch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="575" to="577" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Algorithms for k-colouring and finding maximal independent sets</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Byskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="456" to="457" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A note on the problem of reporting maximal cliques</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cazals</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Karande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">407</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="564" to="568" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Segmentation and automated social hierarchy detection through email network analysis</title>
		<author>
			<persName><forename type="first">G</forename><surname>Creamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rowe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hershkop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">J</forename><surname>Stolfo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WebKDD/SNA-KDD</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="40" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Evolution of networks: From biological nets to the internet and www</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Dorogovtsev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F F</forename><surname>Mendesand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallel algorithm for enumerating maximal cliques in complex network</title>
		<author>
			<persName><forename type="first">N</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Xin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mining Complex Data</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="207" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The h-index of a graph and its application to dynamic subgraph statistics</title>
		<author>
			<persName><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">S</forename><surname>Spiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WADS</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="278" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">On power-law relationships of the internet topology</title>
		<author>
			<persName><forename type="first">M</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Faloutsos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="251" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Social network analysis: Methods and applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wasserman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An index to quantify an individual&apos;s scientific research output</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Hirsch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the National Academy of Sciences of the United States of America</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="issue">46</biblScope>
			<biblScope unit="page" from="16569" to="16572" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Estimating search tree size</title>
		<author>
			<persName><forename type="first">P</forename><surname>Kilby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Slaney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thiébaux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Walsh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Estimating the efficiency of backtrack programs</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">129</biblScope>
			<biblScope unit="page" from="121" to="136" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Enumerating all connected maximal common subgraphs in two graphs</title>
		<author>
			<persName><forename type="first">I</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">250</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="1" to="30" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Visualizing plant metabolomic correlation networks using clique-metabolite matrices</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Weckwerth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Linke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Fiehn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1198" to="1208" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">New algorithms for enumerating all maximal cliques</title>
		<author>
			<persName><forename type="first">K</forename><surname>Makino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Uno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SWAT</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="260" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Large maximal cliques enumeration in sparse graphs</title>
		<author>
			<persName><forename type="first">N</forename><surname>Modani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Dey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="1377" to="1378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cluster-c, an algorithm for the large-scale clustering of protein sequences based on the extraction of maximal cliques</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mohseni-Zadeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brézellec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Risler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Biology and Chemistry</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="218" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The structure and function of complex networks</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E J</forename><surname>Newman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Review</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="167" to="256" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A scalable, parallel algorithm for maximal clique enumeration</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Samatova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-H</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="417" to="428" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Finding all maximal cliques in dynamic graphs</title>
		<author>
			<persName><forename type="first">V</forename><surname>Stix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and applications</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="173" to="186" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The worst-case time complexity for generating all maximal cliques and computational experiments</title>
		<author>
			<persName><forename type="first">E</forename><surname>Tomita</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Takahashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">363</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="28" to="42" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A new algorithm for generating all the maximal independent sets</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tsukiyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ariyoshi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shirakawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="505" to="517" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">From pull-down data to protein interaction networks and complexes with biological relevance</title>
		<author>
			<persName><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B.-H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">V</forename><surname>Karpinets</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">F</forename><surname>Samatova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="979" to="986" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
