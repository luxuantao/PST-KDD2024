<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Faster and Simpler Algorithms for Multicommodity Flow and other Fractional Packing Problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Naveen</forename><surname>Garg</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Jochen</forename><surname>Könemann</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering</orgName>
								<orgName type="institution">Indian Institute of Technology</orgName>
								<address>
									<settlement>New Delhi</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">GSIA</orgName>
								<orgName type="institution" key="instit2">Carnegie Mellon University Pittsburgh</orgName>
								<address>
									<postCode>15213-3890</postCode>
									<region>PA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Faster and Simpler Algorithms for Multicommodity Flow and other Fractional Packing Problems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">429B5CD383E3A94DD786200B77808DCB</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T08:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper considers the problem of designing fast, approximate, combinatorial algorithms for multicommodity flows and other fractional packing problems. We provide a different approach to these problems which yields faster and much simpler algorithms. Our approach also allows us to substitute shortest path computations for min-cost flow computations in computing maximum concurrent flow and min-cost multicommodity flow; this yields much faster algorithms when the number of commodities is large.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Consider the problem of computing a maximum s-t flow in a graph with unit edge capacities. While there are many different algorithms known for this problem we discuss one which views the problem purely as one of packing s-t paths so that constraints imposed by edge-capacities are not violated. The algorithm associates a length with each edge and at any step it routes a unit flow along the shortest s-t path.</p><p>It then multiplies the length of every edge on this path by 1 + for a fixed . Thus the longer an edge is the more is the flow through it. Since we always choose the shortest s-t path to route flow along, we essentially try to balance the flow on all edges in the graph. One can argue that, if, after sufficiently many steps, M is the maximum flow through an edge, then the flow computed is almost M times the maximum s-t flow. Therefore scaling the flow by M gives a feasible flow which is almost maximum.</p><p>Note that the length of an edge at any step is exponential in the total flow going through the edge. Such a length function was first proposed by Shahrokhi and Matula <ref type="bibr" target="#b12">[13]</ref> who Supported by the EU ESPRIT LTR Project N. 20244 (ALCOM-IT). Work done while the author was at the Max-Planck-Institut für Informatik, Im Stadtwald, 66123 Saarbrücken, Germany.</p><p>y Work done while the author was at the Universität des Saarlandes, Im Stadtwald, 66123 Saarbrücken, Germany. used it to compute the throughput of a given multicommodity flow instance. While this problem (and all other problems considered in this paper) can be formulated as a linear program and solved to optimality using fast matrix multiplication <ref type="bibr" target="#b15">[16]</ref>, in <ref type="bibr" target="#b12">[13]</ref> were mainly interested in providing fast, possibly approximate, combinatorial algorithms. Their procedure, which applied only to the case of uniform edge capacities, computed a (1 + !)-approximation to the maximum throughput in time polynomial in ! ?1 . The key idea of their procedure, which was adopted in a lot of subsequent work, was to compute an initial flow by disregarding edge capacities and then to reroute this, iteratively, along short paths so as to reduce the maximum congestion on any edge.</p><p>The running time of <ref type="bibr" target="#b12">[13]</ref> was improved significantly by Klein et.al. <ref type="bibr" target="#b8">[9]</ref>. It was then extended and refined to the case of arbitrary edge capacities by Leighton et.al. <ref type="bibr" target="#b9">[10]</ref>, Goldberg <ref type="bibr" target="#b3">[4]</ref> and Radzik <ref type="bibr" target="#b11">[12]</ref> to obtain better running times; see Table <ref type="table" target="#tab_0">1</ref> for the current best bound.</p><p>Plotkin, Shmoys and Tardos <ref type="bibr" target="#b10">[11]</ref> and Grigoriadis and Khachiyan <ref type="bibr" target="#b6">[7]</ref> observed that a similar technique could be applied to solve any fractional packing or covering problem. Their approach, for packing problems, starts with an infeasible solution. The amount by which a packing constraint is violated is captured by a variable which is exponential in the extent of this violation. At any step the packing is modified by a fixed amount in a direction determined by these variables. Hence, the running time of the procedure depends upon the maximum extent to which any constraint could be violated; this is referred to as the width of the problem <ref type="bibr" target="#b10">[11]</ref>. The running time of their algorithm for packing problems being only pseudo-polynomial, <ref type="bibr" target="#b10">[11]</ref> suggest different ways of reducing the width of the problem.</p><p>In a significant departure from this line of research and motivated by ideas from randomized rounding, Young <ref type="bibr" target="#b16">[17]</ref> proposed an oblivious rounding approach to packing problems. Young's approach has the essential ingredient of previous approaches -a length function which measures, and is exponential in, the extent to which each constraint is violated by a given solution. However, <ref type="bibr" target="#b16">[17]</ref> builds the solution from scratch and at each step adds to the packing a variable which violates only such packing constraints that are not already too violated. In particular, for multicommodity flow, it implies a procedure which does not involve rerouting flow (the flow is only scaled at the end) and which for the case of maximum s-t flow reduces to the algorithm discussed at the beginning of this section.</p><p>Our Contributions. In this paper we provide a unified framework for a host of multicommodity flow and packing problems which yields significantly simpler and faster algorithms than previously known. Our approach is similar to Young's approach for packing problems. However, we develop a new and simple combinatorial analysis which has the added flexibility that it allows us to make the greatest possible advance at each step. Thus for the setting of maximum s-t flows with integral edge capacities, Young's procedure routes a unit flow at each step while our procedure would route enough flow so as to saturate the minimum capacity edge on the shortest s-t path. This simple modification is surprisingly powerful and delivers better running times and simpler proofs. In particular, it lets us argue that the contribution of a constraint to the running time of the procedure cannot exceed a certain bound which is independent of the width. This yields a new and straightforward strongly-polynomial combinatorial approximation algorithm for the fractional packing problem (Section 3). The earlier algorithm for this problem, due to Grigoriadis and Khachiyan <ref type="bibr" target="#b4">[5]</ref> reduced the problem to two resource sharing problems.</p><p>Our approach yields a new, very natural, algorithm for maximum concurrent flow (Section 5) which extends in a straightforward manner to min-cost multicommodity flows (Section 6). Both these algorithms use a min-cost flow computation as a subroutine as do all earlier algorithms. Contradicting popular belief that using min-cost flow as a subroutine is better, we provide algorithms for these two problems which use shortest path computations as a subroutine and are faster than previous algorithms by at least a fac- Table <ref type="table" target="#tab_0">1</ref> summarizes our results. T sp and T mcf are the times to compute single-source shortest paths and singlecommodity min-cost flow in a graph with positive edge lengths and costs while T orc is the time taken for each call to an oracle as in <ref type="bibr" target="#b10">[11]</ref>. All our algorithms are deterministic and compute a (1 + !)-approximation to the optimum solution. For brevity we define C 1 def = d 1 1 log 1+ 1 me where (1 ? 1 ) ?2 = 1 + ! and C 2 def = d 1 2 log 1+ 2 m 1? 2 e where (1 ? 2 ) ?3 = 1 + !.</p><p>Note that in the running time of our algorithms for concurrent flow problems we can replace C 2 log k by O(log n(! ?2 + log k)) using a trick from earlier papers; we remark on this in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Maximum multicommodity flow</head><p>Given a graph G = (V; E) with edge capacities c : E ! R + and k pairs of terminals (s i ; t i ), with one commodity associated with each pair, we want to find a multicommodity flow such that the sum of the flows of all commodities is maximized. The dual of the maximum multicommodity flow problem is an assignment of lengths l : E ! R + to the edges such that D(l) def = P e l(e)c(e) is minimized. This is subject to the constraint that the shortest path between any pair s i ; t i under the length function l, which we denote by dist i (l), is at least one. Let (l) def = min i dist i (l) be the minimum length path between any pair of terminals. Then the dual problem is equivalent to finding a length function l : E ! R + such that D(l) (l) is minimized. Let def = min l D(l)= (l). The algorithm proceeds in iterations. Let l i?1 be the length function at the beginning of the i th iteration and f i?1 be the total flow routed in iterations 1 : : : i ? 1. Let P be a path of length (l i?1 ) between a pair of terminals and let c be the capacity of the minimum capacity edge on P. In the i th iteration we route c units of flow along P. Thus f i = f i?1 + c. The function l i differs from l i?1 only in the lengths of the edges along P; these are modified as l i (e) = l i?1 (e)(1 + c=c(e)), where is a constant to be chosen later.</p><p>Initially every edge e has length , ie., l 0 (e) = for some constant to be chosen later. For brevity we denote (l i ); D(l i ) by (i); D(i) respectively. The procedure stops after t iterations where t is the smallest number such that (t) 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Analysis</head><p>For every iteration i 1 D(i) = = D(i ? 1) + (f i ? f i?1 ) (i ? 1) which implies that</p><formula xml:id="formula_0">D(i) = D(0) + i X j=1</formula><p>(f j ? f j?1 ) (j ? Consider the length function l i ?l 0 . Note that D(l i ?l 0 ) = D(i) ? D(0) and (l i ? l 0 ) (i) ? L where L is the longest path along which flow is routed. Hence D(l i ? l 0 ) (l i ? l 0 ) D(i) ? D(0) (i) ? L Substituting this bound on D(i) ? D(0) in equation 1 we</p><formula xml:id="formula_1">get (i) L + i X j=1</formula><p>(f j ? f j?1 ) (j ? 1)</p><p>Note that for any i, (i) is maximum when for all j; 0 j i ? 1, (j) is the largest possible. Hence (i) (i ? 1)(1 + (f i ? f i?1 )= ) (i ? 1)e (fi?fi?1)= Since (0) L this implies (i) Le fi= Proof: Consider an edge e. For every c(e) units of flow routed through e the length of e increases by a factor of at least 1 + . The last time its length was increased, e was on a path of length strictly less than 1. Since every increase in edge-length is by a factor of at most 1 + , l t (e) &lt; 1 + . Since l 0 (e) = it follows that the total flow through e is at most c(e) log 1+ 1+ . Scaling the flow, f t , by log 1+ 1+</p><p>then gives a feasible flow of claimed value.</p><p>Thus the ratio of the values of the dual and the primal solutions, , is ft log 1+ 1+ . By substituting the bound on =f t from (2) we obtain</p><formula xml:id="formula_2">log 1+ 1+ ln( L) ?1 = ln(1 + ) ln 1+ ln( L) ?1</formula><p>The ratio ln(1+ ) ?1 ln( L) ?1 equals (1 ? ) ?1 for = (1 + )((</p><p>)L) ?1= . Hence with this choice of we have</p><formula xml:id="formula_4">(1 ? ) ln(1 + ) (1 ? )( ? 2 =2) (1 ? ) ?2</formula><p>Since this quantity should be no more than our approximation ratio (1 + w) we choose appropriately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Running time</head><p>In the i th iteration we increase the length of the minimum capacity edge along P by a factor of 1 + . Since for any edge e, l 0 (e) = and l t (e) &lt; 1 + the number of iterations in which e is the minimum capacity edge on the path chosen in that iteration is at most d 1 log 1+ Le. Using the fact that there are m edges we get the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2.1</head><p>There is an algorithm that computes a (1 ?</p><p>) ?2 -approximation to the maximum multicommodity flow in time md 1 log 1+ LeT sp where L is the length of the longest path between any source-sink pair and T sp is the time required to compute the shortest s-t path in a graph with non-negative edge-weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Packing LP</head><p>A packing LP is a linear program of the kind max c T xjAx b; x 0 where A; b and c are (m n); (m 1) and (n 1) matrices all of whose entries are positive. We also assume that for all i; j, the (i; j) th entry of A, A(i; j), is at most b(i). The dual of this LP is min b T yjA T y c; y 0 . We view the rows of A as edges and the columns as paths. b(i) is the capacity of edge i and every unit of flow routed along the j th column consumes A(i; j) units of capacity of edge i while providing a benefit of c(j) units. The dual variable y(i) corresponds to the length of edge i.</p><p>Define the length of a column j with respect to the dual variables y as length y (j) def = P i A(i; j)y(i)=c(j). Finding a shortest path now corresponds to finding a column whose length is minimum; define (y) def = min j length y (j).</p><p>Also define D(y) def = b T y. Then the dual program is equivalent to finding a variable assignment y such that D(y)= (y)</p><p>is minimized.</p><p>Once again our procedure will be iterative. Let y k?1 be the dual variables and f k?1 the value of the primal solution at the beginning of the k th iteration. Let q be the minimum length column of A ie., (y k?1 ) = length y k?1 (q) -this corresponds to the path along which we route flow in this iteration. The minimum capacity edge is the row for which b(i)=A(i; q) is minimum; let this be row p. Thus in this iteration we will increase the primal variable x(q) by an amount b(p)=A(p; q) so that f k = f k?1 +c(q)b(p)=A(p; q).</p><p>The dual variables are modified as</p><formula xml:id="formula_5">y k (i) = y k?1 (i)(1 + b(p)=A(p; q) b(i)=A(i; q) )</formula><p>where is a constant to be chosen later.</p><p>The initial values of the dual variables are given by y 0 (i) = =b(i), for some constant to be chosen later. For brevity we denote (y k ); D(y k ) by (k); D(k) respectively. Thus D(0) = m . The procedure stops at the first iteration t such that D(t) 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Analysis</head><p>The analysis here proceeds almost exactly as in the case of maximum multicommodity flow. For every iteration k</p><formula xml:id="formula_6">1 D(k) = X i b(i)y k (i) = X i b(i)y k?1 (i) + b(p) A(p; q) X i A(i; q)y k?1 (i) = D(k ? 1) + (f k ? f k?1 ) (k ? 1)</formula><p>which, as before, implies that</p><formula xml:id="formula_7">D(k) = D(0) + k X l=1</formula><p>(f l ? f l?1 ) (l ? 1) Proof: The primal solution x we constructed has value f t .</p><p>However, it may not be feasible since some packing constraint ( P j A(i; j)x(j))=b(i) 1 may be violated. When we pick column q and increase x(q) by b(p)=A(p; q) we increase the left-hand-side (LHS) of the i th constraint by A(i;q)b(p) b(i)A(p;q) (= z say). Simultaneously we increase the dual variable y(i) by a multiplicative factor of 1 + z. By our definition of p it follows that z 1 and hence increasing the LHS of the i th constraint by 1 causes an increase in y(i) by a multiplicative factor of at least 1 + . Note that y t?1 (i) &lt; 1=b(i) and so y t (i) &lt; (1 + )=b(i). Since y 0 (i) = =b(i) it follows that the final value of the LHS of the i th constraint is no more than log 1+ 1+ . Since this is true for every i, scaling the primal solution by log 1+ 1+</p><p>gives a feasible solution of value as in the claim.</p><p>The rest of the analysis is exactly the same as in Section 2.1 with m replacing L. Thus = (1 + )((1 + )m) ?1= .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Running time</head><p>In the k th iteration we increase the dual variable of the "minimum capacity" row by a factor of (1 + ). Since for any row i, y 0 (i) = =b(i) and y t (i) &lt; (1 + )=b(i) and there are m rows in all, the total number of iterations is at most md 1 log 1+ me. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Spreading metrics</head><p>Given a graph G = (V; E) with edge costs c : E ! R + , a spreading metric is an assignment of lengths to the edges, l : E ! R + , so as to minimize P e l(e)c(e) subject to the constraint that for any set S V and vertex r 2 S, P v2S dist r;v (l) f(S) where dist r;v (l) is the dis- tance from r to v under the length function l and f() is a function only of the size of S. For the linear arrangement problem f(S) = (jSj ? 1)(jSj ? 3)=4 <ref type="bibr" target="#b1">[2]</ref> while for the problem of computing a -separator 1 f(S) is defined as jSj ? jV j <ref type="bibr" target="#b2">[3]</ref>.</p><p>Since the length function l is positive, the shortest paths from r to the other vertices in S forms a tree -the shortest path tree rooted at r. Thus the above constraints can be equivalently stated as: for any tree T, for any subset S of vertices in T and for any vertex r 2 S X v2S dist r;v (l; T) f(S) where dist r;v (l; T) denotes the distance from r to v in tree T under the length function l.</p><p>Let u e (T; S; r) be the number of vertices of S in the subtree below edge e when T is rooted at r. Note that the packing LP has exponentially many variables. However, the (1 + w)-approximation to the optimum fractional solution, in the previous Section, only needed an oracle that returned the "most violated constraint" of the dual LP. In this setting, this oracle is a subroutine, which, given a length function l finds a triple (T; S; r)</p><p>for which ( P e2T l(e)u e (T; S; r))=f(S), or equivalently ( P v2S dist r;v (l; T))=f(S), is minimum. Our subroutine will try out all n choices for vertex r and for each of these it will determine the best choice of T; S. For a given r and every subset S, the expression 1 a minimum cost set of edges whose removal disconnects the graph into connected components each of which has at most jV j vertices. P v2S dist r;v (l; T) is minimized when T is the tree of shortest paths from r and under the length function l. Therefore, for a given r, our choice of T will be the shortest path tree rooted at r. Since f(S) depends only on jSj, given that jSj = k, the ratio ( P v2S dist r;v (l; T))=f(S) is min- imized when S is the set of k nearest vertices to r. Amongst the n different choices for k, and hence for S, we choose the set for which the above ratio is minimum.</p><p>The subroutine thus requires n single-source shortest path computations. The running time of the procedure is obtained by noting that the subroutine is invoked once in each of the md 1 log 1+ me iterations. Theorem 4.1 There is an algorithm that computes a (1 ? ) ?2 -approximation to Spreading metrics in time md 1 log 1+ menT sp where T sp is the time required to compute single-source shortest paths in a graph with nonnegative edge-weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Maximum concurrent flow</head><p>Once again we are given a graph with edge capacities c : E ! R + and k commodities with s i ; t i being the source, sink for commodity i. Now each commodity has a demand d(i) associated with it and we want to find the largest such that there is a multicommodity flow which routes d(i) units of commodity i. Let min cost j (l) be the minimum cost of shipping d(j) units of flow from s j to t j where l(e) is the cost of shipping one unit of flow along edge e and the total flow through e is at most c(e). Further let (l) def = P k j=1 min cost j (l). The dual problem now is an assignment of lengths to the edges, l : E ! R + , such that D(l)= (l) is minimized. Let be this minimum. For now we assume that 1 and shall remove this assumption later.</p><p>The algorithm now proceeds in phases; each phase is composed of k iterations. Consider the j th iteration of the i th phase and let l i;j?1 be the length function before this iteration. In this iteration we route d(j) units of commodity j along the paths given by min cost j (l i;j?1 ). Let f i;j (e) be the flow through edge e. The length function is modified as l i;j (e) = l i;j?1 (e)(1 + f i;j (e)=c(e)). Then D(l i;j ) = X e l i;j (e)c(e) = D(l i;j?1 ) + X e l i;j?1 (e)f i;j (e) = D(l i;j?1 ) + min cost j (l i;j?1 )</p><p>The lengths at the start of the (i + 1) th phase are the same as that at the end of the i th phase, ie., l i+1;0 = l i;k . Initially, for any edge e, l 1;0 (e) = =c(e) = l 0;k (e).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">The Analysis</head><p>We shall be interested in the values of the functions D(); () only for the length functions l i;k ; i 0. For brevity we denote D(l i;k ); (l i;k ) by D(i); (i) respectively. With these new notations we have for i 1 D(i) = D(l i;k ) = D(l i;0 ) + k X j=1 min cost j (l i;j?1 )</p><p>Since the edge-lengths are monotonically increasing min cost j (l i;j?1 ) min cost j (l i;k ) and hence</p><formula xml:id="formula_8">D(i) D(l i;0 )+ k X j=1 min cost j (l i;k ) = D(i?1)+ (i) Since D(i) (i)</formula><p>we have where the last inequality uses our assumption that 1.</p><formula xml:id="formula_9">D(i) D(i ? 1) 1 ? = Since D(0) = m we have for i 1 D(i) m (1 ? = ) i = m 1 ? = (1 + ? ) i?1</formula><p>The procedure stops at the first phase t for which D(t) 1.</p><p>Therefore,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">D(t) m</head><p>1 ? e (t?1) (1? ) which implies t ? 1 (1 ? ) ln 1? m</p><p>In the first t ? 1 phases, for every commodity j, we have routed (t ? 1)d(j) units. However, this flow may violate capacity constraints.</p><p>Claim 5.1 &gt; fract ? 1log 1+ 1= .</p><p>Proof: Consider an edge e. For every c(e) units of flow routed through e, we increase its length by at least a factor 1 + . Initially, its length is =c(e) and after t ? 1 phases, since D(t ? 1) &lt; (1 ? ) 2 ln(1 + ) (1 ? ) 2 ( ? 2 =2) (1? ) ?3</p><p>Now it remains to choose suitably so that (1 ? ) ?3 is at most our desired approximation ratio 1 + w.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Running time</head><p>By weak-duality we have</p><formula xml:id="formula_11">1 &lt; t ? 1 log 1+ 1</formula><p>and hence the number of phases in the above procedure, t, is strictly less than 1 + log 1+ 1= which implies that t = d log 1+ m 1? e.</p><p>The running time of our computation depends on which can be reduced/increased by multiplying the demands/capacities appropriately. Let z i be the maximum possible flow of commodity i and let z def = min i z i =d(i).</p><p>Then z denotes the maximum fraction of the demands that can be routed independently and hence z=k z. We scale the capacities/demands so that z=k = 1 thus satisfying our assumption that 1. Note however that could now be as large as k.</p><p>If our procedure does not stop within 2d 1 log 1+ m 1? e (= T, say) phases then we know that 2. We double the demands of all commodities and continue the procedure. Note that is now half its value in the previous phase and is at least 1. We run the procedure for an additional T phases and if it does not halt we again double demands. Since we halve the value of after every T phases, the total number of phases is at most T log k.</p><p>Theorem 5.1 There is an algorithm that computes a (1 ?</p><p>) ?3 -approximation to the maximum concurrent flow in time 2k log kd 1 log 1+ m 1? eT mcf where T mcf is the time re- quired to compute a minimum cost s-t flow in a graph with non-negative edge-costs.</p><p>The number of phases can be reduced further using an idea from <ref type="bibr" target="#b10">[11]</ref>. We first compute a 2-approximation to using the procedure outlined above. This requires O(log k log m) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Minimum cost multicommodity flow</head><p>Given Once again the algorithm proceeds in phases each of which is composed of k iterations. In the j th iteration of the i th phase we begin with length functions (l i;j?1 ; i;j?1 ) and route d(j) units of commodity j. As before, for all edges e, define l i+1;0 (e) = l i;k (e) and l 1;0 (e) = l 0;k (e) = =c(e). Similarly i+1;0 = i;k and 1;0 = =B.</p><p>The flow in each iteration is routed in a sequence of steps; in each step we only route so much flow that its cost does not exceed the bound B. Let (l s?1 i;j ; s?1 i;j ) be the length functions at the start of the s th step (see Fig. <ref type="figure" target="#fig_8">1</ref>); the lengths at the start of the first step are given by l 0 i;j = l i;j?1 and 0 i;j = i;j?1 . Further, let d s?1 i;j be the flow of commod- ity j that remains to be routed in this iteration. We compute f s i;j def = min cost j (l s?1 i;j + b s?1 i;j ) which routes d(j) units of flow of commodity j. Since we need to route only d s?1 i;j units of flow we multiply the flow function f s i;j by d s?1 i;j =d(j). If B s i;j is the cost of flow f s i;j then the cost of the scaled flow is B s i;j d s?1 i;j =d(j). If this quantity exceeds B then we multiply the original flow function f s i;j by B s i;j =B.</p><p>We reuse notation and denote the final scaled flow and its cost by f s i;j ; B s i;j respectively. Now f s i;j routes at most d s?1 i;j units of flow at cost B s i;j B.</p><p>The length functions are modified in a similar manner as before. Thus l s i;j = l s?1 i;j (1 + f s i;j (e)=c(e)) and s i;j = s?1 i;j (1 + B s i;j =B). Further, only d s i;j = d s?1 i;j ? f s i;j , more units of commodity j remain to be routed in this iteration.</p><p>The iteration ends at the step p for which d p i;j = 0. The procedure stops at the first step at which D() exceeds 1; let this happen in the t th phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Analysis</head><p>Note that now D(l s i;j ; s i;j ) = D(l s?1 i;j ; s?1 i;j ) + min cost j (l s?1 i;j + b s?1 i;j )f s i;j =d(j) D(l s?1 i;j ; s?1 i;j ) + min cost j (l p i;j + b p i;j )f s i;j =d(j)</p><p>where the last inequality holds because the edge-lengths are monotonically increasing over steps. The total flow routed in the p steps equals the demand of commodity j, ie., P p s=1 f s i;j = d(j). Summing over all p steps we get D(l p i;j ; p i;j ) D(l 0 i;j ; 0 i;j ) + min cost j (l p i;j + b p i;j )</p><p>The length functions at the start of the (j + 1) th iteration are given by l i;j = l p i;j and i;j = p i;j . Moving from steps to iterations we have D(l i;j ; i;j ) D(l i;j?1 ; i;j?1 ) + min cost j (l i;j + b i;j ) D(l i;j?1 ; i;j?1 ) + min cost j (l i;k + b i;k )</p><p>where the last inequality uses the fact that the edge-lengths are monotonically increasing over iterations. Summing over all iterations in the i th phase we have</p><formula xml:id="formula_12">D(l i;k ; i;k ) D(l i;0 ; i;0 ) + k X j=1 min cost j (l i;k + b i;k ) = D(l i?1;k ; i?1;k ) + (l i;k ; i;k )</formula><p>As before we abbreviate D(l i;k ; i;k ); (l i;k ; i;k ) to D(i); (i) respectively to obtain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D(i) D(i ? 1) + (i)</head><p>The remainder of the analysis is exactly as in Section 5.1. The only modification is in the claim about the throughput of the flow routed. Now we need to argue that the cost of the flow after we scale it by log 1+ 1= is at most B, or equivalently, that the cost of the flow routed in the first t?1 iterations is at most B log 1+ 1= . This follows from the fact that t?1;k &lt; 1=B (since D(t ? 1) &lt; 1), that 1;0 = =B and that in our procedure every time we route flow whose total cost is B we increase by at least a factor 1+ .   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Running time</head><p>Note that except for the last step in each iteration, in all other steps we increase the length function by a factor 1 + . This implies that the total number of steps exceeds the number of iterations by at most log 1+ 1= . Now define z i as the maximum possible flow of commodity i of cost no more than B. Again z def = min i z i =d(i) denotes the maximum fraction of the demands that can be routed if the capacity constraints and the bound B on the cost of the flow applied independently to each commodity. Thus z=k z and we multiply demands suitably so that for the new instance 1 k. As before we double the demands, thereby halving , after every T phases. Thus the number of iterations is kT log k and so our procedure for minimum cost multicommodity flow needs at most (2k log k + 1)d 1 log 1+ m 1? e single-commodity min-cost flow computations. Theorem 6.1 There is an algorithm that computes a (1 ?</p><p>) ?3 -approximation to the maximum cost-bounded concurrent flow in time (2k log k + 1)d 1 log 1+ m 1? eT mcf where T mcf is the time required to compute a minimum cost s-t flow in a graph with non-negative edge-costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Avoiding min-cost flow computations</head><p>We now use ideas from our algorithm for min-cost multicommodity flow to give algorithms for the maximum concurrent flow and min-cost multicommodity flow problems which use shortest path computations instead of min-cost flow computations and are faster than the algorithms in Sec- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Maximum concurrent ow revisited</head><p>Define (l) def = P j d(j)dist j (l) where dist j (l) denotes the shortest path distance between s j and t j under the length function l. The dual to the maximum concurrent flow problem can also be viewed as an assignment of lengths to edges, l : E ! R + , such that D(l)= (l) is minimized. Let be this minimum.</p><p>The structure of this new algorithm is similar to that in the previous section. Thus the algorithm runs in phases each of which is composed of k iterations. In the j th iteration of the i th phase we route d(j) units of commodity j in a sequence of steps. Let l s?1 i;j be the length function before the s th step and let P s i;j be the shortest path between s j and t j , ie., P s i;j has length dist j (l s?1 i;j ). In this step we route f s i;j = min c; d s?1 i;j units of flow along P s i;j where c is the capacity of the minimum capacity edge on this path. We now set d s i;j to d s?1 i;j ? f s i;j ; the iteration ends after p steps where d p i;j = 0.</p><p>Thus at each step we perform a shortest path computation instead of a min-cost flow computation as in Section 6. The length functions are modified in exactly the same manner as before and the analysis is almost exactly the same. Thus after routing all flow of commodity j we have D(l p i;j ) D(l 0 i;j ) + d(j)dist j (l p i;j )</p><p>and after routing all commodities in the i th phase we have</p><formula xml:id="formula_13">D(l i;k ) D(l i;0 ) + k X j=1 d(j)dist j (l i;k )</formula><p>Using the same abbreviations as before we again obtain</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D(i) D(i ? 1) + (i)</head><p>Beyond this point we follow the analysis of Section 5.1 to argue that we have a (1 + !)-approximation for the same choice of and .</p><p>For the running time we again note that in each step, except the last one in an iteration, we increase the length of at least one edge by a factor 1 + . Since each edge has an initial length of and a final length less than 1+ , the number of steps exceeds the number of iterations by at most m log 1+ 1+ . Thus the total number of steps is at most (2k log k + m)d 1 log 1+ m</p><p>1? e and each of these involves one shortest path computation.</p><p>Theorem 7.1 There is an algorithm that computes a (1 ?</p><p>) ?3 - </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Min-cost multicommodity ow revisited</head><p>We now define (l; ) def = P j d(j)dist j (l + b ). The dual to the min-cost multicommodity flow problem is an assignment of lengths to edges, l : E ! R + , and a scalar such that D(l)= (l) is minimized. Let be this minimum.</p><p>The algorithm differs from the one developed in Section 6 in that at any step we route flow along only one path, which, if this is the s th step of the j th phase of the i th iteration, is the shortest path between s j and t j under the length function l s?1 i;j + b s?1 i;j . If the minimum capacity edge on this path has capacity c then the flow function at this step, f s i;j corresponds to routing c units of flow along this path. If c d s?1 i;j and the cost of this flow is less than B we route this flow completely. Else we scale it so that the flow routed in this step has cost no more than B and the total flow routed in this iteration does not exceed d(j).</p><p>The analysis of the algorithm proceeds as in Section 6.1</p><p>with the only modification that min cost j (:) is replaced with d(j)dist j (:). For the running time we need only observe that in each step, except the last step in an iteration, we increase, either the length of some edge or the value of by a factor 1+ . The lengths of the edges and can each be increased by a factor 1 + at most log 1+ 1+ times. Hence the number of steps exceeds the number of iterations by at most (m + 1)d 1 log 1+ m 1? e.</p><p>Theorem 7.2 There is an algorithm that computes a (1 ?</p><p>) ?3 -approximation to the maximum concurrent flow in time (2k log k + m + 1)d 1 log 1+ m 1? eT sp where T sp is the time required to compute the shortest s-t path in a graph with non-negative edge-weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">Integrality</head><p>A multicommodity flow has integrality q if the flow of every commodity on every edge is a non-negative integer multiple of q. In this section we show how small modifications to the algorithms discussed in previous sections lead to flows that have small integrality.</p><p>Our algorithm for maximum multicommodity flow routes flow along a path P in the i th iteration. If c is the capacity of a minimum capacity edge on P then we require that the flow routed in this iteration be no more than c. However, note that if we route q &lt; c units along P and increase the length of an edge e on P by a factor (1 + q=c(e)) then the algorithm still delivers a (1? ) ?2 -approximation to the maximum multicommodity flow, albeit with a worse running time. To obtain a feasible flow we scale the flow constructed in this manner by log 1+ 1= . Thus if we were routing q units in a certain iteration then only q log 1+ 1= units "appear" in the feasible solution.</p><p>Theorem 7.3 Let e be the minimum capacity edge in G and q c(e). Then one can in polynomial time compute a flow f which is a (1 ? ) ?2 -approximation to the maximum multicommodity flow and f has integrality q log 1+ L .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 7.4 If all edges in G have capacity at least</head><p>1 log 1+ L then there is an integral flow which is a (1 ?</p><p>) ?2 -approximation to the maximum multicommodity flow.</p><p>For maximum concurrent flow we use the algorithm from Section 7. Recall that in the s th step of the j th iteration in the i th phase we route f s i;j = min c; d s?1 i;j units of flow along path P s i;j where c is the capacity of the minimum capacity edge on this path and d s?1 i;j is the residual demand of the j th commodity. As in the case of maximum multicommodity flow we route q &lt; f s i;j units of flow in this step and increase the length of an edge e on P by a factor (1 + q=c(e)). To ensure that exactly q units of flow can be routed in each step of the j th iteration we require that d(j) be an integral multiple of q. To obtain a feasible flow we scale the flow constructed by log 1+ 1= . Hence in the final solution the flow appears in units of q log 1+ m=(1? ) . Theorem 7.5 Let e be the minimum capacity edge in G and q c(e). If all demands are integral multiples of q then one can, in polynomial time, compute a flow f which is a (1 ? ) ?3 -approximation to the maximum concurrent flow and f has integrality q log 1+ m=(1? ) . 1? and all demands are integral multiples of 1 log 1+ m 1? then there is an integral flow which is a (1 ? ) ?3 -approximation to the maximum concurrent flow.</p><p>The above theorem and its corollary also hold for the setting of min-cost multicommodity flows.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>m; n are the number of commodities, edges and vertices respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 Claim 3 . 1</head><label>131</label><figDesc>Let def = min y D(y)= (y). Then D(l ? 1)= (l ? 1) ? f l?1 )D(l ? 1) which implies that D(k) m e f k = By our stopping condition 1 D(t) m e ft= and hence f t ln(m ) ?There is a feasible solution to the packing LP of value ft log 1+ 1+</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 3 . 1</head><label>31</label><figDesc>There is an algorithm that computes a (1 ? ) ?2 -approximation to the Packing LP in time md 1 log 1+ meT orc where m is the number of rows and T orc is the time required to compute the minimum length column.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Then the above constraint can be rewritten again to obtain the LP minimize P e l(e)c(e) subject to 8T; 8S T; 8r 2 S P e2T l(e)u e (T; S; r) f(S) The primal program, which is a packing LP, has a nonnegative variable x(T; S; r) for every tree T, subset S T and vertex r 2 S and is as follows maximize P T;S;r x(T; S; r)f(S) subject to 8e 2 E P T:e2T x(T; S; r)u e (T; S; r) c(e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>an instance of the multicommodity flow problem, as in the previous section, edge costs b : E ! R + , where b(e) represents the cost incurred in shipping 1 unit of flow along edge e, and a bound B, we consider the problem of maximizing subject to the additional constraint that the cost of the flow is no more than B. The dual of this linear program is an assignment of lengths to the edges, l : E ! R + , and a scalar -which we view as a length associated with a pseudo-edge of capacity B -such that D(l; ) def = P e l(e)c(e) + B is minimized subject to the constraint that (l; ) def = P j min cost j (l + b) is at least 1. This is equivalent to finding a length function (l; ) such that D(l; )= (l; ) is minimum; let denote this minimum value. As in the case of maximum concurrent flow we begin by assuming that 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The notation used in Sections 6 and 7. The length functions above the central axis are the lengths before the box on the right and the ones below are the lengths after the box on the left.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>tion 5 and 6 by at least a factor min n n; nk log k m o .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Corollary 7 . 6</head><label>76</label><figDesc>If all edges in G have capacity at least 1 log 1+ m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 . A summary of our results</head><label>1</label><figDesc></figDesc><table><row><cell>1) (1)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>1, the length of e satisfies l t?1;k (e) &lt; 1=c(e). Therefore the total amount of flow through e in the first t ? 1 phases is strictly less than</figDesc><table><row><cell cols="4">log 1+ flow by log 1+ 1= implies the claim. 1=c(e) = log 1+ 1= times its capacity. Scaling the</cell></row><row><cell cols="4">Thus the ratio of the values of the dual and primal solu-tions, , is strictly less than t?1 log 1+ 1= . Substituting the bound on =(t ? 1) from (3) we get</cell></row><row><cell>&lt; log 1+ 1= (1 ? ) ln 1? m</cell><cell cols="2">= (1 ? ) ln(1 + )</cell><cell>ln 1= ln 1? m</cell></row><row><cell cols="2">For = (m=(1 ? )) ?1= the ratio ln 1= ln 1? m and hence</cell><cell cols="2">equals (1 ? ) ?1</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The first author would like to Philip Klein, Cliff Stein and Neal Young for useful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Improved approximation algorithms for the multicommodity flow problem and local competitive routing in dynamic networks</title>
		<author>
			<persName><forename type="first">B</forename><surname>Awerbuch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">T</forename><surname>Leighton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, ACM Symposium on Theory of Computing</title>
		<meeting>ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="487" to="496" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Divideand-conquer approximation algorithms via spreading metrics</title>
		<author>
			<persName><forename type="first">G</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, IEEE Symposium on Foundations of Computer Science</title>
		<meeting>IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="62" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast approximate graph partitioning algorithms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Even</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schieber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1997">1997</date>
			<biblScope unit="page" from="639" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A natural randomization strategy for multicommodity flow and related algorithms</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="249" to="256" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">An exponentialfunction reduction method for block-angular convex programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grigoriadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Khachiyan</surname></persName>
		</author>
		<idno>LCSR-TR-211</idno>
		<imprint>
			<date type="published" when="1993">1993</date>
			<pubPlace>New Brunswick, NJ</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Rutgers University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Approximate minimum-cost multicommodity flows in Õ( ?2 knm) time</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grigoriadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Khachiyan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Programming</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="477" to="482" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast approximation schemes for convex programs with many blocks and coupling constraints</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Grigoriadis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">G</forename><surname>Khachiyan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Optimization</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="86" to="107" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Adding multiple cost constraints to combinatorial optimization problems, with applications to multicommodity flows</title>
		<author>
			<persName><forename type="first">D</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, ACM Symposium on Theory of Computing</title>
		<meeting>ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="18" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Faster approximation algorithms for the unit capacity concurrent flow problem with applications to routing and finding sparse cuts</title>
		<author>
			<persName><forename type="first">P</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="466" to="487" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast approximation algorithms for multicommodity flow problems</title>
		<author>
			<persName><forename type="first">T</forename><surname>Leighton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Makedon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Tragoudas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="228" to="243" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast approximation algorithms for fractional packing and covering problems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Shmoys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">É</forename><surname>Tardos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Oper. Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="257" to="301" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast deterministic approximation for the multicommodity flow problem</title>
		<author>
			<persName><forename type="first">T</forename><surname>Radzik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="486" to="492" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The maximum concurrent flow problem</title>
		<author>
			<persName><forename type="first">F</forename><surname>Shahrokhi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Matula</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="318" to="334" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Approximation algorithms for NPhard problems, chapter Cut problems and their application to divide and conquer</title>
		<author>
			<persName><forename type="first">David</forename><surname>Shmoys</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>PWS Publishing Company</publisher>
			<biblScope unit="page" from="192" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Approximation algorithms for multicommodity flow and scheduling problems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIT</title>
		<imprint>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Speeding up linear programming using fast matrix multiplication</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Vaidya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, IEEE Symposium on Foundations of Computer Science</title>
		<meeting>IEEE Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="332" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Randomized rounding without solving the linear program</title>
		<author>
			<persName><forename type="first">N</forename><surname>Young</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting>ACM-SIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="170" to="178" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
