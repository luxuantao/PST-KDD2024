<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Data Retention in MLC NAND Flash Memory: Characterization, Optimization, and Recovery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yu</forename><surname>Cai</surname></persName>
							<email>yucaicai@gmail.com</email>
						</author>
						<author>
							<persName><forename type="first">Yixin</forename><surname>Luo</surname></persName>
							<email>yixinluo@cs.cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Erich</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
							<email>erich.haratsch@lsi.com</email>
							<affiliation key="aff1">
								<orgName type="institution">LSI Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ken</forename><surname>Mai</surname></persName>
							<email>kenmai@ece.cmu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
							<email>omutlu@ece.cmu.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Data Retention in MLC NAND Flash Memory: Characterization, Optimization, and Recovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">61B36B3A0C77EE390FE725FD87430B1E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:22+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>NAND Flash Memory</term>
					<term>Retention</term>
					<term>Threshold Voltage Distribution</term>
					<term>ECC</term>
					<term>Fault Tolerance</term>
					<term>Reliability</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Retention errors, caused by charge leakage over time, are the dominant source of flash memory errors. Understanding, characterizing, and reducing retention errors can significantly improve NAND flash memory reliability and endurance. In this paper, we first characterize, with real 2y-nm MLC NAND flash chips, how the threshold voltage distribution of flash memory changes with different retention age -the length of time since a flash cell was programmed. We observe from our characterization results that 1) the optimal read reference voltage of a flash cell, using which the data can be read with the lowest raw bit error rate (RBER), systematically changes with its retention age, and 2) different regions of flash memory can have different retention ages, and hence different optimal read reference voltages. Based on our findings, we propose two new techniques. First, Retention Optimized Reading (ROR) adaptively learns and applies the optimal read reference voltage for each flash memory block online. The key idea of ROR is to periodically learn a tight upper bound, and from there approach the optimal read reference voltage. Our evaluations show that ROR can extend flash memory lifetime by 64% and reduce average error correction latency by 10.1%, with only 768 KB storage overhead in flash memory for a 512 GB flash-based SSD. Second, Retention Failure Recovery (RFR) recovers data with uncorrectable errors offline by identifying and probabilistically correcting flash cells with retention errors. Our evaluation shows that RFR reduces RBER by 50%, which essentially doubles the error correction capability, and thus can effectively recover data from otherwise uncorrectable flash errors.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Over the past decade, the capacity of NAND flash memory has been increasing continuously, as a result of aggressive process scaling and the advent of multi-level cell (MLC) technology. This trend has enabled NAND flash memory to replace spinning disks for a wide range of applications -from high performance clusters and large-scale data centers to consumer PCs, laptops, and mobile devices. Unfortunately, as flash density increases, flash memory cells become more vulnerable to various types of device and circuit level noise <ref type="bibr" target="#b0">[1]</ref>[2] -e.g., retention noise <ref type="bibr" target="#b1">[2]</ref>[3][4] <ref type="bibr" target="#b4">[5]</ref> <ref type="bibr" target="#b5">[6]</ref>, read disturbance noise <ref type="bibr" target="#b4">[5]</ref>, cellto-cell program interference noise <ref type="bibr" target="#b1">[2]</ref>[7] <ref type="bibr" target="#b7">[8]</ref>, and program/erase (P/E) cycling noise <ref type="bibr" target="#b1">[2]</ref> <ref type="bibr" target="#b8">[9]</ref>. These are sources of errors that can significantly degrade NAND flash reliability.</p><p>A traditional solution to overcome flash errors, regardless of their source, is to use error-correcting codes (ECC) <ref type="bibr" target="#b9">[10]</ref> <ref type="bibr" target="#b10">[11]</ref>. By storing a certain amount of redundant bits per unit data, ECC can detect and correct a limited number of raw bit errors. With the help of ECC, flash memory can hide these errors from the users until the number of errors per unit data exceeds the correction capability of the ECC. Flash memory designers have been relying on stronger ECC to compensate for lifetime reductions due to technology scaling. However, stronger ECC, which has higher capacity and implementation overhead, has diminishing returns on the amount of flash lifetime improvement <ref type="bibr" target="#b2">[3]</ref> <ref type="bibr" target="#b3">[4]</ref>. As such, we intend to look for more efficient ways of reducing flash errors.</p><p>Retention errors, caused by charge leakage over time after a flash cell is programmed, are the dominant source of flash memory errors <ref type="bibr" target="#b1">[2]</ref>[3][4] <ref type="bibr" target="#b11">[12]</ref>. The amount of charge stored in a flash memory cell determines the threshold voltage level of the cell, which in turn represents the logical data value stored in the cell. The flash controller reads data from each cell by applying several read reference voltages to the cell to identify its threshold voltage. As flash memory process technology scales to smaller feature sizes, the capacitance of a flash cell, and the number of electrons stored on it, decreases. State-of-the-art MLC flash memory cells can only store ~100 electrons. Gaining or losing several electrons on a flash cell can significantly change the cell's voltage level and eventually alter the state of the cell. In addition, MLC technology reduces the size of the threshold voltage window <ref type="bibr" target="#b8">[9]</ref>, i.e., the span of threshold voltage values corresponding to each logical state, in order to store more states in a single cell. This also makes the state of a cell more likely to shift due to charge loss caused by retention noise. As such, for flash memory, retention errors are one of the most important limiting factors of more aggressive process scaling and MLC technology.</p><p>One way to reduce retention errors is to periodically read, correct, and reprogram the flash memory before the number of errors accumulated over time exceed the error correction capability of ECC <ref type="bibr" target="#b2">[3]</ref>[4] <ref type="bibr" target="#b12">[13]</ref> <ref type="bibr" target="#b13">[14]</ref>. However, this flash correct and refresh (FCR) technique has two major limitations: 1) FCR uses a fixed read reference voltage to read data under different retention ages, which is suboptimal (as we show in Sec. 3), and 2) FCR requires the flash controller to be consistently powered on so that errors can be corrected, limiting its applicability to enterprise deployments that have always-on power supplies.</p><p>In this paper, we pursue a better understanding of retention error behavior to improve NAND flash reliability and lifetime, and find better ways to mitigate flash retention errors. We characterize 1) the distortion of threshold voltage distribution at different retention ages for state-of-the-art 2y-nm (20-to 24nm) NAND flash memory chips at room temperature, and 2) the retention age distribution of flash pages using disk traces taken from real workloads. Our key findings are: 1) Due to threshold voltage distribution distortion, the optimal read reference voltages of flash cells, at which the minimum raw bit er-ror rate (RBER) can be achieved, systematically shift to lower values as retention age increases. 2) Pages within the same flash block (the granularity at which flash memory can be erased) tend to have similar retention ages and hence similar optimal read reference voltages, whereas pages across different flash blocks have different optimal read reference voltages.</p><p>The key ideas of our approach leverage these findings to 1) optimize flash reliability, lifetime, and performance by learning and applying the optimal read reference voltage for each flash block online, and 2) recover uncorrectable flash errors that exceed the correction capability of ECC by identifying and correcting fast-and slow-leaking cells offline (by comparing the distortion of threshold voltages of different flash cells over different retention ages). Toward this end, we make the following three key contributions:  We are the first to characterize the distortion of threshold voltage distribution over different retention ages for 2y-nm NAND flash memory. We extensively analyze the correlation of this distortion with retention age and its implication on the optimal read reference voltage, raw bit error rate, and P/E cycles (Sec. 3).  We propose Retention Optimized Reading (ROR), a new online technique that reduces raw bit error rate by adaptively learning and applying the optimal read reference voltage for each flash block. Our evaluations show that ROR can extend flash lifetime by 64% and reduce average error correction latency by 10.1%, with only 768 KB storage overhead for a 512 GB flash-based SSD (Sec. 4).  We propose Retention Failure Recovery (RFR), a new offline error recovery technique that identifies fast-and slow-leaking cells and determines the original value of an erroneous cell based on its leakage-speed property and its threshold voltage.</p><p>Our evaluations show that RFR can effectively reduce average RBER by 50%, essentially doubling the error correction capability, which allows for the recovery of data otherwise uncorrectable by ECC (Sec. 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background and Motivation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Basics of NAND Flash Memory</head><p>Fig. <ref type="figure" target="#fig_0">1</ref>(a) shows the cross-sectional view of a flash cell. On top of a flash cell is the control gate (CG) and below is the floating gate (FG). The FG is insulated on both sides, on top by an inter-poly oxide layer and below by a tunnel oxide layer. As a result, the electrons programmed on the floating gate will not discharge even when flash memory is powered off. The voltage applied on the CG generates and controls the conductivity of the conductive channel between the source and the drain electrodes. The minimum voltage that can turn on the channel is called the threshold voltage. The threshold voltage of a flash cell can be changed by injecting different amounts of charge onto the FG, whose generated electric field will partially cancel the electric field from the CG. Thus, the threshold voltage (Vth) of a flash cell can be formulated as <ref type="bibr" target="#b14">[15]</ref>:</p><formula xml:id="formula_0">pp FG thi th C Q V V / ) (   (1)</formula><p>In Eqn. 1, Vthi and Cpp are process-dependent constants. While QFG, the amount of charge that is programmed on the FG, is a variable. As Eqn. 1 shows, with more electrons (which carry negative charge) injected into the floating gate, the threshold voltage of the flash cell increases.</p><p>The threshold voltage range of a flash memory cell is divided into separate regions, with each of the regions representing a predefined binary n-bit value. As an example, for a 2-bit MLC NAND flash memory, the threshold voltage range is divided into four regions (erased, P1, P2, and P3 states), each of which corresponds to a unique 2-bit binary value. In MLC flash memory, the least significant bits are typically organized together to form LSB pages, while the most significant bits form MSB pages.</p><p>Fowler-Nordheim (FN) tunneling. During a program operation, electrons are injected into the FG from the substrate when applying a high positive voltage (e.g., +10V) to the CG. During an erase operation, electrons are ejected from the FG into the substrate when applying a high negative voltage (e.g., -20V) to the CG. The injection and ejection of electrons through the tunnel oxide are enabled by the well-known Fowler-Nordheim (FN) tunneling effect <ref type="bibr" target="#b15">[16]</ref>, whose resulting tunneling current (J FN) <ref type="bibr" target="#b14">[15]</ref> can be modeled as:</p><formula xml:id="formula_1">ox FN E ox FN FN e E J / 2      (2)</formula><p>In Eqn. 2, JFN is the tunneling current density, αFN and βFN are constants, and Eox is the electric field strength in the tunnel oxide. As Eqn. 2 shows, the tunneling current (JFN) exponentially correlates with the oxide electric field strength (Eox).</p><p>When no external voltage is applied to any of the electrodes (i.e., CG, source, and drain) of a flash cell, an electric field still exists between the FG and the substrate, generated by the charge present in the FG. This is called the intrinsic electric field <ref type="bibr" target="#b14">[15]</ref> (illustrated in Fig. <ref type="figure" target="#fig_0">1a</ref>), and is expressed as:</p><formula xml:id="formula_2">ox thi th ox ono ono ox T V V C C C E / ) ( )} /( {     (3)</formula><p>In Eqn. 3, Tox and Vthi are process-dependent constants. This intrinsic electric field generates stress-induced leakage current (SILC) <ref type="bibr" target="#b16">[17]</ref>[18], a weak tunneling current that leaks charge away from the FG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Retention Loss Mechanisms</head><p>Retention loss is the phenomenon that the threshold voltage changes over time without external stimulation. It is caused by the unavoidable trapping of charge within the tunnel oxide <ref type="bibr" target="#b18">[19]</ref>. The amount of trapped charge increases with the electrical stress induced by repeated program and erase operations, which degrade the insulating property of the tunnel oxide. We next explain two failure mechanisms (illustrated in Fig. <ref type="figure" target="#fig_0">1b</ref>), which directly lead to retention loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Trap-assisted tunneling (TAT).</head><p>The electric charge trapped in the tunnel oxide forms an electrical tunnel, which exacerbates the weak tunneling current, SILC. As a result of this TAT effect, the electrons present in the FG leak away much faster through the intrinsic electric field. Hence, the threshold voltage of the flash cell decreases over time. As the flash cell wears out with increasing P/E cycles, the amount of trapped charge also increases <ref type="bibr" target="#b18">[19]</ref>, and so does the TAT effect. At high P/E cycles, the amount of trapped charge is large enough to form percolation paths that will significantly hamper the insulating properties of the gate dielectric <ref type="bibr" target="#b17">[18]</ref>, resulting in retention failure.</p><p>Charge de-trapping. The electric charge trapped in the tunnel oxide can also be spontaneously de-trapped over time <ref type="bibr" target="#b18">[19]</ref>[20] <ref type="bibr" target="#b20">[21]</ref>. Note that the polarity of the trapped charge can be either negative (i.e., electrons) or positive (i.e., holes). Hence, charge de-trapping can either decrease or increase the threshold voltage of a flash cell, depending on the polarity of the de-trapped charge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.">Our Goal</head><p>The goal of this paper is threefold. First, we would like to build a strong understanding, characterization, and analysis of how the threshold voltage distribution of flash memory distorts over retention age, via experiments on and measurements of real NAND flash memory chips. Second, based on this understanding, we aim to devise a new technique that optimizes the read reference voltage for data under different retention ages to minimize the raw bit error rate, and thus improve both the lifetime and system performance of flash memory. Third, we aim to devise a new mechanism that takes advantage of the unique charge-leakage properties of each individual flash cell, to recover the data that otherwise cannot be corrected by ECC due to the accumulated retention errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Retention Loss Characterization</head><p>In this section, we use the methodology described in Sec. 3.1 to characterize the effect of retention age on the threshold voltage distribution (Sec. 3.2), and its implications for the optimal read reference voltage (Sec. 3.3), RBER (Sec. 3.4), and P/E-cycle lifetime (Sec. 3.5). We make eight findings throughout our analysis, which motivate and inspire two new techniques proposed in Sec. 4 and Sec. 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Methodology</head><p>Testing platform. We use an FPGA-based flash memory testing platform <ref type="bibr" target="#b21">[22]</ref> that allows us to issue commands to raw flash chips without ECC. We test 2-bit MLC NAND flash memory devices manufactured in 2y-nm technology. We use the read-retry feature present in these devices to accurately measure the threshold voltage of each cell <ref type="bibr" target="#b8">[9]</ref>. Our previous works describe our testing platform in detail</p><formula xml:id="formula_3">[2][3][4][7][8][9][22].</formula><p>Temperature.</p><p>We characterize the threshold voltage distributions over different retention ages and different P/E cycles at room temperature (20°C) to mimic real-world scenarios. While it is possible to accelerate retention tests under high temperature and compute the equivalent retention age under room temperature with the Arrhenius Law <ref type="bibr" target="#b22">[23]</ref> (as done in <ref type="bibr" target="#b5">[6]</ref>), we believe this method does not accurately represent how NAND flash memories are typically used, as it may exaggerate some causes of retention loss over others <ref type="bibr" target="#b23">[24]</ref>.</p><p>Tests. To characterize the threshold voltage distribution over different P/E cycles, we form multiple groups of flash blocks, and repeatedly erase and program them with random data <ref type="foot" target="#foot_1">1</ref> to different predefined P/E-cycle targets. Note that each group is set to a different P/E-cycle target to cover a collective range of 0 to 50,000 P/E cycles. To characterize the threshold voltage distribution over different retention ages, we first program predefined data to each block. Then, using the read reference voltage sweeping methodology <ref type="bibr" target="#b6">[7]</ref>[9] <ref type="bibr" target="#b21">[22]</ref>, we read and record the threshold voltage distribution of all flash blocks after a certain retention age (i.e., a range of times from 1 day to 40 days) at room temperature. We use a 5-second dwell time<ref type="foot" target="#foot_2">2</ref> for all tests.</p><p>We first use the characterization results from a single representative group at 8k P/E cycles to demonstrate several trends and findings related to the threshold voltage distribution (Figs. <ref type="figure" target="#fig_1">2</ref><ref type="figure" target="#fig_7">3</ref><ref type="figure">4</ref>), the optimal read reference voltage (Fig. <ref type="figure" target="#fig_3">5</ref>), and RBER (Fig. <ref type="figure" target="#fig_4">6</ref>). Note that similar trends and findings hold at different P/E cycles. Then, we use the characterization results from all of the groups to show trends and findings related to flash lifetime (Fig. <ref type="figure">7</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Threshold Voltage Distribution under Retention Loss</head><p>Fig. <ref type="figure" target="#fig_1">2</ref> shows the threshold voltage distribution of flash memory at different retention ages for 8k P/E cycles. The mean and variance of the distributions of different states over the range of tested retention ages are shown in Fig. <ref type="figure" target="#fig_7">3</ref> and Fig. <ref type="figure">4</ref>, respectively. We conclude three findings from these results.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 1: The threshold voltage distributions of the P2 and P3 states systematically shift to lower voltages with retention age.</head><p>In Fig. <ref type="figure" target="#fig_1">2</ref>, we observe that the peaks of the P2 and P3 threshold voltage distributions shift to the left as retention age increases. Fig. <ref type="figure" target="#fig_7">3</ref> further verifies this observation quantitatively -the mean values of the P2 and P3 threshold voltage distributions decrease as retention age increases. However, the same observation does not apply to the P1 state. Fig. <ref type="figure" target="#fig_7">3</ref> shows that for the P1 state, the mean of the threshold voltage distribution remains almost constant.</p><p>As discussed in Sec. 2.2, flash retention loss is caused by a combination of two mechanisms, TAT and charge de-trapping. Charge de-trapping can either increase or decrease the threshold voltage, depending on the polarity of the de-trapped charge. In contrast, TAT can only decrease the threshold voltage, as the resulting SILC can flow only in the direction of the intrinsic electric field generated by the electrons in the FG. In the P2 and P3 states, the intrinsic electric field strength is higher, making TAT the dominant source of retention loss. This explains why we observe the systematic decrease of threshold voltage with retention age.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 2: The threshold voltage distribution of each state becomes wider with higher retention age.</head><p>In Fig. <ref type="figure" target="#fig_1">2</ref>, the threshold voltage distribution of each state becomes wider as retention age increases. Fig. <ref type="figure">4</ref> further shows this observation quantitatively -the variance of all three threshold voltage distributions increases with retention age.</p><p>This trend can be caused by two reasons. First, charge detrapping can either increase or decrease the threshold voltage. Some flash cells with higher threshold voltages (relative to the mean threshold voltage of the corresponding state) might gain charge over time, while some others with lower threshold voltages might lose charge. Second, process variation can cause TAT to decrease threshold voltages at different rates. Some flash cells with higher threshold voltages might leak charge slower due to TAT, while some others with lower threshold voltages might leak charge faster. As a result of both reasons, the threshold voltage distributions become wider and flatter over time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 3: The threshold voltage distribution of a highervoltage state shifts faster than that of a lower-voltage state.</head><p>In Fig. <ref type="figure" target="#fig_7">3</ref>, the slope of the mean threshold voltage change with retention age is steeper for a higher-voltage state than that for a lower-voltage state (ΔP3&gt;ΔP2&gt;ΔP1). We have observed in Finding 1 that the threshold voltage distributions of the P2 and P3 states systematically shift to lower voltages with retention age, and that this slope indicates the speed of the observed shift with retention age.</p><p>As discussed earlier, the systematic decrease of threshold voltage is caused by TAT, which exacerbates the tunneling current, SILC. SILC flows in the direction of the intrinsic electric field, and its magnitude exponentially correlates with the intensity of the intrinsic electric field (as shown in Eqn. 2). Furthermore, the intrinsic electric field intensity is proportional to the threshold voltage of the cell (as shown in Eqn. 3). As a result, a higher-voltage cell experiences a greater amount of SILC, and hence a faster drop in its threshold voltage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Optimal Read Reference Voltage</head><p>A read reference voltage that falls between P1 and P2 states is used to read the LSB page. Two read reference voltages, one falling between the P2 and P3 states and another between the P1 and erased states, are used to read the MSB page. Previous works <ref type="bibr">[7][8]</ref> show that 1) there exists an optimal read reference voltage (OPT) that achieves the minimal RBER between every two neighboring states, 2) when random data is programmed to cells (i.e., each state appears with equal probability), OPT lies at the intersection of neighboring threshold voltage distributions. As the threshold voltage distributions change over retention age, we expect OPT to experience a similar shift.</p><p>Fig. <ref type="figure" target="#fig_3">5</ref> plots the optimal read reference voltage over retention age. Throughout the paper, we denote the OPT between P1 and P2 as P1-P2 OPT and that between P2 and P3 as P2-P3 OPT. Fig. <ref type="figure" target="#fig_3">5</ref>(a) shows a slightly decreasing trend of P1-P2 OPT over retention age. Similarly, but more significantly, P2-P3 OPT decreases over retention age, as shown in Fig. <ref type="figure" target="#fig_3">5(b)</ref>. We conclude two findings from Fig. <ref type="figure" target="#fig_3">5</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 4: Both P1-P2 OPT and P2-P3 OPT become smaller over retention age. Finding 5: P2-P3 OPT changes more significantly over retention age than P1-P2 OPT.</head><p>Since the distribution of the P1 state becomes wider without systematic shifts, the intersection of the P1 and P2 states tends to move to the right (assuming that the distribution of the P2 state does not change). On the other hand, since the threshold voltage distribution of the P2 state shifts to the left, the intersection between the P1 and P2 state distributions tends to shift to the left (assuming the distribution of the P1 state does not change). These two trends counteract each other, and thus P1-P2 OPT shifts only slightly to the left.</p><p>On the other hand, the distributions of the P2 and P3 states both shift to the left, and the amount of the distribution shift for the P3 state is larger than that of the P2 state (as can be seen in Fig. <ref type="figure" target="#fig_7">3</ref>). Therefore, the intersection of the P2 and P3 states systematically shifts to the left. As such, P2-P3 OPT becomes smaller with retention age.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">RBER for Suboptimal Read Reference Voltages</head><p>We have shown in Finding 4 that the optimal read reference voltages can be significantly different for different retention ages. Traditionally, the flash controller uses a fixed read reference voltage for the entire flash memory, and is unaware of the distribution distortion caused by retention age. Such a fixed read reference voltage cannot be optimal for all blocks in flash memory due to two reasons. First, the retention age of an individual block varies over time due to both environmental factors that might change rapidly (e.g., temperature), causing varying amounts of retention loss, and the changing pattern of accesses the block receives. Second, different blocks are likely to be programmed at different times, and thus are likely to have different retention ages.</p><p>To quantify how the choice of read reference voltage affects RBER, we apply the optimal read reference voltages (OPTs) determined for {0, 1, 2, 6, 9, 17, 21, 28}-day retention ages to read 28-day-old data. Fig. <ref type="figure" target="#fig_4">6</ref> shows the RBER obtained when reading the 28-day-old data with different OPTs, normalized to the RBER obtained when reading the data with the 28day OPT. We conclude two major findings from Fig. <ref type="figure" target="#fig_4">6</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 6: The optimal read reference voltage corresponding to one retention age is suboptimal (i.e., it results in a higher RBER) for reading data with a different retention age.</head><p>For example, the RBER obtained when reading with 0-day OPT is 4.6 times higher than the RBER obtained when reading with the actual optimal read reference voltage (28-day OPT) for a retention age of 28 days.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 7: RBER becomes lower when the retention age for which the used read reference voltage is optimized becomes closer to the actual retention age of the data.</head><p>Fig. <ref type="figure" target="#fig_4">6</ref> shows that RBER decreases when the applied OPT (as a function of retention age) becomes closer to the actual OPT for the data. Our previous work <ref type="bibr" target="#b7">[8]</ref> shows that RBER reduces as we apply a read reference voltage closer to the OPT. For example, the RBER of 28-day-old data when reading it with the 17-day OPT is only about 50% of that when reading it with the 6-day OPT. Combining this Finding 7 with Finding 4, which implies a monotonic relationship between OPT and retention age, we conclude that one can reduce RBER by estimating and applying the OPT that corresponds to the actual retention age of the data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Lifetime vs. RBER</head><p>As RBER is affected by the applied read reference voltage, flash memory lifetime also changes correspondingly with the applied read reference voltage. In Fig. <ref type="figure">7</ref>, we show RBER over P/E cycles and the corresponding impact on flash lifetime, assuming all data has a 7-day retention age and is read with the OPT for {0-7}-day retention ages. A typical flash device is considered to be error-free if it guarantees an uncorrectable error rate of less than 10 -15 , which corresponds to traditional data storage reliability requirements <ref type="bibr" target="#b26">[27]</ref>. For an ECC that can correct up to 40 erroneous bits for every 1 KB of data, the acceptable RBER to meet this reliability requirement is 10 -3 (shown by the horizontal dashed line in Fig. <ref type="figure">7</ref>). We conclude one finding from Fig. <ref type="figure">7</ref>. Fig. <ref type="figure">7</ref>. RBER for 7-day-old data read using the optimal read reference voltages of different retention ages, over P/E cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 8: The P/E-cycle lifetime of flash memory can be extended if the optimal read reference voltage that corresponds to the retention age of the data is used.</head><p>Fig. <ref type="figure">7</ref> divides the P/E-cycle lifetime of flash memory into three stages, according to whether or not the RBER can be tolerated by ECC when different read reference voltages are applied. In Stage-0, all the errors are correctable by ECC when any read reference voltage (i.e., 0-day OPT to 7-day OPT) is applied. In Stage-1, the 7-day OPT yields an RBER that is correctable by ECC, while all other read reference voltages result in unacceptable RBERs. In Stage-2, all read reference voltages fail to guarantee an RBER that is correctable by ECC, and hence flash memory comes to the end of its lifetime.</p><p>Note that, similar to Finding 7, as the retention age for which the used read reference voltage is optimized gets closer to the actual retention age of the data, RBER decreases (at any given P/E cycle). Hence, the resulting flash lifetime also improves correspondingly as the applied read reference voltage approaches the actual OPT of the data (7-day OPT).</p><p>We conclude that if we actually apply the 7-day OPT when reading data with 7-day retention age (i.e., when we apply the OPT corresponding to the retention age of the data), RBER reduces in Stage-0 (Finding 7) and flash lifetime improves in Stage-1 (Finding 8). In Sec. 4, we will show that, when RBER becomes lower, flash read latency also reduces (in both stages). This strongly motivates us to estimate the actual OPT of the data (i.e., the OPT corresponding to its retention age), for which we will provide a mechanism in Sec. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Retention Optimized Reading (ROR)</head><p>In this section, we propose (Sec. 4.2) and evaluate (Sec. Sec. 3 and Sec. 4.1) to improve flash performance and P/Ecycle lifetime. We also discuss our design rationale (in Sec.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.4) a new technique called Retention Optimized Reading (ROR), which exploits our new observations and findings (in</head><p>4.1) and analyze how ROR provides better performance (Sec. 4.3 and Sec. 4.4) and lifetime (Sec. 4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Design Rationale</head><p>Recall from Sec. 2.3 that our goal is to devise a new technique to optimize the read reference voltage for data under different retention ages, to minimize RBER and improve flash P/E-cycle lifetime and performance. The results from Sec. <ref type="bibr" target="#b2">3</ref>.5 indicate that we can improve the P/E-cycle lifetime by optimizing the read reference voltage. In this subsection, we make four observations, which we exploit in our ROR technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observation 1: Flash read latency can be reduced by minimizing the number of read retries.</head><p>To understand how to reduce the flash read latency, we first discuss how a flash controller reads data from flash memory. The flowchart in Fig. <ref type="figure" target="#fig_5">8</ref> depicts how a flash controller reads data from flash memory step by step, using a method called read-retry. 1) The flash controller first reads the data out of flash memory with the default read reference voltage. 2) It then sends data for error correction. 3) If ECC successfully corrects all the errors in the data, the read operation succeeds. 4) If ECC fails to correct the errors, the flash controller will read the memory again with a different read reference voltage (go to Step 1). The flash controller iterates through the above steps until either it successfully reads the data using a certain set of read reference voltages or all possible read reference voltages achievable by the flash controller have failed to correctly read the data.</p><p>The overall latency to read data with the read-retry technique can be calculated as:</p><formula xml:id="formula_4">    N i flash i ECC read T T T 1 ) ( ) (<label>(4)</label></formula><p>In Eqn. 4, TECC (i) is the error correction latency during the i-th read-retry iteration, which, as we show in Sec. 4.3, is proportional to the number of errors in the data. Tflash is the time to read the data from flash cells into the flash controller, which is relatively constant. Tflash includes 1) the time to read the data from the flash cell array into the internal flash buffer, and 2) the time to fetch the data from the internal buffer into the flash controller. N is the number of read-retry iterations performed.</p><p>This equation shows that the overall flash read latency is proportional to the number of read-retries. Hence, we can reduce the overall flash read latency by minimizing the number of read-retries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observation 2: The number of read-retries can be reduced by using a closer-to-optimal starting read reference voltage.</head><p>Based on Observation 1, we next try to reduce the number of read-retries. Recall from Finding 4 that the optimal read reference voltage between two states strictly reduces with retention age. This motivates us to set the highest read reference voltage as the starting read reference voltage so that we can reduce it step-by-step on each read-retry failure. As the read reference voltage moves toward the optimal read reference voltage for the retention age, RBER decreases until the data can be successfully read by the controller (i.e., all errors can now be corrected by ECC). The number of readretry steps can be modeled as:</p><formula xml:id="formula_5">V V V N e correctabl start    / ) (<label>(5)</label></formula><p>In Eqn. 5, Vstart is the starting read reference voltage. Vcorrectable is the maximum read reference voltage in the range of [OPT, Vstart] that can achieve an acceptable RBER level (i.e., that can be corrected by ECC). ΔV is the minimal step size by which we can decrease the read reference voltage each time when ECC fails.</p><p>When the read reference voltage is swept down from the starting voltage Vstart towards OPT, the number of raw errors decreases <ref type="bibr" target="#b7">[8]</ref>. Since the read reference voltage is reduced step by step to reduce RBER, Vcorrectable will be the first reference voltage that can be found to reduce RBER to a level that is within the acceptable RBER range for ECC.</p><p>As such, we can see from Eqn. 5 that if we set the starting read reference voltage Vstart close to the optimal read reference voltage, we will be able to reduce the read-retry count (i.e., N), and hence the overall flash read latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Observation 3: The optimal read reference voltages of pages in the same block are close, while those of pages in different blocks are not.</head><p>We next examine how retention age varies across pages in the same block. Typically, the flash controller writes new data to the same block until the block is full. As a result, the difference in retention ages within a block is bounded by the time it takes for the flash controller to fill the block. Given that the block size is small (256 pages), as long as the workload is not write-non-intensive, the retention ages of different pages in the same block would be relatively close to each other (e.g., within one day). As a result, the optimal read reference voltages of pages in the same block should also be close.</p><p>To verify this hypothesis, we simulate traces of 14 real workloads on a NAND flash device for 7 days, and study the workload behavior (our methodology is described in Sec. 4.4). We record the maximum retention age difference between any two pages within the same block. We find that this difference, as we hypothesized, never exceeds one day for any of our evaluated traces (not plotted).</p><p>On the other hand, the OPT of pages in different blocks can be different. Fig. <ref type="figure">9</ref> plots the distribution of the retention ages across all pages after 7 days of operation running 14 real workloads. This figure shows that flash pages across different blocks can have different retention ages (e.g., in hm, different pages have retention ages ranging from 1 to 6 days), even though pages within the same block have similar retention ages. Recall from Finding 6 that data with different retention ages have different optimal read reference voltages. As such, this observation motivates us to record the optimal read reference voltages at a flash block (instead of a smaller page or a larger region) granularity. Within a page, the data in a flash block is programmed in page order (i.e., sequentially from page 0 to page 255, assuming 256 pages per block) to minimize inter-page program interference <ref type="bibr" target="#b6">[7]</ref>. Therefore, according to Finding 4, the optimal read reference voltage for page 255 is no less than that of any other page within the same block (because page 255 is programmed last and thus has the largest retention age). Hence, if we record the optimal read reference voltage of the last-programmed page (page 255), we can get the upper bound of the optimal read reference voltages of all pages in a given block. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Retention Optimized Reading Mechanism</head><p>Next, we propose the Retention Optimized Reading (ROR) technique, which aims to reduce RBER by finding and using OPT for each block. ROR consists of two components: 1) an online pre-optimization algorithm triggered daily and after power-on to learn the starting read reference voltage for each block, and 2) an improved read-retry technique that uses the starting read reference voltage to approach OPT for the block.</p><p>Online pre-optimization algorithm. Motivated by our findings and observations in Sec. 3 and Sec. 4.1, we propose an online pre-optimization algorithm to learn and record OPT for the last-programmed page (i.e., page 255) in each block. As discussed earlier, this recorded reference voltage is a tight upper bound of OPT for the block and hence can be used as the starting read reference voltage. The proposed algorithm consists of the following four steps.</p><p>Step 1 -Initialization. The flash controller first reads page 255 with any default read reference voltage V default, and attempts to correct the errors in the raw data read from the page. Next, we record the number of raw bit errors as the currently lowest error count NERR, and the applied read reference voltage as Vref = Vdefault. If we cannot find the error count (i.e., the error is uncorrectable), we record the maximum number of errors correctable by ECC as NERR.</p><p>Step 2 -Try with a lower read reference voltage. Since we want to find the optimal read reference voltage for page 255 (Observation 4), we approach it from the current starting read reference voltage step by step. Since OPT typically decreases over retention age (Finding 4), we first attempt to lower the read reference voltage. We decrease the read reference voltage to (Vref -ΔV) and read page 255. If the number of corrected errors in the new data is less than or equal to the old NERR, we update NERR and Vref with the new values. We repeat Step 2 until the number of corrected errors in the new data is greater than the old NERR or the lowest possible read reference voltage is reached.</p><p>Step 3 -Try with a higher read reference voltage. Since the optimal threshold voltage might increase in rare cases, we also attempt to increase the read reference voltage. We increase the read reference voltage to (Vref + ΔV) and read page 255. Again, if the number of corrected errors in the new data is less than or equal to NERR, we update NERR and Vref with the new values. We repeat Step 3 until the number of corrected errors in the new data is greater than the old NERR or the highest possible read reference voltage is reached.</p><p>Step 4 -Record the optimal read reference voltage. After Step 3, the currently used Vref is the optimal read reference voltage for page 255. Thus, we record this voltage as the upper bound of the optimal read reference voltages for the block.</p><p>Two possible scenarios for the pre-optimization algorithm are illustrated in Fig. <ref type="figure" target="#fig_8">10</ref>. As the figure shows, whether the default read reference voltage is higher than OPT (Fig. <ref type="figure" target="#fig_8">10a</ref>) or lower than OPT (Fig. <ref type="figure" target="#fig_8">10b</ref>), the algorithm can always find the actual OPT by flexibly adjusting the read reference voltage to either a lower voltage (Step 2) or a higher voltage (Step 3) to achieve a lower RBER. We trigger this algorithm both daily and after power-on for each flash block to maintain a relatively tight upper bound of OPT for all blocks. Recall from Finding 4 that OPT gradually reduces over retention age. By performing pre-optimization daily, we can maintain a good enough estimate of OPT for each block, and thus limit the number of read-retries to a small number during a normal read operation. When the SSD is powered off, the flash controller may lose track of the most upto-date starting read reference voltages. Thus, we trigger the same pre-optimization algorithm after power-on to learn the new starting read reference voltages for all blocks.</p><p>Learning the starting read reference voltages for all blocks may require many iterations of read-retries if we always start from the default read reference voltage. Thus, we speed up the algorithm by reusing the previously learned starting read reference voltage for a block, either from the previous period or from the last power-on, as a prediction of the new starting read reference voltage. When the algorithm is triggered daily, we simply set the default read reference voltage to the previously learned starting read reference voltage. On power off, we store the current set of starting read reference voltages to flash memory as a table. Then, when the algorithm is triggered during power-on, we use the stored read reference voltages as the default read reference voltages.</p><p>Improved read-retry technique. During a normal read operation, we apply an improved read-retry technique that takes advantage of the recorded starting read reference voltage and Observation 4. First, the flash controller attempts to read the data with the recorded starting read reference voltage. Then, since the recorded starting read reference voltage is the upper bound of the OPTs within the block, we iteratively decrease the read reference voltage until the read operation succeeds. Note that the starting read reference voltages are accessed frequently (on each read operation) by the flash controller, so we store them in the SSD's DRAM buffer to allow fast access. Compared with the original read-retry technique (Sec. 4.1), our technique is faster due to two reasons as it uses more information based on our findings: 1) it starts the read-retry process at an already close-to-optimal starting read reference voltage that is estimated and recorded daily and upon power-on, 2) it approaches OPT in a known, informed direction from this starting read reference voltage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Minimizing the Error Correction Latency</head><p>We next analyze the error correction latency of a flash read operation. We use Bose, Chaudhuri, and Hocquenghem (BCH) codes as an example to show that reducing the raw bit error rate can actually reduce the overall flash read latency. This conclusion further motivates the use of our ROR technique, introduced in Sec. 4.2, which reduces RBER.</p><p>BCH codes are widely used in today's flash controllers to detect and correct multi-bit errors <ref type="bibr" target="#b27">[28]</ref> <ref type="bibr" target="#b28">[29]</ref>. Out of n total bits in a code word, the first k bits are data bits, and the remaining (n-k) bits are the error correction information to protect the data bits. To extract the data bits from flash memory, the flash controller sends the entire code word to a BCH decoder. The BCH decoder can identify all the erroneous bits and flip them to correct the errors. Fig. <ref type="figure" target="#fig_9">11</ref> illustrates the three steps of a BCH decoder, which we explain briefly in turn. Step 1 -Syndrome calculation. First, to find out whether the code word, R(x), contains any error, the BCH decoder computes the syndrome vector, S(x), which indicates if and how many of the rules enforced by the BCH code are violated. The i-th syndrome, Si, is set to 1 if rule i is violated, and to 0 otherwise. To calculate S(x), this step uses a parity check matrix H to encode the BCH code rules, and multiplies the code word with this matrix (i.e., S(x) = R(x)×H). If all the syndromes of a code word is zero, the code word is declared to be error-free. Otherwise, the decoder proceeds to the next steps to correct the errors.</p><p>Step 2 -Berlekamp-Massey algorithm. We use the Berlekamp-Massey algorithm <ref type="bibr">[30][31]</ref> to construct an error location polynomial, σ(x), whose roots encode the error locations of the code word:</p><formula xml:id="formula_6">e e x x x x             ... 1 ) (</formula><p>tion of e = 0 (i.e., σ(x) = 1). Then, it iteratively updates σ(x) by adding correction terms until σ(x) successfully encodes all error locations of the code word. In each iteration, a correction term is calculated from both the syndromes calculated in Step 1 and σ(x) from previous iterations (only when σ(x) satisfies certain conditions). This algorithm successfully finds σ(x) after n = (E+e) / 2 iterations, where E is the maximum number of errors correctable by the BCH code.</p><p>Note that 1) the highest order of the polynomial, e, is proportional to the number of errors in the code word, 2) the number of iterations, n, is also proportional to the number of errors, 3) each iteration is compute-intensive as it involves several multiply and add operations, and 4) this algorithm cannot be parallelized across iterations as the computation in each iteration is dependent on the previous ones.</p><p>Step 3 -Chien search. The Chien search algorithm uses the error location polynomial to find all the raw bit errors in the code word. Each erroneous bit location is encoded with a known function f <ref type="bibr" target="#b30">[31]</ref>. As an example, if the i-th bit is erroneous, the error location polynomial σ(f(i)) = 0, otherwise σ(f(i)) ≠ 0. Since i is bounded by the code word length, the Chien search algorithm simply uses trial-and-error (i.e., tests if σ(f(i)) is zero) from the first bit to the last until it finds all of the error bits. Finally, the identified raw bit errors are corrected by simply flipping the erroneous bits.</p><p>Note that 1) the computation of σ(f(i)) is also computeintensive, but can be parallelized since the computation for each bit is independent, and 2) the complexity of Step 3 is correlated with the number of errors in the code word.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ECC latency analysis.</head><p>Based on what we described above, the BCH decoder latency can be modeled as:</p><formula xml:id="formula_7">Chien Berlekamp syndrome dec BCH T m k T N T T      ) / ( (6)</formula><p>In Eqn. 6, TSyndrome is the latency for calculating the syndrome, which is determined by the size of the parity check matrix H; TBerlekamp is the latency for one iteration of the Berlekamp-Massey algorithm; N is the total number of iterations that the Berlekamp-Massey algorithm requires; TChien is the latency for deciding whether or not one bit location is erroneous during Chien search; k is the data bit length; and m is the number of bits that are processed in parallel in <ref type="bibr">Step 3.</ref> In this equation, TSyndrome, TBerlekamp, k, and m are constants given a certain BCH decoder, while N and TChien are proportional to the raw bit error count of the data. <ref type="foot" target="#foot_5">5</ref> We conclude that the latency of the BCH decoder increases linearly with the raw bit error count in the data.</p><p>Recall from Sec. 4.2 that the ROR technique reduces raw bit error rate. As a result, it also reduces the BCH decoding latency. Furthermore, since error correction latency is an important part of flash read latency (Sec. 4.1), ROR also reduces the overall flash read latency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Evaluation</head><p>We show the benefits of the ROR technique, compared to a conventional design that uses a fixed read reference voltage, in terms of P/E-cycle lifetime improvement and read latency reduction. Note that ROR can be applied either alone or together with flash refresh techniques <ref type="bibr">[3][4]</ref>.</p><p>Methodology.</p><p>We model a 512 GB flash-based SSD (composed of sixteen 256 Gbit flash memory chips) with an 8 KB page size, 256-page block size, and 100 μs read latency. We model a flash controller with a BCH decoder that can correct 40 bit errors for every 1 KB of data <ref type="bibr" target="#b10">[11]</ref> (i.e., it can tolerate an RBER of 10 -3 during the flash lifetime). We assume that the BCH decoder is designed with balanced latencies in each stage. In other words, Stages 1-3 have equal latency when the maximum number of errors (i.e., 40 bit errors per 1 KB of data) is corrected.</p><p>We use a combination of 1) experimental characterization of real flash chips, and 2) SSD simulations with real application traces to support our observations. We assume that all data is refreshed every 7 days <ref type="bibr" target="#b2">[3]</ref>, so the retention age never exceeds 7 days. We run 14 traces from FIU <ref type="bibr" target="#b32">[33]</ref> and MSR-Cambridge <ref type="bibr" target="#b33">[34]</ref> for 7 days using DiskSim 4.0 <ref type="bibr" target="#b34">[35]</ref> with SSD extensions <ref type="bibr" target="#b35">[36]</ref> to simulate the performance of our proposed ROR technique with a 7-day refresh period. We evaluate three configurations: baseline (the conventional read technique), naive read-retry (Sec. 4.1), and ROR (our proposed technique).</p><p>P/E-cycle lifetime. We use the RBER curve in Fig. <ref type="figure">7</ref> to estimate P/E-cycle lifetime. Baseline uses a traditional read technique that applies a fixed read reference voltage and thus cannot guarantee an ECC-correctable RBER in Stage-1. In contrast, naive read-retry and ROR apply an adaptive read reference voltage and are thus still functional in Stage-1. As such, both naive read-retry and ROR, with 25.5k P/E-cycle lifetimes, provide a 64% flash lifetime improvement over baseline, with a 15.5k P/E-cycle lifetime.</p><p>Performance during the nominal lifetime (i.e., Stage-0 in Fig. <ref type="figure">7</ref>). We use the latency model presented in Eqn. 6 to estimate ECC decoding latency. Fig. <ref type="figure" target="#fig_10">12</ref> shows the ECC decoding latency reduction for ROR over baseline. On average, ROR reduces the ECC decoding latency by 10.1%. As we have discussed in Sec. 4.3, BCH decoding latency reduces linearly with the raw bit error count in the data. In Stage-0, all the errors are correctable by ECC when any read reference voltage is applied (i.e., no read-retries are needed). However, by finding and applying OPT, ROR can reduce RBER significantly (Fig. <ref type="figure" target="#fig_4">6</ref>). Thus, the number of raw bit errors corrected by the BCH decoder reduces, and so does the ECC decoding latency (see Eqn. 6).</p><p>Assuming that ECC decoding latency takes ~24% of the overall flash read latency,<ref type="foot" target="#foot_6">6</ref> the 10.1% average reduction in ECC decoding latency is equivalent to a 2.4% overall flash read latency reduction. Note that this fraction (and thus the overall latency reduction) may increase as flash page size in-creases in the future. While a 2.4% overall flash read latency reduction may sound small, it is a real latency reduction on the critical path of a flash memory read operation.</p><p>Performance during extended lifetime (i.e., Stage-1 in Fig. <ref type="figure">7</ref>). We use the latency model presented in Eqn. 4 to estimate the latency reduction of ROR over naive read-retry. Fig. <ref type="figure" target="#fig_11">13</ref> shows the reduction in read-retry count with ROR over naive read-retry. ROR is able to reduce the average number of read-retries, and therefore the overall read latency, by 70.4%. This performance improvement is mainly due to ROR's reduction of the read-retry count over naive read-retry. In Stage-1, only naive read-retry and ROR can successfully read the data, albeit with potentially increased read latency due to extra read-retries. Compared to naive read-retry, which always uses a fixed starting read reference voltage across all blocks and regardless of retention age, ROR periodically finds a close-to-optimal read reference voltage for each block taking into account its retention age, and thus requires fewer readretries.</p><p>Performance overhead. We model the latency to perform the pre-optimization algorithm with the following formula:</p><formula xml:id="formula_8">y ReadLatenc AvgRetry ock PagesPerBl PageSize β y SSDCapacit α      (<label>7</label></formula><formula xml:id="formula_9">)</formula><p>where α is the fraction of the occupied capacity in the SSD; β is the number of flash read operations the SSD can perform in parallel; and AvgRetry is the average read-retry count throughout the pre-optimization process. Recall from Eqn. 5 that, during power-on, read-retry count correlates with the difference between the previously-recorded starting read reference voltage (obtained before the SSD is powered off) and the newly-found starting read reference voltage. Also recall from Sec.</p><p>3 that this difference correlates with the elapsed retention age. According to our characterization results in Sec. 3, the average ready-retry count is respectively 2, 10, and 15 for flash memory at 8k P/E cycles with 1-day, 7-day, and 30-dayequivalent retention age. Plugging this into Eqn. 7 and considering the worst-case scenario (flash capacity is full, i.e., α is 1, which is pessimistic in most real systems), we obtain an estimated pre-optimization latency of respectively 3, 15, and 23 seconds for flash memory with 1-day, 7-day, and 30-dayequivalent retention age.</p><p>Once the power-on process is completed, the starting read reference voltage for each block will be close to the optimal read reference voltage. Then, the pre-optimization algorithm is triggered daily to ensure the starting read reference voltages to catch up with the shifting of the threshold voltage distribution due to flash retention. As such, the flash controller can minimize read-retry count by reusing the previously-recorded read reference voltages. In this case, the latency for the preoptimization algorithm is as low as 3 seconds, which can be largely hidden by executing the algorithm only when the SSD is idle or in the background at a lower priority.</p><p>Storage Overhead. We store the starting read reference voltages learned by ROR at a flash block granularity, leveraging our Observations 3 and 4 (Sec. 4.1). This greatly reduces the overhead compared to the alternative of recording the voltage at a page granularity. As a result, for our evaluated NAND flash device, the total storage overhead is 768 KB. 7  This allows the flash controller to manage the ROR read reference voltage table completely within its DRAM buffer.</p><p>Summary. We conclude that our ROR technique is able to improve the P/E-cycle lifetime as well as the read performance of flash memory with only moderate latency overhead during the pre-optimization process and modest storage and logic overheads in the SSD controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Retention Failure Recovery (RFR)</head><p>In this section, we introduce another technique, Retention Failure Recovery (RFR), that allows us to recover data from flash memory offline after an ECC-uncorrectable retention failure happens (i.e., when the flash controller fails to read some data due to the inability to correct retention errors). We show in Sec. 5.1, that data loss, resulting from retention failure under various circumstances, can happen. In Sec. 5.2, we study the charge-leakage property of a flash memory cell, and describe a technique to classify fast-and slow-leaking cells. This classification method enables the RFR technique, which we describe in Sec. 5.3, to recover an otherwise-uncorrectable retention error. In Sec. 5.4, we evaluate the raw bit error rate reduction benefit of the RFR technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Motivation for Offline Retention Error Recovery</head><p>The RFR technique is motivated by two major shortcomings of previously proposed flash refresh techniques <ref type="bibr" target="#b2">[3]</ref>[4] <ref type="bibr" target="#b12">[13]</ref> <ref type="bibr" target="#b13">[14]</ref>. First, these refresh techniques require the system to be consistently powered on; otherwise, uncorrectable errors may occur, resulting in data loss. Some use cases of flash memory, such as those in removable media and mobile devices, do not satisfy this requirement as these devices are not always powered-on. Even some always-on use cases of flash memory, such as those in some enterprise environments, may not always satisfy this requirement, as they may not always have an uninterrupted power supply to keep the SSDs powered-on with zero downtime.</p><p>Second, the refresh period needs to be maintained conservatively (i.e., in a way that guarantees error correction with a certain margin) by the flash controller to avoid unexpected data loss. However, this is difficult to guarantee in cases where temperature of flash memory increases very quickly. Increased temperature exponentially increases retention loss due to increased leakage and therefore increases the effective retention age of a flash memory block (i.e., the equivalent retention age 7 We store one byte per block for each starting read reference voltage learned for the erased-P1 OPT, the P1-P2 OPT, and the P2-P3 OPT, which together consume a storage overhead of 3 B * 2 18 blocks = 768 KB. Note that it is possible to further reduce this overhead by grouping flash blocks with similar retention ages and storing a single set of read reference voltages for them or by storing only those read reference voltages that cause the most retention errors (e.g., leveraging the observation in Finding 5 that retention loss may affect the P2-P3 OPT much more significantly).</p><p>of the block under room temperature <ref type="foot" target="#foot_7">8</ref> ). This phenomenon can be modeled by Arrhenius Law <ref type="bibr" target="#b22">[23]</ref>:</p><formula xml:id="formula_10">  ) / 1 / 1 ( ) / ( exp / 2 1 2 1 T T k E t t AF a    <label>(8)</label></formula><p>In Eqn. 8, AF is the aging factor, which is defined as the ratio between the effective retention age t1 under temperature T1 and the effective retention age t2 under temperature T2; Ea is the activation energy, which is a process-dependent constant, and k is the Boltzmann constant.</p><p>As an illustrative example, Table <ref type="table" target="#tab_0">I</ref> shows the retention age in hours at high temperature (70°C) to achieve a {30, 60, 90, 180, 360, 1080}-day-equivalent retention age at room temperature (20°C). Note that flash memory can achieve a 30-dayequivalent retention age in only 2.6 hours at 70°C. Table <ref type="table" target="#tab_0">II</ref> shows the AF values for various high temperatures when T1 is set to 20°C. Note that AF increases exponentially with temperature (as a direct result of the fact that retention loss increases exponentially with temperature). Case study. Next, we use two case studies to show that retention failures are unavoidable. First, when a mobile device is exposed under sunlight (e.g., because it is left in the front of a car on a sunny day), the temperature can be elevated to as high as 70°C. If the required refresh period of the flash memory is 1 week at room temperature, uncorrectable errors may start to accumulate after a mere 36 minutes (i.e., 1 week / 275.8, the AF for 70°C). Second, today's flash devices, which do not require flash refresh, have a typical retention age of 1 year at room temperature. For such a device, uncorrectable errors may start to accumulate after the flash device experiences 70°C for a total of only 32 hours (i.e., 1 year / 275.8) within a year.</p><p>Note that it is unrealistic to log the environmental temperature and estimate the effective retention age accurately to avoid a retention failure, as the environment temperature may change sporadically and rapidly. To avoid data loss resulting from retention failure (due to either a failure of timely refresh or unexpected exposure to high temperature), we propose an offline technique, RFR, to reduce RBER and increase the chances of successful recovery of data after a retention failure happens.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Fast-and Slow-Leaking Cells</head><p>In this subsection, we identify the existence of fastand slow-leaking cells, which we exploit to enable the RFR technique.</p><p>At low retention age, the threshold voltage distributions of two neighboring states are far away from each other (Sec. 3.2). Hence, the data is likely to be read with a low and correctable error rate as long as a close-to-optimal read reference voltage is applied (Sec. <ref type="bibr">3.4)</ref>. However, at a high retention age, the neighboring threshold voltage distributions become flatter and closer to each other (Sec. 3.2), and thus retention error count increases and a retention failure can appear. Also, recall from Finding 3 that the threshold voltage distribution shifts faster in highervoltage states, such as P2 and P3. As a result, retention errors are more likely to happen in cells that are between the P2 and P3 states (i.e., in MSB pages). We use the P2 and P3 states as an example to illustrate our new findings.</p><p>To quantitatively show how the threshold voltage distributions of the P2 and P3 states change over retention age, we first record a trace of how the threshold voltage of each cell in the two different states shifts over 40 days. Next, we divide each of the two threshold voltage distributions into eight regions in terms of the corresponding standard deviations of each distribution (as illustrated in Fig. <ref type="figure" target="#fig_12">14a</ref>), and classify each cell into these regions based on its threshold voltage after 28 days. We plot the average magnitude of the threshold voltage shift in each region over retention age, separately for the P2 and P3 states in Fig. <ref type="figure" target="#fig_12">14(b</ref>) and Fig. <ref type="figure" target="#fig_12">14(c)</ref>.</p><p>Although the flash cells are programmed with similar threshold voltages initially, after 28 days' worth of retention loss, the cells that leak charge faster are more likely to have lower threshold voltages than the mean, and the opposite happens to slow-leaking cells. This difference is a result of process variation, where different cells on the same chip can have different characteristics such as charge leakage speed. We classify the cells with lower threshold voltages than the mean as fastleaking cells, and the cells with higher threshold voltages than the mean as slow-leaking cells.<ref type="foot" target="#foot_8">9</ref>  As we can see in Fig. <ref type="figure" target="#fig_12">14 (a</ref>) and (b), the average threshold voltage of fast-leaking cells decreases by 0.3 ΔV/day (i.e., stepsizes/day) and 2 ΔV/day for the P2 and P3 states. In contrast, the average threshold voltage of slow-leaking cells remains almost unchanged in either the P2 or P3 state. Retention errors are caused by the cells that fall into the regions where the two distributions overlap (i.e., fast-leaking cells programmed to the P3 state and slow-leaking cells programmed to the P2 state). We will show later that, by identifying the difference in the rate of reduction of the threshold voltages between these cells, we can guess the original state of a cell with a high enough success rate to recover the data from retention failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Retention Failure Recovery Mechanism</head><p>As we discussed in Sec. 5.1, retention failures can be unavoidable under some conditions and use cases. As a result, the flash controller will fail to read the failed cells correctly even with the optimal read reference voltage (found by ROR). In order to recover the failed data, we propose Retention Failure Recovery (RFR), an offline technique. RFR identifies fast-vs. slow-leaking cells and uses selective bit flipping to correct retention failures and thus reduce RBER. With reduced raw bit errors, the read data may be reconstructed by ECC with a higher probability. RFR consists of the following 4 offline steps, which are triggered when an uncorrectable error is found:</p><p>Step 1 -Identify data with a retention failure. We can identify such data with any flash controller that uses the proposed ROR technique. The flash controller first attempts to read as much data as it can. It backs up all data, including those successfully read, in another disk drive to prevent additional data loss during the recovery process. It records the physical page numbers of the data that failed error correction, and ensures that the voltage values remain unchanged in the failed pages to allow further investigation.</p><p>Step 2 -Identify risky cells using three read operations. Next, we identify risky cells, i.e., cells with potential errors due to retention loss, for further investigation. We perform the following four sub-steps to achieve this goal: 2.1) read data with (OPT -δ), where δ is configurable and is set to the standard deviation (σ) of the P3 threshold voltage distribution in our experiments, 2.2) read data with OPT, 2.3) read data with (OPT + δ), 2.4) record the threshold voltage of each cell by sweeping the read reference voltage.</p><p>As shown in Fig. <ref type="figure" target="#fig_13">15a</ref>, the values read from the first 3 substeps can be recorded as an ordered set (or sequence), (a,b,c), each bit of which is a binary value representing whether or not the threshold voltage of the cell is greater than the read reference voltage of the corresponding sub-step (i.e., 2.1, 2.2, 2.3 respectively). A sequence as a whole represents the threshold voltage region into which a cell falls. Only 4 value sequences are valid for the ordered set: {(0,0,0), (1,0,0), (1,1,0), (1,1,1)}, corresponding to the voltage regions: {Vth &lt; Vopt -δ, Vopt -δ &lt; Vth &lt; Vopt, Vopt &lt; Vth &lt; Vopt + δ, Vopt + δ &lt; Vth}. <ref type="foot" target="#foot_9">10</ref>We identify each cell with a sequence (1,0,0) or (1,1,0) as a risky cell. Recall from Sec. 5.2 that such cells fall into the overlapping region of the two threshold voltage distributions (as illustrated in Fig <ref type="figure" target="#fig_13">15b</ref>) and hence consist of a mixture of cells that are misread and correctly read. According to the classification method in Sec. 5.2, we further classify risky cells into 4 types: type ① (slow-leaking cells of the P2 state correctly read as being in the P2 state), type ② (slow-leaking cells of the P2 state misread as being in the P3 state), type ③ (fast-leaking cells of the P3 state misread as being in the P2 state), and type ④ (fast-leaking cells of the P3 state correctly read as being in the P3 state). Type ① and type ③ cells have the sequence (1,0,0), and type ② and type ④ cells have the sequence (1,1,0) after the three read operations. Note that, after this step, we still cannot identify the misread cells (type ② and type ③). Step 3 -Identify fast-and slow-leaking cells. To determine the exact type of each cell, we next identify fast-vs. slow-leaking cells. To this end, we perform the following two sub-steps: 3.1) introduce additional retention loss to the cells (note that one can accelerate this process by heating up the failed flash chip), and 3.2) record the threshold voltage of each cell. By calculating the magnitude of the threshold voltage shift after additional retention loss using the two recorded threshold voltages in Steps 2.4 and 3.2, we further classify risky cells into fast-and slow-leaking cells using the technique described in Sec. 5.2 (i.e., we predict a cell with a lower threshold voltage shift than the mean voltage shift as a fast-leaking cell, and a cell with a higher threshold voltage shift than the mean voltage shift as a slow-leaking cell).</p><p>Recall from Step 2 that type ② cells are slow-leaking cells with the sequence (1,1,0) and type ③ cells are fast-leaking cells with the sequence (1,0,0), as shown in Fig. <ref type="figure" target="#fig_13">15(c</ref>). As such, we have successfully identified type ② and type ③ cells, which are the risky cells that are likely misread.</p><p>Step 4 -Selective bit flipping.</p><p>To correct the likelymisread bits, we simply take the raw data (backed up in Step 1) and selectively flip the bits that are stored in type ② and type ③ cells to correct these likely errors. Note that although the identified errors may not necessarily be the actual error bits (due to factors such as misidentification of risky cells and misclassification of fast-and slow-leaking cells, as discussed in Footnotes 9 and 10), we are still able to significantly reduce the number of raw retention errors, and thus successfully recover considerable data with ECC, as we show in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Evaluation</head><p>We evaluate RFR on data programmed to random values that has 28-day equivalent retention age. In Step 3.1, we introduce an additional 12 days' worth of equivalent retention age. Fig. <ref type="figure" target="#fig_14">16</ref> shows the resulting raw bit error rate of RFR over a range of P/E cycles (compared to that of the baseline). This figure shows that RFR reduces RBER by 50%, averaged across all P/E cycles. Thus, we expect the number of raw bit errors to be halved, increasing the chances that these errors are correctable by ECC. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>This paper, to our knowledge, is the first one that experimentally characterizes and comprehensively analyzes how the threshold voltage distribution changes over different retention ages, as well as the implication of these changes on read reference voltages and P/E-cycle lifetime, for state-of-theart 2y-nm MLC NAND flash memories. <ref type="foot" target="#foot_10">11</ref> Prior works <ref type="bibr" target="#b1">[2]</ref>[5] characterize NAND flash data retention, but only in terms of RBER. Papandreou et al. <ref type="bibr" target="#b5">[6]</ref> characterize the retention effect on threshold voltage distributions under high temperature baking, but this method may not accurately represent how flash memories are typically used (as we discussed in Sec. 3.1).</p><p>Prior works <ref type="bibr" target="#b2">[3]</ref>[4] <ref type="bibr">[13][14]</ref> propose to use periodic refresh to mitigate retention errors. However, these techniques 1) require the system to be consistently powered on, and 2) are unaware of the fact that the optimal read reference voltage changes with different retention age. Note that these works always apply a fixed read reference voltage regardless of the retention age of the cell, which is suboptimal for reading flash blocks at different retention ages (as we showed in Sec. 3.4). In contrast, our ROR technique optimizes the read reference voltage of each flash block based on its retention age, leading to significant lifetime improvements.</p><p>A few works <ref type="bibr" target="#b5">[6]</ref>[7] <ref type="bibr" target="#b7">[8]</ref> proposed optimizing the read reference voltage. <ref type="bibr" target="#b7">[8]</ref> provides a technique to calculate the optimal read reference voltage from the mean and variance of the threshold voltage distributions, which are characterized by the read-retry technique <ref type="bibr" target="#b8">[9]</ref>. The cost of such a technique is relatively high, as it requires periodically reading flash memory with all possible read reference voltages to discover the threshold voltage distributions. Papandreou et al. propose to apply a per-block close-to-optimal read reference voltage by periodically sampling and averaging 6 read reference voltages within each block <ref type="bibr" target="#b5">[6]</ref>. In contrast, ROR can find the optimal read reference voltage at a much lower cost, thanks to the new findings and observations in this paper.</p><p>No previous mechanism (e.g., <ref type="bibr">[3][4]</ref>[6][13] <ref type="bibr" target="#b13">[14]</ref>) can recover the data from an uncorrectable error that is beyond the error correction capability of ECC. However, we observe that such uncorrectable errors can happen quickly under unexpected high temperature, as the effective retention age can easily become longer than the refresh period or the assumed retention target. Our RFR mechanism is the first to provide error recovery capability from retention errors uncorrectable by ECC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We comprehensively characterized and analyzed how the threshold voltage distribution and the optimal read reference voltages of state-of-the-art 2y-nm MLC NAND flash memory change over different retention ages. Based on these analyses, we proposed two new techniques. Retention Optimized Reading (ROR) improves reliability, lifetime, and performance of MLC NAND flash memory at modest storage cost by optimizing the read reference voltage of each flash memory block based on its retention age. We demonstrate significant benefits with ROR in terms of reduced RBER, extended flash lifetime, and reduction in flash read latency. Retention Failure Recovery (RFR) recovers data with uncorrectable errors by identifying and probabilistically correcting flash cells with retention errors. We demonstrated large raw bit error rate reductions with RFR.</p><p>We hope that our new, comprehensive characterization of data retention in flash memory will enable better understanding of flash retention errors and motivate other new techniques to overcome these errors. We believe the importance of our two new techniques (ROR and RFR) will grow as NAND flash memory scales to smaller feature sizes and becomes even less reliable in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (a) Cross-sectional view of a flash cell, (b) retention loss mechanisms.</figDesc><graphic coords="2,45.35,557.40,252.00,89.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Threshold voltage distribution of 2y-nm MLC NAND flash memory vs. retention age, at 8k P/E cycles under room temperature.</figDesc><graphic coords="3,315.00,358.50,252.00,105.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .Fig. 4 .</head><label>34</label><figDesc>Fig. 3. Mean of threshold voltage distribution for P1, P2, and P3 states of 2ynm MLC NAND flash memory, at 8k P/E cycles under room temperature.</figDesc><graphic coords="3,315.00,496.65,252.00,113.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Effect of retention age on the optimal read reference voltage between (a) the P1 and P2 states, and (b) the P2 and P3 states.</figDesc><graphic coords="4,315.00,424.05,252.00,117.25" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Normalized RBER when reading 28-day-old data with different optimal read reference voltages (normalized to 28-day OPT).</figDesc><graphic coords="5,45.35,358.80,252.00,65.15" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Read-retry steps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 9 .Observation 4 :</head><label>94</label><figDesc>Fig. 9. Retention age distribution across all pages after 7 days of operation.Observation 4: The optimal read reference voltage of pages in a block is upper-bounded by the optimal read reference voltage of the last-programmed page.Within a page, the data in a flash block is programmed in page order (i.e., sequentially from page 0 to page 255, assuming 256 pages per block) to minimize inter-page program interference<ref type="bibr" target="#b6">[7]</ref>. Therefore, according to Finding 4, the optimal read reference voltage for page 255 is no less than that of any other page within the same block (because page 255 is programmed last and thus has the largest retention age). Hence, if we record the optimal read reference voltage of the last-programmed page (page 255), we can get the upper bound of the optimal read reference voltages of all pages in a given block.3   </figDesc><graphic coords="7,45.70,54.00,252.00,82.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>3</head><label>3</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Voltage learning with default read reference voltage (a) higher than OPT, and (b) lower than OPT.</figDesc><graphic coords="7,315.00,305.25,252.00,61.45" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Error correction flow of BCH codes.</figDesc><graphic coords="8,45.70,380.45,252.00,70.00" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. ECC decoding latency reduction of ROR over baseline.</figDesc><graphic coords="9,45.35,447.25,252.00,71.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Read-retry count reduction of ROR over naive read-retry.</figDesc><graphic coords="9,315.00,152.40,252.00,71.20" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. (a) Threshold voltage distributions of the P2 and P3 states partitioned into 8 regions, (b) P2 state threshold voltage shift, and (c) P3 state threshold voltage shift over retention age, based on the classification of the threshold voltage after 28 days' worth of retention loss.</figDesc><graphic coords="11,45.70,359.85,252.00,154.35" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. (a) Classification of the cells to identify misread bits, (b) cells before additional retention loss, and (c) cells after additional retention loss.</figDesc><graphic coords="12,45.70,108.60,252.00,131.30" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Effect of the RFR technique on raw bit error rate.</figDesc><graphic coords="12,315.00,53.65,252.00,96.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell></cell><cell>.</cell><cell cols="5">EFFECTIVE RETENTION AGE COMPARISON</cell></row><row><cell cols="2">20°C (Days)</cell><cell>30</cell><cell>60</cell><cell>90</cell><cell>180</cell><cell>360</cell><cell>1080</cell></row><row><cell cols="2">70°C (Hours)</cell><cell>2.6</cell><cell>5.2</cell><cell>7.8</cell><cell>15.7</cell><cell>31.3</cell><cell>94.0</cell></row><row><cell cols="2">TABLE II.</cell><cell cols="6">AF UNDER HIGH TEMPERATURE WHEN T1 = 20°C</cell></row><row><cell>T2</cell><cell>50°C</cell><cell>60°C</cell><cell></cell><cell>66°C</cell><cell>70°C</cell><cell>80°C</cell><cell>90°C</cell></row><row><cell>AF</cell><cell>27.5</cell><cell>90.2</cell><cell></cell><cell>177.8</cell><cell>275.8</cell><cell>791.6</cell><cell>2143.6</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>978-1-4799-8930-0/15/$31.00 ©2015 IEEE</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>We use random (or pseudo-random) data because data encryption and randomization mechanisms used in today's flash controllers lead to randomized data to be programed into raw flash chips<ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2"><p><ref type="bibr" target="#b1">2</ref> Dwell time is the time duration between an erase operation and the following program operation to the same flash cell.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3"><p>Note that even if a page is read in the future after it is programmed, its optimal read reference voltage will decrease over time until it is read and thus will never exceed this upper bound.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_4"><p> 2  1    where e is the number of raw bit errors in the code word. The polynomial is constructed via an iterative process.<ref type="bibr" target="#b3">4</ref> Since e is not known a priori, the algorithm starts from the initial assump-<ref type="bibr" target="#b3">4</ref> We refer the reader to<ref type="bibr" target="#b10">[11]</ref>[30]<ref type="bibr" target="#b30">[31]</ref> for a more detailed explanation of the Berlekamp-Massey algorithm.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5"><p>Previous works<ref type="bibr" target="#b27">[28]</ref>[29]<ref type="bibr" target="#b31">[32]</ref> implement the Berlekamp-Massey algorithm and the Chien search in a hardware BCH decoder. Their results are in line with the conclusions of our latency model.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>We estimate the ECC decoding latency for a conventional BCH decoder as (4 μs/8 Kbit) × 8 KB = 32 μs<ref type="bibr" target="#b27">[28]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>The flash controller cannot adapt to such temperature changes if it uses a fixed read reference voltage (regardless of temperature) or if ROR or any other read reference voltage learning technique<ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref> is not performed frequently enough to capture such temperature emergencies.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Note that this classification may not be absolutely accurate, as the threshold voltage difference between cells due to leakage-speed variation may not dominate other factors as initial program variations. However, as we will show in Sec. 5.3 and Sec. 5.4, this classification method works for our purposes as long as it can correctly classify a majority of fast-and slowleaking cells and thereby lead to reduction in RBER using the RFR technique.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Other value sequences are possible due to circuit fluctuations, but we consider them to be invalid as they happen infrequently. We can either classify such sequences as the closest valid sequence using Manhattan distance, or repeat Step 2 until a valid sequence is found.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_10"><p>Even though recent works have investigated the retention characteristics of modern DRAM devices<ref type="bibr" target="#b36">[37]</ref>[38]<ref type="bibr" target="#b38">[39]</ref> and proposed optimizations to take advantage of these characteristics<ref type="bibr" target="#b36">[37]</ref>[38]<ref type="bibr" target="#b39">[40]</ref>[41]<ref type="bibr" target="#b41">[42]</ref>, retention characteristics of flash memory have not been studied in detail in previous works, and optimizations based on such characteristics have been even less common.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Saugata Ghose and Nandita Vijaykumar from the SAFARI Research Group and the anonymous reviewers for feedback. This work is partially supported by the Intel Science and Technology Center, CMU Data Storage Systems Center, and NSF grants 1212962 and 1320531.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Error Analysis and Management for MLC NAND Flash Memory</title>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">FMS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Error Patterns in MLC NAND Flash Memory: Measurement, Characterization and Analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>DATE</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Flash Correct-and-Refresh: Retention-Aware Error Management for Increased Flash Memory Lifetime</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICCD</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Error Analysis and Retention-Aware Error Management for NAND Flash Memory</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intel Technology Journal</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Bit Error Rate in NAND Flash Memories</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mielke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRPS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Using Adaptive Read Voltage Thresholds to Enhance the Reliability of MLC NAND Flash Memory Systems</title>
		<author>
			<persName><forename type="first">N</forename><surname>Papandreou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">GLSVLSI</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Interference in MLC NAND Flash Memory: Characterization, Modeling, and Mitigation</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Neighbor-cell Assisted Error Correction for MLC NAND Flash Memory</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMETRICS</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<title level="m">Threshold Voltage Distribution in MLC NAND Flash Memory: Characterization, Analysis, and Modeling</title>
		<meeting><address><addrLine>DATE</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Error Detecting and Error Correcting Codes</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">W</forename><surname>Hamming</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1950">1950</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Error Control Coding</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">J</forename><surname>Costello</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">95%-Lower-BER 43%-Lower-Power Intelligent Solid-State Drive (SSD) with Asymmetric Coding and Stripe Pattern Elimination Algorithm</title>
		<author>
			<persName><forename type="first">S</forename><surname>Tanakamaru</surname></persName>
		</author>
		<idno>ISSCC 2011</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Optimizing NAND Flash-Based SSD via Retention Relaxation</title>
		<author>
			<persName><forename type="first">R.-S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Quasi-Nonvolatile SSD: Trading Flash Memory Nonvolatility to Improve Storage System Performance for Enterprise Applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Pan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">HPCA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gill</surname></persName>
		</author>
		<title level="m">Nonvolatile Memory Technologies with Emphasis on Flash: A Comprehensive Guide to Understanding and Using NVM Devices</title>
		<imprint>
			<publisher>WILEY Press</publisher>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Electron Emission in Intense Electric Fields</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">H</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Nordheim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the Royal Society A</title>
		<imprint>
			<biblScope unit="volume">119</biblScope>
			<biblScope unit="issue">781</biblScope>
			<biblScope unit="page" from="173" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Stress Induced Leakage Current Limiting to Scale down EEPROM Tunnel Oxide Thickness</title>
		<author>
			<persName><forename type="first">K</forename><surname>Naruke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Taguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEDM</title>
		<imprint>
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Analytical Percolation Model for Predicting Anomalous Charge Loss in Flash Memories</title>
		<author>
			<persName><forename type="first">R</forename><surname>Degraeve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Electronic Devices</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Degradation of Tunnel Oxide by FN Current Stress and its Effects on Data Retention Characteristics of 90-nm NAND Flash Memory</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRPS</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Analysis of Detrap Current due to Oxide Traps to Improve Flash Memory Retention</title>
		<author>
			<persName><forename type="first">R</forename><surname>Yamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRPS</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Flash EEPROM Threshold Instabilities due to Charge Trapping during Program/Erase Cycling</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mielke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Device and Material Reliability</title>
		<imprint>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">FPGA-Based Solid-State Drive Prototyping Platform</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FCCM 2011</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Characteristics &amp; Reliability of 100A Oxides</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Baglee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reliability Physics Symposium</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Analysis of Failure Mechanisms and Extraction of Activation Energies (Ea) in 21-nm NAND Flash Cells</title>
		<author>
			<persName><forename type="first">K</forename><surname>Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Data Randomization Scheme for Endurance Enhancement and Interference Mitigation of Multilevel Flash Memory Devices</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ETRI Journal</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A 21 nm High Performance 64 Gb MLC NAND Flash Memory with 400 MB/s Asynchronous Toggle DDR Interface</title>
		<author>
			<persName><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JSSC</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Failure Mechanisms and Models for Semiconductor Devices</title>
	</analytic>
	<monogr>
		<title level="j">JEDEC Publication JEP</title>
		<imprint>
			<biblScope unit="page" from="122" to="2003" />
		</imprint>
	</monogr>
	<note>JEDEC Solid State Technology Association</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Gb/s Multi-Threaded BCH Encoder and Decoder for Multi-Channel SSD Controllers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<idno>ISSCC 2012</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A 4Gb 2b/cell NAND Flash Memory with Embedded 5b BCH ECC for 36MB/s System Read Throughput</title>
		<author>
			<persName><forename type="first">R</forename><surname>Micheloni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ravasio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Marelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISSCC</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">High-Speed Decoding of BCH codes</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lin</surname></persName>
		</author>
		<title level="m">Channel Codes: Classical and Modern</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The Area and Latency Tradeoffs of Binary Bit-Parallel BCH Decoders for Prospective Nanoelectronic Memories</title>
		<author>
			<persName><forename type="first">D</forename><surname>Strukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACSSC</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">I/O Deduplication: Utilizing Content Similarity to Improve I/O Performance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rangaswami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOS</title>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Write Off-Loading: Practical Power Management for Enterprise Storage</title>
		<author>
			<persName><forename type="first">D</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TOS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The DiskSim Simulation Environment Version 4.0 Reference Manual</title>
		<author>
			<persName><forename type="first">J</forename><surname>Bucy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Design Tradeoffs for SSD Performance</title>
		<author>
			<persName><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">An Experimental Study of Data Retention Behavior in Modern DRAM Devices: Implications for Retention Time Profiling Mechanisms</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<idno>ISCA 2013</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<author>
			<persName><forename type="first">S</forename><surname>Khan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Efficacy of Error Mitigation Techniques for DRAM Retention Failures: A Comparative Experimental Study</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A New Investigation of Data Retention Time in Truly Nanoscaled DRAMs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EDL</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">8</biblScope>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">RAIDR: Retention-Aware Intelligent DRAM Refresh</title>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISCA</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Retention-Aware Placement in DRAM (RAPID): Software Methods for Quasi-Non-Volatile DRAM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Memory Scaling: A Systems Architecture Perspective</title>
		<author>
			<persName><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MEMCON</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
