<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">AVATAR: The Architecture for First-Order Theorem Provers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrei</forename><surname>Voronkov</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Manchester</orgName>
								<address>
									<settlement>Manchester</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">AVATAR: The Architecture for First-Order Theorem Provers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">5437E977A92E6ECBFF07D5B267287079</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a new architecture for first-order resolution and superposition theorem provers called AVATAR (Advanced Vampire Architecture for Theories and Resolution). Its original motivation comes from a problem wellstudied in the past -dealing with problems having clauses containing propositional variables and other clauses that can be split into components with disjoint sets of variables. Such clauses are common for problems coming from applications, for example in program verification and program analysis, where many ground literals occur in the problems and even more are generated during the proof-search.</p><p>This problem was previously studied by adding various versions of splitting. The addition of splitting resulted in some improvements in performance of theorem provers. However, even with various versions of splitting, the performance of superposition theorem provers is nowhere near SMT solvers on variable-free problems or SAT solvers on propositional problems.</p><p>This paper describes a new architecture for superposition theorem provers, where a superposition theorem prover is tightly integrated with a SAT or an SMT solver. Its implementation in our theorem prover Vampire resulted in drastic improvements over all previous implementations of splitting. Over four hundred TPTP problems previously unsolvable by any modern prover, including Vampire itself, have been proved, most of them with short runtimes. Nearly all problems solved with one of 481 variants of splitting previously implemented in Vampire can also be solved with AVATAR.</p><p>We also believe that AVATAR is an important step towards efficient reasoning with both quantifiers and theories, which is one of the key areas in modern applications of theorem provers in program analysis and verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definitions of Avatar (from various dictionaries):</head><p>(Hindu Mythology) the descent of a deity to the earth in an incarnate form or some manifest shape; the incarnation of a god (Science Fiction) a hybrid creature, composed of human and alien DNA and remotely controlled by the mind of a genetically matched human being (Automated Reasoning) a first-order theorem prover, which embodies a SAT solver controlling the prover's behaviour</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The work described in this paper started with an attempt to make further improvement in dealing with problems having clauses containing propositional variables and other clauses that can be split into components with disjoint sets of variables. The problem of dealing with such clauses started with splitting with backtracking, implemented in Spass <ref type="bibr" target="#b19">[20]</ref> and splitting without backtracking <ref type="bibr" target="#b11">[12]</ref> implemented in Vampire <ref type="bibr" target="#b8">[9]</ref>. A very extensive investigation of various ways of organising splitting in a theorem prover was undertaken in <ref type="bibr" target="#b6">[7]</ref>, where both kinds of splitting were augmented with various options, including the use of BDDs and SAT solvers. Though the use of splitting results in the improvement of theorem provers performance, the methods used in them cannot compete with the methods used in SAT solvers on propositional problems or methods used in SMT solvers on ground problems with equality.</p><p>In first-order theorem proving, theorem provers based on variants of resolution and superposition calculi (in the sequel simply called superposition provers) are predominant. This is confirmed by the results of the last CASC competitions <ref type="foot" target="#foot_0">1</ref> , see <ref type="bibr" target="#b18">[19]</ref> for a description of CASC. The top three theorem provers Vampire <ref type="bibr" target="#b8">[9]</ref>, E-MaLeS and E <ref type="bibr" target="#b16">[17]</ref> are resolution and superposition-based, while the fourth one iProver <ref type="bibr" target="#b7">[8]</ref> implements both an instance-based calculus and resolution with superposition.</p><p>Superposition theorem provers use saturation algorithms. They deal with a search space consisting of clauses. Inferences performed by saturation algoritms are of three different kinds:</p><p>1. Generating inferences derive news clause from clauses in the search space. These new clauses can then be immediately simplified and/or deleted by other kinds of inference. Examples of generating inferences are binary resolution and superposition. 2. Simplifying inferences replace a clause by another clause that is simpler in some strict sense. Examples of simplifying inferences are demodulation (rewriting by ordered unit equalities) and subsumption resolution (binary resolution inference whose conclusion subsumes one of the premises). 3. Deletion inferences delete clauses from the search space. Examples of deletion inferences are subsumption and tautology deletion.</p><p>On hard problems the search space of superposition provers is often growing rapidly, and simplifications and deletions consume considerable time. Performance of such provers degrades especially fast when they generate many clauses having more than one literal (multi-literal clauses for short) and heavy clauses (clauses of large sizes). There are several reasons for this degradation of performance:</p><p>1. The complexity of algorithms implementing inference rules depends on the size of clauses. For example, subsumption and subsumption resolution are known to be NP-complete and algorithms implementing them are exponential in the number of literals in clauses. 2. Storing heavy clauses requires more memory. Moreover, every literal in a clause (and sometimes every term occurring in such a literal) are normally added to one or more indexes. Index maintenance requires considerable space and time and operations on these indexes slow down significantly when the indexes become large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Generating inferences applied to heavy clauses usually generate heavy clauses.</head><p>Generating inferences applied to clauses with many literals usually generate clauses with many literals. For example, resolution applied to two clauses containing n 1 and n 2 literals typically gives a clause with n 1 + n 2 -2 literals.</p><p>To deal with multi-literal and heavy clauses, one can simply start discarding them after some time, thus losing completeness as in <ref type="bibr" target="#b13">[14]</ref>. Alternatively, one can use splitting.</p><p>There are two kinds of splitting described in the literature: splitting with backtracking (originally introduced in SPASS <ref type="bibr" target="#b19">[20]</ref>) or splitting without backtracking (originally introduced in Vampire <ref type="bibr" target="#b12">[13]</ref>).</p><p>In this paper we introduce a new way of splitting clauses, driven by a SAT or an SMT solver. This results in a new architecture for first-order theorem proving, which we call AVATAR. We show that the use of AVATAR instead of standard architectures results in a considerable improvement in the performance of theorem provers. Hundreds of problems unsolvable by any prover for years were solved when AVATAR was implemented in Vampire. Moreover, we believe that AVATAR is a significant step towards major improvements in one of the main problems in modern first-order theorem proving: reasoning with both quantifiers and theories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We assume that the reader is familiar with SAT solving and has some knowledge of firstorder theorem provers. A deeper knowledge of superposition theorem proving, as well as SMT solving, is useful, but not necessary, since we give some background material on saturation algorithms implemented in superposition theorem provers.</p><p>Recall that a (first-order) clause is a disjunction L 1 ∨ . . . ∨ L n of literals, where a literal is an atomic formula or a negation of an atomic formula. A literal or clause is ground if it contains no occurrences of variables. In the context of splitting we sometimes consider a clause as a set of its literals. In other words, we assume that clauses do not contain multiple occurrences of the same literal and clauses equal up to permutation of literals are considered equal. We assume that all predicates and functions in first-order logic are uninterpreted and that the language may contain (but not necessarily contains) the equality predicate, denoted by =. The empty clause is denoted by 2.</p><p>Unlike SMT solving, clauses containing variables are considered implicitly universally quantified. Suppose that C is a clause with variables x 1 , . . . , x k . Then ∀C will denote the formula (∀x 1 ) . . . (∀x k )C, also called the universal closure of C. In firstorder theorem proving the semantics of a clause is its universal closure, so a set of clauses C 1 , . . . , C n is satisfiable if and only if so is the set of formulas ∀C 1 , . . . , ∀C n . Any clause obtained by applying a substitution to a clause C is called an instance of C. If this instance is also a ground clause, it is called a ground instance of C. Satisfiability of a set of clauses in first-order predicate logic (in the SMT terminology it is the logic of equality and uninterpreted predicates and functions) is characterised by the Herbrand theorem: a set S of clauses is unsatisfiable if and only if some finite set of ground instances of clauses in S in unsatisfiable.</p><p>Our next aim is to explain splitting. In very simple terms, splitting is based on the following idea. Suppose that S is a set of (first-order) clauses and C 1 ∨ C 2 a clause such that the variables of C 1 and C 2 are disjoint. Then ∀(C 1 ∨ C 2 ) is equivalent to (∀C 1 ) ∨ (∀C 2 ), which implies that the set S ∪ {C 1 ∨ C 2 } is unsatisfiable if and only if both S ∪ {C 1 } and S ∪ {C 2 } are unsatisfiable.</p><p>Let C 1 , . . . , C n be clauses such that n ≥ 2 and all the C i 's have pairwise disjoint sets of variables. Then we say that the clause</p><formula xml:id="formula_0">D def = C 1 ∨ . . . ∨ C n is splittable into com- ponents C 1 , .</formula><p>. . , C n . We will also say that the set C 1 , . . . , C n is a splitting of D. For example, every ground multi-literal clause is splittable. There may be more than one way to split a clause, however there is always a unique splitting such that each component C i is non-splittable; we call this splitting maximal. It is easy to see that a maximal splitting has the largest number of components and every splitting with the largest number of components is the maximal one. There is a simple algorithm for finding the maximal splitting of a clause <ref type="bibr" target="#b11">[12]</ref>, which is, essentially, the union-find algorithm.</p><p>In the sequel, when we speak about a splitting of a clause we will only consider maximal splittings and only deal with components that are non-splittable. We will denote arbitrary clauses by D and components by C, maybe with indexes.</p><p>Splittable clauses appear especially often when theorem provers are used for software verification and static analysis. Problems used in these applications usually have a large number of ground clauses (coming from program analysis) and a small number of non-ground clauses (for example, axiomatisations of memory or objects).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Saturation Algorithms</head><p>In this section we briefly discuss saturation algorithms with redundancy elimination used in superposition theorem provers. Essentially, a saturation algorithm works with a set of clauses S (the current search space) and uses a collection of generating, simplifying and deletion inferences. The theoretical basis of saturation algorithms is the notion of redundancy given e.g., in <ref type="bibr" target="#b0">[1]</ref>: a clause D is redundant if D is a logical consequence of clauses in the search space, which are strictly smaller than D w.r.t. a simplification ordering on clauses. Both simplifying and deletion inferences in saturation algorithms are designed in such a way that they only remove redundant clauses.</p><p>There is more than one saturation algorithm. For illustration we will use the Otter saturation algorithm <ref type="bibr" target="#b8">[9]</ref>, though AVATAR works equally well with other saturation algorithms. For an overview of saturation algorithms we refer to <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b8">9]</ref>.</p><p>A simplified description of the Otter saturation algorithm is shown in Figure <ref type="figure">1</ref>. The algorithms maintains three sets of clauses:</p><p>1. active: the set of clauses selected for generating inferences. The algorithm is designed in such a way that all generating inferences among active clauses are applied. 2. passive: clauses that are waiting to be activated. The Otter saturation algorithm uses passive clauses for simplifying and deletion inferences. All operations performed by the saturation algorithm that may take considerable time to execute, are normally implemented using term indexing, that is, building a special purpose index data structure that makes the operation faster. For example, all theorem provers with built-in equality reasoning have an index for forward demodulation (rewriting by ordered unit equalities from active ∪ passive).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">AVATAR</head><p>In this section we describe AVATAR and how it handles splitting. AVATAR consists of two components: a resolution (or resolution and superposition) theorem prover FO and a SAT solver SAT. Later we will consider how an SMT solver can be used in place of SAT. The SAT solver stores propositional clauses, which considered clause components as propositional literals. To consider them as propositional literals, we will use a mapping [•] from components to propositional literals. This mapping satisfies the following properties:</p><p>1.</p><p>[C] is a positive literal if and only if C is either a non-ground component or a positive ground literal; 2. For a negative ground component ¬C we have</p><formula xml:id="formula_1">[¬C] = ¬[C]. 3. [C 1 ] = [C 2 ] if and only if C 1 is equal to C 2 up</formula><p>to variable renaming and symmetry of equality. During the proof search, FO and SAT exchange information. The information exchange is described in Figure <ref type="figure">2</ref>.</p><formula xml:id="formula_2">FO SAT ¬[C1] ∨ . . . ∨ ¬[Cm] ∨ [C 1 ] ∨ . . . ∨ [C n ] (split clause) ¬[C1] ∨ . . . ∨ ¬[Cm] (contradiction clause) Solve! C-</formula><p>In a nutshell, AVATAR works as follows. The superposition prover FO works as usual, using a saturation algorithm. The difference is in the treatment of splittable clauses. If there is a splittable clause C 1 ∨. . .∨C n with components C 1 , . . . , C n , which passed the retention test, it is not added to passive. Instead,</p><formula xml:id="formula_3">[C 1 ] ∨ . . .∨ [C n ]</formula><p>it is passed to the SAT solver. The SAT solver adds the new clause to existing clauses and checks all clauses for satisfiability. If it is unsatisfiable, we are done. Otherwise, it computes a C-interpretation I, which is a model of all clauses stored in it. For each literal in the interpretation, if this literal has a form [C] for some component C, the component C is passed to FO where it is used as an assertion. The exception are literals of the form</p><formula xml:id="formula_4">¬[C],</formula><p>where C is a non-ground component, since such a literal does not correspond to any component.</p><p>To explain the cooperation in more detail, we should modify the superposition calculus to deal with these assertions. The description is similar, but not the same as in splitting with backtracking.</p><p>An assertion is a finite set of components. A clause with assertions, or simply an A-clause is a pair, consisting of a clause D and an assertion A. Such a clause with assertions will be denoted by (D ← A), or simply D when the assertion A is empty. We will denote assertions by A and A-clauses as F . An A-clause (D ← C 1 , . . . , C m ) is logically equivalent to ∀D ∨ ¬∀C 1 ∨ . . . ∨ ¬∀C m (or, equivalently, to ∀C 1 ∧ . . . ∧ ∀C m → ∀D). A standard clause D can be considered as an A-clause with the empty set of assertions. We will extend the notation [•] to assertions: for an assertion</p><formula xml:id="formula_5">A = {C 1 , . . . , C m }, we define [A] = {[C 1 ], . . . , [C m ]}.</formula><p>We call an A-clause (D ← A) splittable if the clause D is splittable. Likewise, every A-clause of the form (2 ← A) is called an empty A-clause. We can change the superposition calculus (or any other calculus on clauses) to a calculus on clauses with assertions by turning any rule of the superposition calculus</p><formula xml:id="formula_6">D 1 • • • D k D into a set of rules (D 1 ← A 1 ) • • • (D k ← A k ) (D ← A 1 ∪ . . . ∪ A k ) ,</formula><p>where A 1 , . . . , A k are assertions. Later we will explain how the addition of assertions affects simplification and deletion rules. AVATAR uses A-clauses instead of ordinary clauses. At each time moment, the components used in assertions are those that are computed by the SAT solver as its last model. Since this model changes over time, clauses with assertions can be added and deleted.</p><p>We are now ready to describe the AVATAR algorithm. It is defined as a sequence of steps performed by the superposition prover FO and the SAT solver SAT. These steps are interleaved. Each step performed by the superposition prover is followed by a step by the SAT solver and vice versa. After each step performed by FO, some information is passed from it to SAT, as shown in Figure <ref type="figure">2</ref>. Likewise, after each step performed by SAT, some information is passed from it to FO. These steps are described in detail in the next two sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The SAT Algorithm</head><p>We start with the SAT algorithm since it is simpler that the algorithm employed by FO. Essentially, the SAT solver is behaving like a standard incremental SAT solver. It receives, from time to time, new propositional clauses from FO and checks, upon a "solve" request, satisfiability of the clauses it stores. If they are satisfiable, it passes back to FO a C-interpretation satisfying all the propositional clauses. Otherwise, it returns unsatisfiable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">The FO Algorithm</head><p>In a nutshell, the FO algorithm behaves like a standard saturation algorithm. The main differences are that it operates on A-clauses and that splittable clauses are not stored. Instead, for each splittable or empty A-clause</p><formula xml:id="formula_7">(C 1 ∨ . . . ∨ C n ← C 1 , . . . , C m ), FO passes the propositional clause [C 1 ] ∨ . . . ∨ [C n ] ∨ ¬[C 1 ] ∨ . . . ∨ ¬[C m ] to SAT.</formula><p>In reality, the FO algorithm is more sophisticated than standard saturation algorithms because of the way it treats simplified and deleted A-clauses. To illustrate the problem, consider an example. Suppose that we have two clauses D, D such that D subsumes D . If D and D occur in the search space of a standard saturation algorithm, D will be treated as redundant and can be deleted. In AVATAR, we deal with A-clauses. Suppose that A-clauses (D ← A) and (D ← A ) occur in the current search space and D subsumes D . If A ⊆ A , then (D ← A ) can still be considered as redundant and deleted. If not, we can only delete it temporarily, since the model computed by the SAT solver can change and make a literal in [A] false, while all the literals in [A ] remain true. In this case (D ← A) will later be removed from the search space and, to preserve completeness, (D ← A ) must then be undeleted.</p><p>For this reason we introduce a special storage for A-clauses that can be temporarily deleted and then undeleted. This storage will be denoted in the saturation algorithm as locked . Elements of locked are pairs (F, λ), where F is an A-clause and λ a set of Cliterals. If (F, λ) ∈ locked , we will informally call λ a lock of F . The same A-clause F can occur in locked with different locks.</p><p>We say that a C-interpretation I unlocks a pair ((C ← A), λ) if 1. all C-literals in [A] are true in I; 2. at least one C-literal in λ is either false or undefined in A.</p><p>When a pair (F, λ) is added to locked , all of the literals in λ are true in the current model int computed by the SAT solver (this follows from a general invariant of the AVATAR algorithm: for every A-clause (D ← A) in the search space, each literal in [A] is true in this model). If one of the literals in λ later becomes false or undefined, the A-clause F must be unlocked by removing it from locked and adding it to the set of unprocessed clauses.</p><p>The FO algorithm is shown on Figure <ref type="figure">3</ref>. Its parts that are specific to AVATAR are marked by . Simplifications will be explained separately.</p><p>The AVATAR algorithm maintains, in addition to the sets active, passive, and unprocessed, the following collections.</p><p>• A C-interpretation int returned by the SAT solver. This interpretation makes the assertions of all stored clauses, apart from locked ones, true. We store this interpretation to maintain locking and unlocking operations. To check which clauses should be locked or unlocked, we compute, at each step, the difference between the current and the previous values of int . • The set of A-clauses sat queue waiting to be passed to the SAT solver. We store A-clauses in sat queue instead of passing them immediately to the SAT solver because changes in the model found by the SAT solver can induce considerable changes in A-clauses and other data structures used by the saturation algorithm, so recomputing this model too often may result in the overall degradation of performance. The only exception is made when an empty A-clause is derived. In this case we recompute the interpretation immediately, since the new model int will make the given clause (and potentially many other stored clauses) locked or even deleted. • The set locked of locked A-clauses with locks. A-clauses in this set are temporarily deleted, since for some components C in their assertions, [C] can be false or undefined in the current C-interpretation int. However, they can be unlocked later. </p><formula xml:id="formula_8">D 1 • • • ¨D m D . (<label>1</label></formula><formula xml:id="formula_9">)</formula><p>This means that D is a logical consequence of D 1 , . . . , D m and addition of D to the search space makes D m redundant. There are three commonly used simplification rules: subsumption, subsumption resolution, and demodulation (rewriting by unit equalities). A inference on A-clauses corresponding to ( <ref type="formula" target="#formula_8">1</ref>) is</p><formula xml:id="formula_10">(D 1 ← A 1 ) • • • (D m ← A m ) (D ← A) ,</formula><p>where </p><formula xml:id="formula_11">A = A 1 ∪ . . . ∪ A m . If A = A m ,</formula><formula xml:id="formula_12">F i = (C i ← A i ) for i = 1, . . . , m. Define A = A 1 ∪ . . . ∪ A m . If A ⊆ A, then we say that (C ← A) is unconditionally simplified by F 1 , . . . , F m into (C ← A). If A ⊆ A, then we say that (C ← A) is conditionally simplified by F 1 , . . . , F m into (C ← A ∪ A ) with the lock A -A.</formula><p>In a similar way we can define notions (C ← A) is unconditionally deleted by F 1 , . . . , F m and (C ← A) is conditionally deleted by F 1 , . . . , F m with the lock A -A.</p><p>Forward simplification in AVATAR is shown in Figure <ref type="figure">4</ref>. Backward simplification is similar and not included in this paper.</p><p>To avoid excessive locking and unlocking, it is desirable to have a SAT solver, which tries to return a model similar to the previously returned one. To this end, one can use the following simple rule: if a new A-clause passed to the SAT solver contains a C-literal [C] undefined in the previous C-interpretation, we satisfy this clause by making [C] true. Such A-clauses are common and appear when a new component is found. Using this rule also helps the SAT solver, since it does not have to be run at all when all recently added A-clauses have this property.</p><p>When all literals in a new A-clause passed to the SAT solver are false in the current C-interpretation int , this interpretation must change. For example, this always happens when we derive an empty A-clause (2 ← A). Phase saving in SAT solvers introduced in <ref type="bibr" target="#b9">[10]</ref> assigns to a propositional variable a value that was most recently assigned to it. Although we did not make experiments with various strategies in a SAT solver, phase saving seems to be useful for achieving a "small model difference" effect. We also use a data structure allowing one to find locked and unlocked clauses upon changes in the SAT solver model in time linear in the size of the number of found clauses plus the number of variables that changed their values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Term Indexing</head><p>When we discuss the use of splitting in superposition theorem provers, it is very important to understand how the use of splitting affects other components of such provers. The efficiency and power of modern superposition theorem provers comes from two techniques: redundancy elimination (see <ref type="bibr" target="#b0">[1]</ref> for the theory and <ref type="bibr" target="#b13">[14]</ref> for the implementation aspects) and term indexing <ref type="bibr" target="#b17">[18]</ref>.</p><p>Even when simplifications are used, the search space can quickly grow to hundreds of thousands of clauses. To perform inferences on such a large search space efficiently, theorem provers maintain several indexes storing information about terms and clauses. These indexes make it easier to find candidates for inferences. In some cases inferences can be performed only by using the relevant index, without retrieving clauses used for these inferences. The number of different indexes in theorem provers varies and can be as many as about 10. Frequent insertions and deletions in an index can affect performance of a theorem prover. A typical example is when a theorem prover generates an equality a = b between two constants and uses it to rewrite a into b. For nearly all indexing techniques used in the superposition theorem provers, every term and clause containing a must be removed from all indexes and a new term containing b inserted in them again. Doing this single simplification step on an indexed set with 100,000 clauses can take a very long time.</p><p>In AVATAR, clauses can be locked and then unlocked. This happens often when the number of clauses stored by the SAT solver grows and it recomputes its C-model int . Frequent deletions of a clause from all indexes it is stored in, followed by its insertion in these indexes, can be very expensive. There is an alternative to deleting locked clauses and information about them from indexes. If an A-clause is deleted or simplified conditionally, we do not remove it from indexes at all. Instead, we change index retrieval operations. For each successful retrieval operation we check if the result is a locked clause. If it is locked, we ignore the retrieved clause and the corresponding inference. This alternative is not yet implemented in Vampire and requires further experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Experiments</head><p>For our experiments we reproduced the experiments from <ref type="bibr" target="#b6">[7]</ref>, where various versions of splitting were considered. In fact, AVATAR and some decisions made in it (such as treatment of locked literals in indexes and addition of negations of ground components) are due to what we learned from experiments <ref type="bibr" target="#b6">[7]</ref>. We will not show all results from <ref type="bibr" target="#b6">[7]</ref> but only consider the most relevant part, where we compare the performance of different versions of splitting. Note that such comparisons are very hard for the following reasons:</p><p>1. One cannot simply compare AVATAR to, say, splitting with backtracking, since the latter can be used with different options, giving very different results. 2. In general, a value of a strategy (a collection of parameter-value pairs) is hard to understand. Some strategies perform very well on the average but cannot solve problems unsolvable by other strategies. Modern theorem provers treat hard problems with a cocktail of strategies. For example, Vampire has a CASC mode <ref type="bibr" target="#b8">[9]</ref> doing exactly that. A collection of strategies, each of which is bad on the average, can easily outperform a collection of strategies, each of which is good on the average. On the other hand, having too many strategies is not good, since running all of them may consume a considerable time, so strategies that solve many problems are useful as part of a collection: indeed, theorem provers are normally used with short time limits, so that one cannot afford running too many strategies on a problem.</p><p>New strategies are most useful if they solve many new problems, and especially with short running times. In this case they can be used to create more powerful cocktails than those used before.</p><p>Our experiments have shown that AVATAR shows outstanding results both in terms of its average performance and in the number of problems that it can solve and that were previously unsolvable by any existing prover.</p><p>For benchmarking we used unsatisfiable TPTP problems having non-unit clauses and rating greater than 0.2 and less than 1. Essentially, the rating is the percentage of existing provers that cannot solve a problem. For example, rating greater than 0.2 means that less than 80% of existing theorem provers can solve the problem. Likewise, rating 1 means that the problem cannot be solved by the existing provers. However, the rating evaluation uses a single mode of every prover, so it is possible that the same prover can solve a problem of rating 1 using a different mode. For this reason, we also added problems of rating 1 that are solvable by some version of Vampire. We excluded very large problems since for them it was preprocessing, but not other options, that affects results the most. This resulted in selecting 6892 TPTP problems for our experiments.</p><p>To conduct our experiments, we took a Vampire strategy that is believed to be nearly the best in the overall number of solved problems, and generated the 481 variations of this strategy obtained by setting the splitting parameters to all possible values described in <ref type="bibr" target="#b6">[7]</ref>, In addition, we used a single run of this strategy using AVATAR.</p><p>Only 5,273 (about 77% of all problems) were solved by at least one splitting strategy. The results are summarised in Table <ref type="table" target="#tab_3">1</ref>. They show that AVATAR is very robust, resulting in a considerable increase of the number of solved problems over the best strategies using other versions of splitting. The second series of experiments was run on our cluster of 45 servers. Each server has 16G RAM and 4 cores. We used 3 cores on each server since we observed that using all 4 often results in the operating system putting two instances of Vampire on the same core. This results in 135 instances on Vampire running in parallel. The experiments were run for over 6 months in 2012-2013. The aim of this series of experiments was to solve as many TPTP problems overall as possible; and its results were used to configure Vampire for the last CASC competition CASC-24. Eventually, Vampire with AVATAR was able to solve 421 problems unsolvable by Vampire without AVATAR and by any other prover. To get the results of other provers, we used the file ProblemAndSolutionStatistics shipped with TPTP, which records results on every TPTP problem by nearly all theorem provers in the recent history. On the contrary, Vampire using splitting with and without backtracking was able to solve only 17 problems unsolvable by any strategy using AVATAR. Solving over 400 previously unsolvable problems is a remarkable result since such all these problems are very hard. In the past, the implementation of various novelties in Vampire would normally result in solving from a few to about 30 previously unsolvable problems.</p><p>The experimental results were so successful that all previously implemented code for handling splitting was completely removed from the latest versions of Vampire, resulting in considerable simplifications in its code and better maintainability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Using an SMT Solver or Other Theory Solvers</head><p>Another interesting feature of AVATAR is that for a combination of first-order logic with theories one can use any theory solver instead of a SAT solver. In particular, for problems with equality one can use an SMT solver for logic with equality and uninterpreted functions. Non-ground components are then treated in the SMT solver as before, as propositional variables. Ground components can be used by the SMT solver as theory literals. We added to Vampire a very simple SMT solver for logic with equality and uninterpreted functions. This addition allowed us to solve some TPTP problems previously unsolved by any prover, including Vampire using AVATAR and a SAT solver.</p><p>The SAT and the SMT solvers implemented in Vampire are very simple and much weaker than best SAT and SMT solvers. It will be interesting to see how the use of better SAT and SMT solvers affects the performance of AVATAR.</p><p>There is an interesting option that can be used for logic with equality and maybe other theories. Instead of passing back to FO a propositional model, an SMT solver can pass some canonical representation of the congruence relation computed by it. Also, the SMT solver can use ground (and maybe also non-ground) unit equalities produced by the superposition prover. We leave these extensions as future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Related Work</head><p>The author believes that proving theorems with both quantifiers and theories is the main problem in modern first-order theorem proving. In particular, it is crucial for applications of theorem provers in program analysis and also in interactive theorem provers. AVATAR offers an architecture different from those proposed in first-order theorem provers able to handle theories, including SPASS+T <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11]</ref>, Z3 <ref type="bibr" target="#b4">[5]</ref>, CVC4 <ref type="bibr" target="#b2">[3]</ref>, Princess <ref type="bibr" target="#b15">[16]</ref> and Beagle <ref type="bibr" target="#b3">[4]</ref>.</p><p>This paper was motivated by our analysis of the results <ref type="bibr" target="#b6">[7]</ref>, which contains an extensive discussion of splitting in superposition theorem provers. In particular, it uses splitting in various forms and SAT solvers, but not in the way discussed in this paper. Earlier work on splitting includes <ref type="bibr" target="#b19">[20]</ref> and <ref type="bibr" target="#b12">[13]</ref>.</p><p>Paper <ref type="bibr" target="#b5">[6]</ref> describes a calculus DPLL(Γ) using a superposition prover together with a SAT or an SMT solver (Z3) in a way similar to AVATAR. Ground literals decided and implied by the SAT solver were used as hypotheses to first-order clauses. Our approach is different in several aspects:</p><p>1. We use arbitrary components, while DPLL(Γ) uses only ground literals; 2. We consider the SAT solver as a black box producing models, while in DPLL(Γ)</p><p>the SAT solver and the superposition prover architectures and calculi are mutually dependent. The backjump rule and locking (disabling) first-order clauses in DPLL(Γ) essentially uses decision levels of the SAT solvers. The use of decision levels makes DPLL(Γ) is very similar to splitting with backtracking, though with some improvements due to the use of a SAT solver.</p><p>Also, <ref type="bibr" target="#b5">[6]</ref> discuss very different benchmarks, where theory reasoning and E-matching are often required to solve problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Conclusion</head><p>We described a new architecture AVATAR for first-order theorem provers. In this architecture, splitting in a theorem prover is driven by a SAT (or an SMT) solver. When the input problem is ground, AVATAR is as efficient as a SAT solver (or an SMT solver for logic with equality). On non-ground problems, an implementation of AVATAR in Vampire outperforms the previous versions of Vampire by a very large margin. In particular, using AVATAR allowed us to solve 421 TPTP problems previously unsolvable by any first-order theorem prover. We believe that AVATAR will become a standard architecture for future first-order theorem provers and can be especially successful in reasoning with both quantifiers and theories. It turned out to be effective in passing information from a first-order theorem prover to a SAT or an SMT solver. Nonetheless, AVATAR does not solve the reverse problem: passing information from an SMT solver to the first-order prover, which is currently done by other approaches, such as E-matching.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>then (D m ← A m ) can be safely deleted. Otherwise, consider the assertion A = A -A m . At the moment this inference is performed, all literals in [A] are true in the current C-interpretation int . However, there may be a moment in the future, when [A m ] is still true, while some literals in [A ] false. In that case (D m ← A m ) must be put back in the search space. Thus, we lock (D m ← A m ) with the lock A . Any change to int , which makes a C-literal in [A ] false will trigger unlocking of this A-clause.To define simplifications formally, we introduce new notions. Suppose that a clause C can be simplified into a clause C using clauses C 1 , . . . , C m . Consider A-clauses (C ← A) and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>3. unprocessed : clauses that have been generated recently. Unprocessed clauses are waiting in a queue for a retention test, which normally includes simplification and deletion inferences applied to these clauses. If a clause C passes the retention test, this clause (or a clause obtained by simplifying C) is added to passive clauses, otherwise it is discarded.</figDesc><table /><note><p>At every step, the algorithm either processes a clause new , picked from unprocessed clauses, or performs generating inferences with the so-called given clause, which is the clause most recently added to active. input: init: set of clauses; var active, passive, unprocessed : set of clauses; var given, new : clause; active := ∅; unprocessed := init; loop while unprocessed = ∅ new :=pop(unprocessed ); if new = 2 then return unsatisfiable; if retained (new ) then (* retention test *) simplify new by clauses in active ∪ passive ; (* forward simplification *) if new = 2 then return unsatisfiable; if retained (new ) then (* another retention test *) delete and simplify clauses in active and (* backward simplification *) passive using new ; move the simplified clauses to unprocessed ; add new to passive if passive = ∅ then return satisfiable or unknown given := select (passive); (* clause selection *) move given from passive to active; unprocessed :=forward infer(given, active); (* forward generating inferences *) add backward infer (given, active) to unprocessed ; (* backward generating inferences *) Fig. 1. Otter Saturation Algorithm</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>if new is unconditionally deleted by A-clauses in active ∪ passive then do nothing else if new is conditionally deleted by A-clauses in active ∪ passive with a lock λ then add (new , λ) to locked else if new is unconditionally simplified by A-clauses in active ∪ passive into new then add new to unprocessed else if new is conditionally simplified by A-clauses in active ∪ passive into new with a lock λ then add new to unprocessed ; add (new , λ) to locked</figDesc><table><row><cell>Fig. 4. Forward Simplification</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 .</head><label>1</label><figDesc>Problems solved by each setting of the splitting strategy</figDesc><table><row><cell>splitting</cell><cell>strategies worst average best</cell></row><row><cell>off</cell><cell>25 3833 3869 3880</cell></row><row><cell>backtracking</cell><cell>64 2538 3889 4381</cell></row><row><cell>non-backtracking</cell><cell>416 2489 3595 4126</cell></row><row><cell>AVATAR</cell><cell>1 4716 4716 4716</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.cs.miami.edu/ ˜tptp/CASC/24/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. We thank Krystof Hoder, who implemented the first version of AVATAR, Giles Reger, Laura Kovács and Martin Suda for discussions and reading preliminary versions of this paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Simplifications</head><p>We already gave a hint as to how simplifications are performed, when we discussed the use of locking and treatment of subsumed clauses.</p><p>Consider now simplification rules. All simplification rules in Vampire and other superposition provers have the following form:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Resolution theorem proving</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bachmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Automated Reasoning</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="page" from="19" to="99" />
		</imprint>
	</monogr>
	<note>ch. 2</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Refutational theorem proving for hierarchic first-order theories</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bachmair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Ganzinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Waldmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Algebra Eng. Commun. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="193" to="212" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<author>
			<persName><forename type="first">C</forename><surname>Barrett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Deters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hadarean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jovanović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Reynolds</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Tinelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2011</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Gopalakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="171" to="177" />
		</imprint>
	</monogr>
	<note>CVC</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchic Superposition with Weak Abstraction</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baumgartner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Waldmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CADE 2013</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Bonacina</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7898</biblScope>
			<biblScope unit="page" from="39" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TACAS 2008</title>
		<editor>
			<persName><forename type="first">C</forename><forename type="middle">R</forename><surname>Ramakrishnan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rehof</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">4963</biblScope>
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Engineering DPLL(T) + saturation</title>
		<author>
			<persName><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">S</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAR 2008. LNCS (LNAI)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Baumgartner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5195</biblScope>
			<biblScope unit="page" from="475" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The 481 ways to split a clause and deal with propositional variables</title>
		<author>
			<persName><forename type="first">K</forename><surname>Hoder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CADE 2013</title>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Bonacina</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7898</biblScope>
			<biblScope unit="page" from="450" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">iProver-an instantiation-based theorem prover for first-order logic (system description)</title>
		<author>
			<persName><forename type="first">K</forename><surname>Korovin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAR 2008. LNCS (LNAI)</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Armando</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><surname>Baumgartner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Dowek</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="volume">5195</biblScope>
			<biblScope unit="page" from="292" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">First-order theorem proving and vampire</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kovács</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV 2013</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Sharygina</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8044</biblScope>
			<biblScope unit="page" from="1" to="35" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A lightweight component caching scheme for satisfiability solvers</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pipatsrisawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Darwiche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT 2007</title>
		<editor>
			<persName><forename type="first">J</forename><surname>Marques-Silva</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Sakallah</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4501</biblScope>
			<biblScope unit="page" from="294" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SPASS+T</title>
		<author>
			<persName><forename type="first">V</forename><surname>Prevosto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Waldmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ESCoR</title>
		<meeting>of ESCoR</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="18" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Splitting without backtracking</title>
		<author>
			<persName><forename type="first">A</forename><surname>Riazanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th International Joint Conference on Artificial Intelligence</title>
		<editor>
			<persName><forename type="first">B</forename><surname>Nebel</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="611" to="617" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The design and implementation of Vampire</title>
		<author>
			<persName><forename type="first">A</forename><surname>Riazanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AI Commun</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2,3</biblScope>
			<biblScope unit="page" from="91" to="110" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Limited resource strategy in resolution theorem proving</title>
		<author>
			<persName><forename type="first">A</forename><surname>Riazanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computations</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="101" to="115" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Limited resource strategy in resolution theorem proving</title>
		<author>
			<persName><forename type="first">A</forename><surname>Riazanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Computations</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="101" to="115" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">E-Matching with Free Variables</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rümmer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LPAR-18</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7180</biblScope>
			<biblScope unit="page" from="359" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">E -a brainiac theorem prover</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schulz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of AI Communications</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="111" to="126" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Handbook of Automated Reasoning</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">V</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</author>
		<editor>Robinson, A., Voronkov, A.</editor>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Elsevier Science</publisher>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1853" to="1964" />
		</imprint>
	</monogr>
	<note>Term indexing</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">:</forename><surname>Sutcliffe</surname></persName>
		</author>
		<author>
			<persName><surname>Tptp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Casc</forename><surname>Tstp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSR 2007</title>
		<editor>
			<persName><forename type="first">V</forename><surname>Diekert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">V</forename><surname>Volkov</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="volume">4649</biblScope>
			<biblScope unit="page" from="6" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Combining superposition, sorts and splitting</title>
		<author>
			<persName><forename type="first">C</forename><surname>Weidenbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Automated Reasoning. ch</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Voronkov</surname></persName>
		</editor>
		<imprint>
			<publisher>Elsevier Science</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1965" to="2013" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
