<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Distributed Performance Monitoring: Methods, Tools, and Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">R</forename><surname>Hofmann</surname></persName>
						</author>
						<author>
							<persName><forename type="first">R</forename><surname>Klar</surname></persName>
						</author>
						<author>
							<persName><forename type="first">B</forename><surname>Mohr</surname></persName>
						</author>
						<author>
							<persName><forename type="first">A</forename><surname>Quick</surname></persName>
						</author>
						<author>
							<persName><forename type="first">M</forename><surname>Siegle</surname></persName>
						</author>
						<title level="a" type="main">Distributed Performance Monitoring: Methods, Tools, and Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">A92A579BFD61B61ED902B7B5FAE3E7F1</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T17:19+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Hardware monitoring</term>
					<term>hybrid monitoring</term>
					<term>event-driven monitoring</term>
					<term>instrumentation</term>
					<term>modeling</term>
					<term>performance evaluation</term>
					<term>debugging</term>
					<term>tuning</term>
					<term>parallel and distributed systems</term>
					<term>SUPRENUM</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A method for analyzing the functional behavior and the performance of programs in distributed systems is presented. We use hybrid monitoring, a technique which combines advantages of both software monitoring and hardware monitoring. The paper contains a description of a hardware monitor and a software package (ZM4/SIMPLE) which make our concepts available to programmers, assisting them in debugging and tuning of their code. A short survey of related monitor systems highlights the distinguishing features of our implementation. As an application of our monitoring and evaluation system, the analysis of a parallel ray tracing program running on the SUPRENUM multiprocessor is described. It is shown that monitoring and modeling both rely on a common abstraction of a system's dynamic behavior and therefore can be integrated to one comprehensive methodology. This methodology is supported by a set of tools.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>SERS AND operators of parallel and distributed sys-U tems often find it very difficult to exploit the immense computing power at their disposal. Writing and debugging parallel programs which use the underlying hardware in an efficient way proves to be a difficult task even for specialists.</p><p>There is typically not enough insight into the internals of the hardware, the system software and their alternating, effect with the user program. Bugs are hard to locate and tuning, which depends on a detailed knowledge of such factors as idle times, race conditions or access conflicts, is often not done systematically but by using ad-hoc methods. To analyze the functional behavior and the performance of a parallel program it is not enough to employ standard methods such as profiling and accounting. Sophisticated methods and tools are needed to handle these issues. Event-driven monitoring is a technique well-suited for analyzing programs running on a parallel or distributed system. It can be done by hardware, software or hybrid monitoring. We prefer hybrid monitoring which combines advantages of both hardware monitoring and software monitoring.</p><p>We agree with Ferrari who argues that in the past "the study o f perjormance evaluation as an independent subject has sometimes (caused researchers in the area to lose contact with realiv" [MI. Therefore we do not only wish to develop <ref type="bibr">Manuscript received September 21, 1992;</ref><ref type="bibr">revised May 25, 1993</ref>. The authors are with the Institiit fur Mathematische Maschinen, Universitat IEEE Log Number 9216780.</p><p>Erlangen-Niirnberg, IMMD VII, D-9 1058 Erlangen, Germany methods, but to implement tools that assist users in writing real-world applications. We built a distributed hardware monitor (ZM4) which is scalable and can be adapted to arbitrary object systems (the system on which the program under study is running). It has a high-precision global clock which allows to monitor several nodes of the object system simultaneously, providing globally valid time stamps. Completely independent of the monitor system ZM4 is the event trace analysis system SIMPLE, which allows the evaluation of arbitrarily formatted event traces. SIMPLE is designed as a software package which comprises independent tools that are all based on a new kind of event trace access: the trace format is described in a trace description language (TDL) and evaluation tools access the event trace through a standardized interface (POET).</p><p>The analysis of parallel programs is not limited to observing the program actually implemented for an underlying distributed architecture. Many questions can be solved more easily and more efficiently by setting up a model of the program and the machine, varying parameters in the model to predict the performance of the program under various circumstances. There is a great potential to integrate eventbased models and event-driven monitoring since both methods are based on the same abstraction of the dynamic behavior of the program under study: the event. Integrating modeling and monitoring allows to define events systematically by using a model to prepare the measurement. It allows to validate the model by comparing it to event traces of the actual program, and finally the use of measured parameters makes models more realistic.</p><p>The paper is organized as follows: the tools, i.e., the hardware monitor ZM4 and the package SIMPLE are described in Section 11. This section also contains a brief survey of other monitor systems which have been described in the literature. We then present a case study (Section 111) in which a parallel ray tracing program on the SUPRENUM multiprocessor is analyzed. We show how our tools enabled us to detect unexpected behavior and program bottlenecks, which helped to improve performance considerably. Current work on the integration of monitoring and modeling is presented in Section IV, which also includes some concluding remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[I. THE ZM4ISIMPLE MONITORING ENVIRONMENT</head><p>Event-driven monitoring represents the dynamic behavior of a program by a sequence of events. Unlike time-driven monitoring, event-driven monitoring is suitable for efficient program analysis, as the aim of monitoring is gaining insight into the dynamic behavior of The Relevance of Hybrid Monitoring:</p><p>1045-9219/94$04.00 0 1994 IEEE a parallel program [ 151. <ref type="bibr">Time-driven monitoring (sampling)</ref> provides only summary statistical information about program execution and is therefore insufficient for behavior analysis. An event is an atomic instantaneous action. The definition of events depends on the monitoring technique used. There are three monitoring techniques: hardware, software and hybrid monitoring. Using hardware monitoring, the event definition and recognition can be difficult and complex. An event is defined as a bit pattem on a processor bus or in a register. It is detected by the probes and detection circuitry of a hardware monitor. In this case it is difficult to relate the recorded signals to the monitored program, i.e., to find a problem-oriented reference. Using sojbvare or hybrid monitoring, the events are defined by inserting monitoring instructions at certain points in the program under investigation (program instrumentation). These instructions write event tokens into a reserved memory area of the monitored system (software monitoring). or to a hardware system interface which is accessible for a hardware monitor (hybrid monitoring). In defining events by program instrumentation, each monitored event token can be clearly assigned to a point in the program; this provides a sourcerelated reference. Thus, the evaluation of the event trace can be done on the program level which is familiar to the program designer. As hybrid monitoring combines source-related event specification with a small interference on the object system's behavior. it is our favorite monitoring technique.</p><p>Whenever the monitor device recognizes an event, il stores a data record (a so-called event record). An event record contains the information what happened when and where and consists of at least an event token and a time stamp. The time stamp is generated by the monitor and represents the acquisition time of the event record. Beside these fields, an event record can contain optional fields describing additional aspects of the occurred event. The sequence of events is stored as an event truce.</p><p>It is strongly recommended to wisely restrict instrumentation to essentials. One reason is that CPU time overhead increases with the number of events issued. The other reason is that a problem should be analyzed on an adequate level of abstraction. Therefore instrumentation should be limited to those events whose tracing is considered essential for an understanding of the problems to be solved. An interesting approach to the limitation of program perturbation is presented in <ref type="bibr" target="#b33">[37]</ref>. It is called adaptive instrumentation control and is used in the Pablo performance analysis environment.</p><p>Monitoring is a great help when analyzing programs running in modem parallel or distributed systems, but it is a task too complex to be done intuitively. Therefore monitoring and especially program instrumentation should be carried out in a systematic way. This is discussed in depth in Section IV.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. ZM4-A Universal Distributed Monitor System</head><p>A monitor system, universally adaptable to computer systems with more than one processor, must fulfill several architectural demands. It must be able to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Demands and Conceptual Issues:</head><p>a) deal with a large number of processors (nodes in the b) cope with spatial distribution of the object nodes, c) be adaptable to different node architectures, d) supply a global view on all interesting events in the object system for showing causal relationships between events in different nodes, e) provide a problem-oriented (source-related) view. We have designed and implemented a universal distributed monitor system, called ZM4 (abbreviation for German "Zahlmonitor 4"), which fulfils the demands a)-d). Its concepts for meeting these challenges are the following: a) In order to deal with a large number of object nodes the monitor ZM4 has a distributed architecture, scalable by allowing an arbitrary number of monitor agents. b) ZM4 interconnects the monitor agents by a local area network. Therefore, monitor agents need not be spatially concentrated and can also monitor spatially distributed object systems. c) ZM4 is not dedicated to just one object system but can record events from arbitrary object systems with arbitrary physical event representation. d) ZM4 has a global clock with an accuracy of 100 ns. This provides sufficient precision for establishing a global view in any of today's parallel and distributed systems. e) A problem-oriented view can be achieved by representing measured events and activities by the identifiers familiar to the programmer. Issues a ) 4 ) are dealt with in this section, containing the description of the architecture of ZM4 and its major component DPU. Issue e) is rather a problem of object instrumentation than of monitoring hardware. However, the ZM4 hardware monitor supports e) by accepting a wide variety of physical event formats.</p><p>The following considerations are important for the notion of global view in distributed systems: monitoring distributed systems or multiprocessors provides an event stream for each processor. When processors are working on a common task, they have to exchange information, resulting in an interdependence of their event streams. One concept to globally reveal all causal relationships is to order events. It suffices to locally order the events of each processor and to globally order events concerning interprocessor communication. Since local ordering is automatically achieved if the events are recorded in the order of their occurrence, we can restrict the following arguments to global ordering.</p><p>In systems communicating via message passing a global ordering of the communication events can be achieved by the inherent causality of Send-and Receive-operations <ref type="bibr">[28]</ref>. If monitoring shall provide not only a functional sequence of correctly ordered events but also performance, it is necessary to introduce time.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ZM4</head><p>access, two consecutive accesses to a shared variable must be ordered correctly. Thus, only a monitor clock with a global resolution less than memory access time allows to globally order communication events in systems with shared variables. As these demands of time resolution exceed those for ordering SendReceive-events by orders of magnitude, a monitor using a clock with an accuracy less than memory access time can be used universally. Architecture of the Hardware Monitor System ZM4: The ZM4 monitor system is structured as a master/slave system with a control and evaluation computer (CEC) as the master and an arbitrary number of monitor agents (MA) as slaves (see Fig. <ref type="figure">1</ref>). The distance between these MA's can be up to 1,000 meters. Conceptually, the CEC is the host of the whole monitor system. It controls the measurement activities of the MA's, stores the measured data and provides the user with a powerful and universal toolset for evaluation of the measured data, which is described in Section 11-B.</p><p>The MA's are standard PC/AT-compatible machines equipped with up to 4 dedicated probe units (DPU's). We use their expandability for configuring ZM4 appropriately to the various object systems. Each MA provides processing power, memory resources, a hard disk and additionally a network interface for access to the data channel. The MA's control the DPU's and buffer the measured event traces on their local disks. The DPU's are printed circuit boards which link the MA and the nodes of the object system. The DPU's are responsible for event recognition, time stamping., event recording and for high-speed buffering of event traces.</p><p>A local clock with a resolution of 100 ns and a time stamping mechanism are integrated into each DPU. The clock of a DPU gets all information for preparing precise and globally valid time stamps via the tick channel from the measure rick generator (MTG). Time stamps in a physically distributed configuration may be adjusted after the measurement accordin,g to the known wire length. While the tick channel togeth'er with the synchronization mechanism is our own development, we used commercially available parts for the data channel, i.e., ETHERNET with TCP/IP. The data channel forms the communication subsystem of ZM4 and it is used to distribute control information and measured data. The ZM4's architectural flexibility has been achieved by two properties: easy interfacing and a scalable architecture. The DPU can easily be adapted to different object systems. Up to now interfaces have been built for SUN-4, DIRMU, Transputer, IBM PC, SUPRENUM and some embedded systems. ZM4 is fully scalable in terms of MA's and DPU's. The smallest configuration consists of one MA with one DPU (see Fig. <ref type="figure">1</ref>, left), and can monitor up to four object nodes. Larger object systems are matched by more DPU's and MA's, respectively. In the following, the DPU architecture, the event recorder and the globally synchronized clock are discussed in a top-down fashion.</p><p>DPU Architecture: The DPU's physically realize a functional separation into the three tasks of event processing: interfacing, event detection and event recording (see general DPU in Fig. <ref type="figure" target="#fig_2">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, left).</head><p>Dedicated DPU-Parts: The intetface has a tight connection to the object system, so it is not intended to be universal but dedicated to the object system. The event detector investigates the rapidly changing information supplied by the interface in order to recognize the events of interest and to supply the event recorder with appropriate information about each event. The complexity of the event detector largely depends on the type of measurement: to recognize predefined statements in a program running on a processor without instruction cache and memory management unit, a set of comparators or a memory-mapped comparison scheme suffices. If the object system uses a processor with a hardware cache, or if predefined sequences of statements are intended to trigger an event, much more complex recognition circuits will be necessary <ref type="bibr">[24]</ref>. In some cases of hybrid monitoring, the object system itself presents event tokens in form of parallel bit pattems. In this case no event detector is needed and a bitparallel interface captures the event tokens directly from the object system (see simple DPU in Fig. <ref type="figure" target="#fig_2">2</ref>, right).</p><p>The universal part of a DPU is the event recorder. It is completely independent of the object system. It receives a bit pattem from the event detector or the bitparallel interface, triggered by a signal for its occurrence.</p><p>Its functionality includes event capturing, time stamping, event record definition and event record buffering.</p><p>Universal Event Recorder: The event recorder has to fulfil two tasks: assigning globally valid time stamps to the incoming event tokens, thereby building event records, and supplying a first level of high-speed buffering. The interface between event detector or bitparallel interface and event recorder is a data path transferring the event token itself, and a control path signalling the occurrence of events. The control path mainly consists of four request lines (Reqi) and four grant lines (Gnt,), each pair ReqJGnt, servicing an asynchronous and independent event stream. That means, up to four object nodes can be monitored with only one DPU. Each of the four event streams can be furnished with an arbitrary fraction of the data field, which in total supplies 48 bits. If at least one of the request lines signals an event, the DPU's capture logic latches the data field into a 48 hit data buffer in order to establish a stable signal condition for further processing. The output of this data buffer together with the flag register (8 bit) and the clock's display register (40 bit) define a 96 bit physical event record. This is written into the FIFO memory within one 100 ns cycle of the globally synchronized clock.</p><p>Each event stream is associated with a bit (El to E4) in the flag register which indicates that its event stream contributed to a valid event. This mechanism allows to recognize the relevant part(s) of the data field and ignore the rest of it. Coincidence of events in different streams is possible. Then more than one bit in the flag register is set, meaning that their corresponding parts in the data field are valid event descriptions. There is an additional bit E, which indicates that a fifth event stream-internal to the monitor system-has generated a synchronization event from decoding Ihe information transmitted via the tick channel. The transmitted synchronization information supports a sophisticated faulttolerant protocol which allows to prove the correctness of all time stamps at the synchronization events and confirms a clock skew of less than 5 ns. This is described below.</p><p>Providing a bandwidth of 120 Megabyteds at the input of the FIFO memory, the event recorder has a peak performance of 10 million eventds. The high-speed buffering having a depth of 02 K event records helps to partly overcome the restricted bandwidth (10000 eventsk) of the monitor agent's local disc: for a short time bursts of events can be recorded and buffered in the FIFO even if the mean event rate of the disc will be exceeded by orders of magnitude. In case of a buffer overflow, a flag is set in the following event record. A second advantage of the FIFO buffer architecture is the ability to read the FIFO buffer while monitoring is going on. This enables continuous monitoring, i.e., there is no restricted maximal length of a trace. So, a high input event rate and arbitrary trace length add to the universality of this event recorder.</p><p>In order to achieve the desired global precision of 100 ns at a guaranteed accuracy, a two-level synchronization mechanism was developed, whose main blocks are shown in Fig. <ref type="figure">4</ref>. The basic PLL-level [I61 ensures that all clocks proceed at exactly the same rate and filters the synchronization signal on the tick channel, whereas the token level is responsible for the global start and stop of all clocks and allows to prove the correctness of all time stamps or to correct them in case of an error.</p><p>Coming from the tick channel, the Manchester coded signal MT (100 kHz) is split into two paths. The left one leads to the PLL-level which consists of a clock separator responsible for converting the Manchester coded signal into a coherent square wave signal that can be used as a reference for the following PLL-circuitry (right output). Additionally, the clock separator checks the validity of the input signal and opens the PLL's control loop (via the switch, left output) if an error is detected. In this case the local oscillator VCO which was previously correctly synchronized will not be forced to deviate from this correct frequency.</p><p>The PLL-circuitry is formed by a loop with the following components: a phase comparator which generates a signal proportional to the difference between the MT and the output of the PLL-circuitry, followed by the switch, followed by the loop-filter, which uses the phase difference for adjusting the VCO's frequency. The VCO's output on the one side feeds the clock input of the display register, which can be turned on (or off) by MTDEC depending on the token received on the tick channel. On the other side, the VCO's output is fed into a frequency divider which generates the necessary signal for comparison with the reference square wave derived from MT.</p><p>With this PLL-frequency multiplier the data transfer rate on the tick channel can be chosen to meet specifications for lowcost cabling and interfacing, without significantly affecting the clock's precision. A theoretical analysis of this scheme and additional measurements both confirm a skew of the clocks in the order of five nanoseconds in the worst case.</p><p>Based on the PLL-level, the token level decodes the Manchester coded MT as follows: the output signal of the frequency divider is fed into the phase shifter SHIFT(pi12) in order to generate a signal for sampling the MT with a timing suitable for retrieving the binary information in every cycle of MT. This binary data stream is shifted into a shift register within MTDEC and compared to a set of predefined token values. If one of these values is detected, the appropriate action will be executed, e.g., the start token leads to starting the display counter, and the stop token stops it.</p><p>Under normal conditions, this hardware part of the clocking scheme ensures a robust global time scale. But in spatially distributed systems, problems can arise from cabling or electromagnetic influences. In order to quickly recognize problems and to prove their absence, this scheme is enhanced by the concept of synchronization events: after fixed time intervals the MTG broadcasts tokens, called sync-token, which are recorded by the event recorder in the same manner as regular  events from the object system (E,-bit in the flag field). The time stamp assigned to such a synchronization event is known a priori because of the fixed intervals for generating them.</p><p>This feature provides the ability to prove the correctness of all time stamps at such synchronization events. Supervising the state of the synchronization and recording this in the flag field for each event, too, allows the extension of the proof to any event between two synchronization events. Additionally, error recovery for corrupted time stamps is possible, because the differences are known at the synchronization events. ZM4 in Relat,ion to Other Monitor Systems: Table <ref type="table" target="#tab_2">I</ref> illustrates how the features of the ZM4 architecture are related to some other interesting monitor concepts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NON-INVASIVE MONITOR:</head><p>Tsai et al. describe a monitor system which i,s called a Non-Invasive Monitor. It is aimed at monitoring of multi-microprocessors based on the MO-TOROLA 68000, which neither use virtual addressing with memory protection nor caching mechanisms <ref type="bibr">[42]</ref>. This monitor works with a shadow-processor for each processor in the object system. Once armed, it is loaded with the internal status of the object processor and then runs in parallel with it. After the specified trigger condition is met, the status of the shadow processor, which is identical with the status of the object processor, can be investigated without disturbing the object system. The aiming for the next investigation is done by issuing an interrupt to the object processor, which tramfers its internal status to the shadow processor. The authors restrict the range of possible investigations to software without dynamic resources, and there is no discussion how to establish a global view of the object system.</p><p>The advantages and drawbacks of hardware, software and hybrid monitoring are analyzed by Mink et al. <ref type="bibr">[32]</ref>. The authors state that hybrid monitoring permits investigations which are not possible with pure hardware monitoring, e.g., when caches are involved. They prefer hybrid monitoring since it causes little interference on the object system. Their monitor system is built of measurement nodes which collect data. They are interconnected by a VME bus with a central analysis computer. A measurement node consists of a set of VLSI chips, responsible for gathering the eventdefining information from the object system, time stamping the generated event records and data buffering. As a special feature, event counters are implemented in one of the VLSI chips in order to reduce the amount of data to be transferred and evaluated. With a time resolution of 100 ns, this monitor system allows to correctly order all communication events in locally concentrated multiprocessor systems.</p><p>At the CSRD a highly modular and flexible hardware monitor system (BLACKBOX) designed for the CEDAR multiprocessor system was built <ref type="bibr">[30]</ref>. It comprises modules for such different tasks as signal conditioning, counting, timing and data logging. The locally concentrated monitor system provides a high resolution global time base. It can record buffered versions of internal signals (hardware monitoring) as well as software controlled signals (hybrid monitoring). The monitor is generally configurable to the type of measurement experiment desired. For example, one module can be configured as an interval timer and another as a counter. In addition to the BLACKBOX monitor, CEDAR has a comprehensive set of other instrumentation and monitoring facilities, including parallel profiling and software tracing. Some basic performance measurements of CEDAR are described in <ref type="bibr">[17]</ref>.</p><p>NETMON-II: NETMON-I1 1131 is a hybrid monitoring tool for distributed and multiprocessor systems. It is a distributed masterhlave system with monitor stations (slaves) and a central control station (master). Each monitor station contains a monitoring unit, a load generation unit and a network interface for the communication with the central station, responsible for controlling the measurement and for data evaluation. The monitoring unit is implemented as an addon board for PC's, which is dedicated to hybrid monitoring, and has an 8 bit wide Centronics printer port as an interface to BLACKBOX:</p><p>the object system. Thus, interfacing, event detection and event recording, i.e., all tasks of a monitor node, are combined on one board. An autonomous clock with a resolution of 8 ps is part of each monitoring unit, making the monitor suitable for object systems which communicate via SendReceive mechanisms. In order to establish a global timebase, these clocks are corrected every 15 ms via the time channel which connects all monitoring units. As this correction is carried out by directly accessing registers from a signal which is transmitted via LAN distances, erroneous corrections due to spikes on the time channel can occur. <ref type="bibr">ELAN [8]</ref> was one of the first monitoring projects to deal with high-level monitoring tools. It was aimed aL the experimental multiprocessor M3 which is a locally concentrated machine and needs no global clock.</p><p>The original goal of the TOPSYS monitor system was to gather information for debugging purposes. Later, performance aspects were included. TOPSYS uses a 80386 bond-out chip for implementing the measurement interface. It has been used for monitoring nodes of an iPSC/2 configuration I71.</p><p>TMP <ref type="bibr">[44]</ref> is a hybrid monitor consisting of many TMP nodes which are connected via the TMP network to a central monitor station. The TMP nodes can monitor object nodes and object communication activities. The instrumentation philosophy "... to view monitor and measuring as an integral and permanent part of any computer system" corresponds to our philosophy of restricting measurement to a small set of essential events. TMP has no global clock.</p><p>This short summary of recent monitors shows that many approaches tend to prefer event-driven hybrid monitoring and that several authors suggest a monitor architecture with many monitoring nodes and one central computer for data collection.</p><p>ZM4 is distinguished from other approaches by the following features:</p><p>the modular design of interfacing, detection and time stamping has proved to be adaptable to arbitrary object systems with small expense; a global clock mechanism which guarantees high resolution / precise synchronization over large distances; a global clock transmission code which supports detection of synchronization errors in the DPU's. Several performance measurements with ZM4 (e.g., <ref type="bibr">[29]</ref>, <ref type="bibr" target="#b32">[36]</ref>) proved that the ZM4 architecture is flexible and efficient. However, these experiences also show that a well working monitor needs to be accompanied by an evaluation environment which supports program instrumentation (event definition), provides a monitor-independent and problem-oriented event trace description and offers powerful tools for event trace evaluation. The following section addresses the problem of event trace description and analysis. Tools for program instrumentation are discussed in Section IV-A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ELAN: TOPSYS: TMP: B. SIMPLE-A Pegormance Evaluation Environment</head><p>SIMPLE (Source-related and Integrated Multiprocessor and -computer Performance evaluation, modeLing and visualization Environment) is a tool environment designed and implemented for analysis of arbitrarily formatted event traces.</p><p>It runs on UNIX and MS-DOS systems. SIMPLE has a modular structure and standardized interfaces. Therefore it is easily extendible, and tools which were developed and implemented by others can be integrated into SIMPLE with little effort.</p><p>The Concept for a General Logical Structure of Measured Data-the Basis for Independence of Measurement and Evaluation: The design and implementation of an evaluation system for measured data is too complex and expensive a task to be done for one special object system or one monitor system only. The three following requirements are essential to make the evaluation system capable of efficiently handling measured data produced by event-driven monitoring of parallel and distributed computer systems.</p><p>Object System Independence: there are many differences in structure and function of the systems to be monitored, e.g., in the node architecture and in the configuration of the interconnection network. There is a variety of operating systems and applications. An evaluation system should be applicable to the measured data coming from all these differently configured computer systems, offering a wide variety of functions.</p><p>Monitor Independence: the measured data, recorded by different monitor devices, should be accessible in a uniform way, even if it is differently structured, formatted and represented. Source Reference: data recorded by monitor systems is usually encoded and compressed. But during analysis and presentation of data, users want to work with the problemoriented identifiers of hardware and software objects of the monitored system. Our approach to fulfilling these requirements is to consider the fundamental structure of the measured data because this is what the evaluation system sees of the monitored system. All requirements mentioned are related to the structure, format, representation and semantics of the measured data. In order to abstract from these properties we developed a general logical structure for all the different types of measured data. This logical structure can then be used to define a standardized access method to the measured data. Using event-driven monitoring, the proposed general logical structure can focus on a general logical event trace structure. This structure of an event trace is given in Fig. <ref type="figure" target="#fig_5">5</ref>. It relies on the fact that measurements store the physical event records sequentially in a file (event tracejle), resulting in a sequence of event records sorted according to increasing time. A section in the event trace which has been continuously recorded is called a trace segment. A trace segment describes the dynamic behavior of the monitored system during a time interval in which none of the detected events was lost. The knowledge of segment borders is important, especially for validation tools based on event traces. Usually each trace segment begins with a special data record, the so-called segment header, which contains some useful information about the following segment, or is simply used to mark the beginning of a new trace segment. The segment header is followed by an arbitrary  TDUPOET--A Basic Tool for Accessing Measured Datu: Based on the general logical event trace structure, we designed and implemented the access tool TDLPOET in order to meet the mentioned requirements. The basic idea is to consider the measured data a generic abstract data structure. The evaluation system can access the measured data only via a uniform and standardized set of generic procedures. Using these procedures, an evaluation system is able to abstract from difierent data formats and representations and thus becomes independent of the monitor device(s) and of the monitored object systems The tool consists of the three components POET, TDL arid FDL 1341, see Fig. <ref type="figure" target="#fig_6">6</ref>: TDL (Trace Description Language): the language TDL is designed for a problem-oriented description of' event traces. The compilation of a TDL description into a corresponding binary access key file has the advantage that syntactic and semantic correctness is checked once and before evaluation. The development of TDL had two principal aims: the first was to make a language available which clearly and naturally reflects the fun-damental structure of an event trace. The second was to enable even users not familiar with all details of the language to read and understand a given TDL description.</p><p>In addition, a TDL description provides a documentation of the performed measurement. POET (Problem Oriented Event Trace Interface): the POET library is a monitor-independent function interface which enables the user to access measured data stored in event trace files in a problem-oriented manner. In order to be able to access and decode the differently structured measured data, the POET functions use the access key file which contains a complete description of formats and properties of the measured data. For efficiency, the key file is in a binary and compact format. In addition, the access key file includes the user-defined (problemoriented) identifiers for the recorded values, enabling the required source reference. The third component, FDL, extends the capabilities of TDLPOET by allowing user-defined views on the measured data.</p><p>FDL (Filter Description Language) is an approach similar to TDL. It is used for specifying rules for filtering event records depending on the values of their record fields.</p><p>The problem-oriented identifiers of the TDL file are also used for filtering. A prototype of the tools TDLPOETFILTER was designed and implemented in 1987. A redesign took place in 1991 (version 5.2). The tools enable us to analyze event traces which were recorded by ZM4 or other monitor systems such as network analyzers, logic analyzers, software monitors, or even traces generated by simulation tools. POET is an open interface. This means that the user can build his own customized evaluation tools using the POET function library.</p><p>Rating of the TDUPOET Approach Configuration files or some sort of data description language are often used in order to make a system independent of the format of its input data. Our work on TDL was inspired by the IS0 standard ASN. I (Abstract Syntax Notation One), which is used in some protocol analyzers to describe the format of the data packets. A similar approach to describe and filter monitoring data was used by <ref type="bibr">Miller et al. in the DPM project (Distributed Program Monitor)</ref>  <ref type="bibr" target="#b28">[33]</ref>. Their language allows the description of name, number and size of the components in an event record. The description of trace structures such as segments and of the physical representation of data values is not supported. Its main targets are distributed systems with SendReceive communication.</p><p>In our opinion, the most important work on describing events was the definition of the event trace description language EDL by <ref type="bibr">Bates and Wileden [9]</ref>. They also introduced the term behavioral abstraction. Their work inspired many others, among them our group. The main purpose of EDL is the definition of complex events out of primitive events. In EDL, attributes of the primitive events can be defined, but not their format or representation <ref type="bibr" target="#b2">[3]</ref>. Finally, a word on standardization: at the moment, efforts are taken to standardize the format of physical event traces for debugging and evaluation systems <ref type="bibr" target="#b39">[43]</ref>. We feel that standardization of the physical event trace format is not the right approach. No standard format can be flexible enough to represent all possible event trace formats unless format information is included in the trace. Furthermore, there is a great variety of existing (hardware) monitors which cannot produce a standardized format. Therefore, many conversion programs would have to be implemented. The TDLPOET interface shows that a generalized access method for arbitrary event traces works well without requiring standardized physical formats. So, we plead for standardizing the event trace access interface instead of standardizing the trace format.</p><p>This section gives a short overview of the main components and the flow of data within the SIMPLE environment (see Fig. <ref type="figure" target="#fig_7">7</ref>). For a more complete discussion and an application example see Wl.</p><p>Using a distributed monitor system results in several independent event traces. The first evaluation step is to generate a global event trace (tool MERGE) in order to get a global view of the whole object system. MERGE takes the local event trace files and the corresponding access key files as an input and generates a global event trace and the corresponding access key file. In the global trace, the event records of the local event traces are sorted according to their time stamps.</p><p>Trace Validation: The next step is often forgotten but nevertheless necessary. Before doing any trace analysis it should be tested whether the measurement was performed cmectly. The tool CHECKTRACE performs some simple standard tests which can be applied to all event traces. The tool VARUS ( Validating Rules checking System) enables the user to specify some rules in a formal language (assertions) for validating the event trace. Trace validation in the context of model-driven monitoring is discussed in Section IV.</p><p>There are two standard tools for trace analysis. The tool LIST for the generation of readable trace protocols and the tool TRCSTAT for computation of frequencies, durations and other performance indices. For more complex investigations the measured data can be analyzed interactively using the data analysis package S from AT&amp;T [5] and analyzed via the TDLPOET interface. Typical results are histograms or pie charts. Time-state diagrams (Gantt-charts) are generated with the tool GANTT.</p><p>The dynamic visualization of an event trace presents the monitored dynamic behavior at a speed which can be followed by the user, exposing properties of the program or system that might otherwise be difficult to understand or might even remain unnoticed. The tools SMART (Slow Motion ilnimated Review of Traces), which can be used on any character-oriented terminal, and VISIMON, which offers enhanced graphics capabilities and is based on X -Windows, support the layout of the animation in an animation description language.</p><p>Trace Animation:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="111.">MONITORING PROGRAM BEHAVIOR ON SUPRENUM</head><p>We have already gained experience using our tools in several different environments. For example, we have used ZMWSIMPLE to analyze a communication system for Transputer networks <ref type="bibr" target="#b32">[36]</ref> and a high-speed LAN [29]. In this section we describe how the ZM4 hardware monitor and the SIMPLE tools were used to analyze the behavior of a parallel program on the SUPRENUM multiprocessor.</p><p>SUPRENUM <ref type="bibr" target="#b3">[41]</ref>, [4] is a loosely coupled parallel architecture consisting of up to 256 processing nodes. Each node has a CPU, 8 MBytes of memory and several coprocessors (among them a vector processing unit). Nodes are grouped in clusters of size 16, and the interconnection network is a two-level bus system: processors within the same cluster communicate via a fast parallel cluster bus, whereas intercluster communication is done via the torus-shaped serial SUPRENUM bus system. There is a seven segment display on each of SUPRENUM's processing nodes which, under normal operating conditions, displays the internal state of communication firmware. We use the seven segment display to output measurement data. Since the seven segment display can only display 16 different patterns (due to limitations of the driving hardware), we devised a scheme for outputting 48 bits of event data sequentially in portions of size 3 bits. An event detector was built whose probes are plugged into the socket of the seven segment display on one side and which connects to the event recorder of ZM4 on the other side (see Fig. <ref type="figure" target="#fig_8">8</ref>). The event detector reassembles the original 48-bit events which are then written to the FIFO buffer of the ZM4 event recorder.</p><p>The parallel program under study is a ray tracer. Ray tracing [18] is a computer graphics method for generating highquality images from formal descriptions of a scene. For the scope of this paper, the reader need not be familiar with ray tracing. In the implementation considered here, the algorithm is parallelized in the following way: there is one master who does administrative work, distributes jobs to an arbitrary number of servants. receives the results and writes them to an output file. The: master communicates with all of the servants by message passing, but there is no communication between any two servants. Servants receive a job, work on the job (this involves mainly geometric intersection computations) and return the results to the master. One job only constitutes a small fraction of the total work to be done. The basic structure of the master and servant processes is shown in Fig. <ref type="figure" target="#fig_9">9</ref>. A window flow control scheme is employed to ensure that each servant always has work to do: initially the master has a fixed number of credits from each servant. The master keeps sending jobs to a servant (thereby decrementing the servant's credit count) as long as there are credits from that servant available. With every result a servant returns one credit to the master. Good load balancing is achieved by this dynamic job assignment and by choosing a small job size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Evolution qf the Parallel Program</head><p>We started by monitoring a basic version of the ray tracing program in which SUPRENUM's mailbox mechanism was used for the communication between the master and the servants. Mailboxes were used in order to avoid blocking of the sender while the receiver is not ready to receive the message. The sender of a message does not hand over the message to the receiver during a rendezvous as in synchronous communication, but puts the message in the receiver's mailbox from where the receiver can pick up the message at a later time. Monitoring a run of this version of the ray tracing program in which the program was running on 16 processors (Le., there are 15 servants) revealed that the servant processor utilization was only about 1596, which means that the servant processors spent Fig. <ref type="figure">10</ref> shows a Gantt-chart obtained from evaluating a measurement of the ray tracing program during which the ray tracer was running on two processors only, the master and one servant. In the chart, the activities of the master and the servant are shown over a common time axis.</p><p>One can observe in the chart that the master goes through the following activities in a cyclic fashion: the activities "Distribute Jobs" <ref type="bibr" target="#b0">(1)</ref> and "Send Jobs" ( 2 ) are followed by a "Wait for Results" activity <ref type="bibr" target="#b2">(3)</ref>. Then results computed by the servant are received ("Receive Results", 4) which is followed by the next "Distribute Jobs" activity (5). Since a window flow control scheme is employed to control the number of outstanding jobs, the results received are not the results for the job just sent but for a previous job. Some of the master's cycles also contain a "Write Pixels" activity (6), during which results are written to the output file. Writing to the output file is not done in each of the master's cycles. This is because pixels have to be written to the output file in correct order. Results may not be received in the order in which the corresponding jobs have been sent, because the time to process a job varies considerably. Writing to the output file takes place whenever a continuous stretch of pixels has been processed.</p><p>We can observe from the chart in Fig. <ref type="figure">10</ref> a major drawback. We see that the transition from "Send Jobs" to "Wait for Results'' (2 -+ 3 ) on the master processor can only take place synchronously with the transition from "Work" to "Wait for Job" (7 -+ 8) on the servant processor. Contrary to what we expected, the master becomes blocked during the "Send Jobs" activity, which is exactly what was to be avoided by using mailbox communication. A lot of time is wasted during the "Send Jobs" activity.</p><p>The reason for this behavior is as follows: with SUPRENUM, a mailbox is a light-weight process owned by the receiving process and running together with the receiving process on one processor in a time-sharing manner. The scheduling strategy used is round robin. However, instead of using time slices each process is allowed to run until it becomes blocked. The master cannot finish his "Send Jobs" activity because he can put a message in the servant's mailbox only if this mailbox process is actually running. This is not the case until the servant relinquishes the processor because he is waiting for a message. Thus, (asynchronous) mailbox communication behaves like synchronous communication. As a result for the ray tracing application, the master cannot keep 15 servants busy because he is spending too much time being blocked while sending jobs to the servants.</p><p>Having observed this behavior, we decided to implement our own asynchronous communication in order to overcome the bottleneck at the master. For the communication from the master to the servants we introduced a pool of light-weight processes which we call communication agents. They are running on the masler processor and communicate with the master via shared variables. When the master wishes to send a message (i.e., a job) to one of the servants, he indicates this to an agent who is currently</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Version 2-Communication Agents:</head><p>Versions 3 and 4-Reducing Total Communication Volume and Further Tuning: Monitoring program version 2 showed that there were no significant waiting times at the master, i.e., the master is busy all the time. However, monitoring the servants over a longer period of time showed that the servants were busy only about 29% of total time. The servants spend the rest of the time waiting for a message (another job) from the master. We decided to reduce the total volume of communication by increasing the job size. So far a job consisted of only a single pixel, which is certainly not a good choice. By sending jobs containing 50 pixels, the total number of messages is reduced by the factor 50. A job consisting of 50 pixels is still only a very small fraction of the total work to be done (256 K pixels have to be processed for a 512 by 512 image), and therefore load balancing is not impaired by this step. Measurements showed that this improved the utilization of the servants to about 46%.</p><p>After further tuning which was suggested by the measurements and included the adjustment of some internal program constants, the program achieved a 60% servant utilization. Fig. <ref type="figure">11</ref> shows the improvement of the servant utilization. Servant utilization is a key performance measure for this application. It is directly correlated with execution time which was reduced by a factor of about 4 from version 1 to version 4. It should be mentioned that the scene used for all the above measurements is of moderate complexity only, which means that there is relatively little work to be done per pixel, resulting in a high communication overhead. Therefore this test scene constitutes a difficult test candidate for the ray tracing program. However, we needed a test scene like this since we wanted to locate all the possible bottlenecks in the program. We verified that the program performs significantly better when processing more complex scenes (over 90% servant utilization was achieved with a complex scene) which is a more realistic workload.</p><p>unemployed. If all agents are busy a new agent is created and added to the pool. It is the agent's task to forward the master's I v . CURRENT WORK AND CONCLUSION message to the servant. Communication between the agent and the servant is synchronous, i.e., no mailboxes are used. It is the advantage of this scheme that the master can proceed with his work, while the agent becomes blocked until the receiving servant is ready to accept the message.</p><p>We have presented a modern and powerful tool environment which has been successfully used in numerous applications, among them the study described above. We will now discuss our current research on the integration of monitoring and modeling. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Model-Driven Monitoring</head><p>In order to define events systematically one needs knowledge about the aim of measurement and about the functional behavior of the system to be analyzed. We agree with Nutt's statement <ref type="bibr" target="#b31">[35]</ref>: "The most important questions to be answered before attempting to monitor a machine are what to measure and why the mmsurement should be taken." Already in 1981, <ref type="bibr">Kobayashi postulated [26]</ref>: "The system tuning requires a clear understanding of the complex interactions among the individual system components. A systematic procedure of performing this task is yer to be developed." In <ref type="bibr" target="#b34">[38]</ref> there is a whole chapter titled '"The Event Collection Problem." These citations show that it is difficult for a designer or programmer to do monitoring systematically and efficiently.</p><p>Our idea of performance evaluation, tuning and debugging is to integrate modeling and monitoring to a comprehensive methodology. When using event-based models (e.g., graph models [40], Petri nets [l], queueing network models [25] or formal specifications like CSP [22] or EXL <ref type="bibr">[20]</ref>) which explicitly model the functional interdependence of activities, and event-driven monitoring, there is a common abstraction-the event-which enables us to integrate both methods. Both in modeling and monitoring, important points are represented as events of interest, and the overall dynamic behavior as an event trace. Due to this very close connection between the flow description in modeling and monitoring it is desirable to use the same set of events for modeling and monitoring.</p><p>Since not every detail of the functional model (e.g., a formal specification), which is used for implementing the program, is of interest in terms of performance evaluation and program analysis, the analysis of the program is carried out on a different level of abstraction. For monitoring purposes, the socalled monitoring model is created. This model is derived from the functional model considering the aim of measurement. It is a subset of the functional model, i.e., it covers some but not all details of the functional model. In the monitoring model the functional dependencies of the implemented program are described on the level of abstraction on which the program should be monitored.</p><p>Model-Driven Instrumentation: Model-driven instrumentation guarantees by construction the same set of events in the instrumented program and in the model. The monitoring model forms the basis for the instrumentation (see Fig. <ref type="figure" target="#fig_2">12</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Integration of Monitoring and Modeling:</head><p>There is a one-to-one mapping between the model events and the monitoring events. After specifying instrumentation points in the model, a command file for an automatic instrumentation tool is generated. All activities represented in the model will be instrumented in the program at their entry and all exit points [27]. The difficult questions "Which events should be defined?' and "Where should the program be instrumented?' are implicitly answered by building the monitoring model.</p><p>Model-driven program instrumentation offers the following advantages over intuitive instrumentation.</p><p>Instrumentation need no longer be an intuitive action, but may be executed systematically. Therefore, instrumentation can be carried out automatically with the support of tools.</p><p>Instead of a fault-prone manual re-instrumentation of the program in each design phase, it suffices to modify the model. Then an automatic instrumentation of all model activities is carried out. The monitored event trace can be validated in a systematic way. This leads to automatic, model-driven event trace validation.</p><p>The interpretations of the instrumented event tokens are known. This knowledge of the event semantics can be used to generate an event trace description in TDL (cf. Section 11-B) automatically, allowing automatic event trace evaluation and program animation.</p><p>The monitoring model can be transformed into a performance model by adding timing and frequency attributes (e.g., run-time distributions and transition probabilities). These attributes can be derived from a measured event trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Measurement, Validation, and Evaluation:</head><p>Model-driven instrumentation (Fig. <ref type="figure" target="#fig_2">12</ref>) is the foundation for model-driven monitoring. After instrumentation, the instrumented program can be executed and monitored which produces an event trace as a result. As the sets of events used in modeling and monitoring are the same, the monitoring model can be used for validating the dynamic behavior of the program. Validation is necessary in order to draw correct conclusions. A simple form, such as checking whether time stamps are increasing or whether the set of monitored event tokens is correct, is addressed in Section 11-B.</p><p>Based on the monitoring model, the monitored behavior represented in the event trace is checked against the functional behavior of the model (model-driven event trace validation). The set of possible event sequences is defined by the model. During validation, it is checked systematically whether the behavior represented in the monitored event trace is a possible occurrence sequence in the model. This kind of validation provides hints for finding program errors (see Fig. <ref type="figure" target="#fig_13">13</ref>, arc from validation to program). If the recorded event trace matches the monitoring model the trace can be used as a base for evaluation. For tool-supported automatic event trace validation the existing modeling tools PEPP (graph models) 1121 and GreatSPN (Petri nets) [lo] were extended.</p><p>There are some other debugging tools for checking a specification against an event trace: the debugger ESCP can only check specified communication behavior and hierarchical fork-join parallelism, and with the TSL system [21] a specification is automatically checked against events generated by an Ada tasking program. As with our approach of modeldriven validation, TSL also requires a linearly ordered event trace.</p><p>The results of the trace evaluation allow the computation of performance indices of the measured program. They can be used for creating a p e ~o r m a n c e model. Runtime distributions and branching probabilities will be assigned to the activities of the monitoring model. The performance model is a prerequisite for predicting the performance of not yet implemented program versions, process mappings or other computer configurations. The use of measured data means model evaluation with realistic parameters and therefore relevant results.</p><p>Summary: In model-driven monitoring the monitoring model is used for program instrumentation, event trace validation, and for creating a performance model. The modeldriven approach enables us to instrument arbitrary statements in the program under investigation on the desired level of abstraction. So, the overhead caused by instrumenting all procedures as in <ref type="bibr" target="#b1">[2]</ref> can be significantly reduced. Also, monitoring is not restricted to inter-process communic;ition as it is done in [19], <ref type="bibr">[23]</ref>. In addition to debugging and tuning (critical path analysis [31]), the integration of modeling and monitoring enables us to carry out automatic event trace validation and performance prediction of not yet available systems and implementations.</p><p>The following references illustrate that model-driven monitoring is independent of the modeling paradigm. In <ref type="bibr">[27]</ref>, the automatic, model-driven instrumentation of a parallel multigrid algorithm based on a stochastic graph model is described. The graph model can be generated and evaluated by the tool PEPP (Performance Evaluation of Parallel Programs) which provides a command file for model-driven instrumentation with AICOS (Automatic Instrumentation of C Object Software) [ 121. Furthermore we have experiences appl) ing the method to queueing network models: the dynamic behavior of a communication system for Transputer networks was modeled and monitored <ref type="bibr" target="#b32">[36]</ref>, <ref type="bibr" target="#b35">[39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>In this paper, we discussed event-driven monitoring, a technique which is very well suited for analyzing the functional behavior and the performance of parallel and dislributed systems. We presented the scalable distributed hardware monitor ZM4 and the SIMPLE package. Practical use of ZM4 confirmed that it can easily be adapted to arbitrary object systems and that the global time stamps are extremely helpful when analyzing concurrent activities on more than one node of a distributed system. SIMPLE is a highly flexible and comfortable tool with which all kinds of event traces (not only traces recorded by ZM4) can be evaluated. The concepts of object system independence and of integrating tools for modeling, monitoring, and trace evaluation proved to be a big step forward. As an application of our monitoring and evaluation system, the paper includes a case study in which a parallel ray tracing program running on the SUPRENUM multiprocessor is analyzed. Monitoring helped to detect unexpected program behavior and to locate bottlenecks whose removal resulted in a dramatic improvement of the ray tracer's performance. Methods such as ZM4/SIMPLE are a valuable aid to designers and users of parallel and distributed systems.</p><p>Finally, we described how event-driven monitoring and event-based modeling can be integrated into one methodology because they both rely on the same abstraction of the dynamic behavior: the event. Integration makes it possible to carry out program instrumentation systematically and with the help of tools, thereby helping to avoid errors which can easily occur in manual instrumentation. We also explained how a model can be validated by comparing it to the sequence of events in a monitored event trace.</p><p>We wish to further test and improve our concepts and tools for integrating monitoring and modeling. Validating not only the functional aspects of a model but also considering time information is a challenging topic. Our current research also includes building a performance model of the parallel ray tracing program described in Section 111. It will be possible to validate the model by comparing it to event traces of the program. The model will enable us to predict the runtime of the program on a larger number of processors. R. Hofmann received the diploma degree in electrical engineering from Friedrich Alexander University in Erlangen in 1985 and the Ph.D. degree in 1992 with a work on secure temporal relationships for the analysis of parallel and distributed systems.</p><p>After joining the performance evaluation group, he developed the ZM4 hardware monitor system. His main research interests include monitoring, development of electronic circuitry, basic problems and algorithms of computer systems, especially the consequences of causal and temporal relationships, and clock synchronization. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. I .</head><label>I</label><figDesc>Fig. I . Distributed architecture of ZM4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Monitor agent equipped with DPU's</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Universal event recorder.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. General event trace structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Event trace access with TDL/POET/FILTTER</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Evaluation with SIMPLE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>.Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The interface between SUPRENUM and ZM4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Basic structure of master and servant processes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>about 85% of total time waiting for a job to arrive. This lead us to analyze the program's behavior in more detail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .Fig. 11 .</head><label>1011</label><figDesc>Fig. 10. Behavior of the mailbox communication (ray tracer on two processors).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Fig. 12. ModeMriven instrumentation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Model-driven monitoring.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Rainer</head><label></label><figDesc>Klar studied physics at the universities of Saarbruecken and Berlin. As a senior student he joined Wolfgang Haendler in 1963 and developed one of Germany's first computer hardware labs at German universities. In 1965 he received his diploma at the University of the Saarland, Germany. He then switched to the field of computer architecture and received the Ph.D. degree in computer science from the University of Erlangen, Germany, in 1971 with a work on hardware monitoring. Since 1981, he has been a Senior Researcher at the Institute of Computer Architecture at the University of Erlangen. His research interests include microprogramming, hardware description languages and performance evaluation of multiprocessor systems and parallel systems, especially hardware monitoring of multiprocessor systems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Duda et al. describe a mechanism to estimate a global time from local observations in systems communicating via message passing [ 1 I]. Systems communicating via shared variables lack this easy mechanism to globally order events and to derive a global time. As the read-access to a shared variable can immediately follow the (state-changing) write-object system),</figDesc><table><row><cell>data channel</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Globally Synchronized Clock: Object Monitoring Global view technique accepts events hybrid monitoring resolution 100 ns from arbitrary cbdc error objects wrreclion</head><label></label><figDesc></figDesc><table><row><cell>Distribution</cell><cell>independence</cell><cell></cell><cell></cell></row><row><cell>LAN distance</cell><cell>yes</cell><cell>hardwareand</cell><cell>yes</cell></row><row><cell>multiprocessor</cell><cell>no</cell><cell>hardwara</cell><cell>no</cell></row><row><cell></cell><cell cols="2">interface dedicated moniloricg</cell><cell></cell></row><row><cell></cell><cell>lo 680x0</cell><cell></cell><cell></cell></row><row><cell>multiprocessor</cell><cell>partly intended for</cell><cell cols="2">hybrid monitoring yes resolulion 100 ns</cell></row><row><cell></cell><cell>80x86. 680x0.</cell><cell></cell><cell></cell></row><row><cell></cell><cell>32x32</cell><cell></cell><cell></cell></row><row><cell>multiprocessor</cell><cell>currently</cell><cell>hardware and</cell><cell>yes</cell></row><row><cell></cell><cell>dedicated to</cell><cell cols="2">hybrid monitoring resolution 85 ns</cell></row><row><cell></cell><cell>CEDAR</cell><cell></cell><cell></cell></row><row><cell>LAN distance</cell><cell>yes</cell><cell cols="2">hybrid monitoring yes</cell></row><row><cell></cell><cell></cell><cell></cell><cell>resolution 8 0s</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell cols="2">tick channel I / + / MTG VRS-485-repeater to next eweni recordrr</cell><cell></cell><cell></cell></row><row><cell>I</cell><cell></cell><cell></cell><cell></cell></row><row><cell>/ '</cell><cell>MT ( I 0 0 kHz)</cell><cell></cell><cell></cell></row><row><cell>separator</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>phase-</cell><cell></cell><cell></cell></row><row><cell></cell><cell>MTDEC</cell><cell></cell><cell></cell></row><row><cell>display: 40 bit counler</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>TMP</cell><cell>LAN distance</cell><cell>yes</cell><cell>hybrd monitoring no</cell></row><row><cell></cell><cell></cell><cell>University of</cell><cell></cell><cell>implemented for a</cell></row><row><cell>Ii",&lt; "p</cell><cell>sync-event</cell><cell>Kaiserslautern</cell><cell></cell><cell>680x0 proc. bus</cell></row><row><cell>Fig. 4.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Synchronization mechanism for global clock.</head><label></label><figDesc></figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>His research interests include performance evaluation, in particular large Markovian models and their efficient analysis, and parallel processing.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A class of generalized stochastic Petri nets for the performance evaluation of multiprocessor systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ajmone Marsan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Balbo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Conte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Quartz: A tool for tuning parallel program performance</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">D</forename><surname>Lazowska</surname></persName>
		</author>
		<idno>TR # 89-10-05</idno>
	</analytic>
	<monogr>
		<title level="j">Dept. of Comput. Sci., Univ. of Washington</title>
		<imprint>
			<date type="published" when="1989-09">Sept. 1989</date>
			<pubPlace>Seattle, WA</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Debugging heterogeneous distributed systems using eventbased models of behavior</title>
		<author>
			<persName><forename type="first">P</forename><surname>Bates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices, Workshop on Parallel and Distrib. Debugging</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="22" />
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parallel conjugate gradient algorithms for solving the neutron diffusion equation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bohm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Brehm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Finnemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Int. Con$ on Supercomputing</title>
		<meeting><address><addrLine>Cologne</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-06">June 1991</date>
			<biblScope unit="page" from="163" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The New S Language, a Programming Environment for Data Analysis and Graphics</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Wilks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">N</forename><surname>Baiardi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Defranco</surname></persName>
		</author>
		<author>
			<persName><surname>Vaglini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng., SE</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="547" to="553" />
			<date type="published" when="1986">1988. Apr. 1986</date>
			<publisher>Wadsworth 8z Brooks/Cole Advanced Books &amp; Software</publisher>
			<pubPlace>Pacific Grove, CA</pubPlace>
		</imprint>
	</monogr>
	<note>Development of a Debugger for a Concurrent Language</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The distributed monitor system of TOPSYS</title>
		<author>
			<persName><forename type="first">T</forename><surname>Bemmerl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lindhof</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Treml</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CONPAR 90-VAPP IV, Joint Int. Con5 on Vector and Parallel Processing</title>
		<editor>
			<persName><forename type="first">H</forename><surname>Burkhart</surname></persName>
		</editor>
		<meeting>CONPAR 90-VAPP IV, Joint Int. Con5 on Vector and Parallel essing<address><addrLine>Ziirich, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-09">September 1990</date>
			<biblScope unit="page" from="756" to="764" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Performance measurement tools in a multiprocessor environment</title>
		<author>
			<persName><forename type="first">H</forename><surname>Burkhart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Millen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="725" to="737" />
			<date type="published" when="1989-05">May 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A basis for distributed system debugging tools</title>
	</analytic>
	<monogr>
		<title level="j">Hawaii Int. Con5 on Syst. Sci</title>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">C</forename><surname>Bates</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Wileden</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<date type="published" when="1982">1982</date>
			<pubPlace>Hawaii</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">CreatSPN 1.5 software architecture</title>
		<author>
			<persName><forename type="first">G</forename><surname>Chiola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 5th lnt. Con5 on Modelling Techn. and Tools for Comput</title>
		<editor>
			<persName><forename type="first">G</forename><surname>Balbo</surname></persName>
		</editor>
		<meeting>5th lnt. Con5 on Modelling Techn. and Tools for Comput<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science Publisher B. V</publisher>
			<date type="published" when="1991">1991</date>
			<biblScope unit="page" from="117" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Estimating global time in distributed systems</title>
		<author>
			<persName><forename type="first">A</forename><surname>Duda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Harrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Haddad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Con</title>
		<meeting>7th Int. Con<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987-09">Sept. 1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">PEFP Performance evaluation of parallel programs-User&apos;s guide-Version 3.1</title>
		<author>
			<persName><forename type="first">P</forename><surname>Dauphin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hartleb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kienow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Mertsiotakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-04">Apr. 1992</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Erlangen-Nurnberg, IMMD VII</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. 5/92</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">NETMON-11, A monitoring tool for distributed and multiprocessor systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Endriss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steinbrunn</surname></persName>
		</author>
		<author>
			<persName><surname>Zitterbart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Int Con5 on Datu Communication and Their Performance</title>
		<meeting>4th Int Con5 on Datu Communication and Their Performance<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-06">June 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Considerations on the insularity of performance evaluation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ferrari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Sofhyare Eng</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="678" to="683" />
			<date type="published" when="1986-06">June 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">D</forename><surname>Ferrari</surname></persName>
		</author>
		<editor>3. Serazzi, and A. Zeigner</editor>
		<imprint/>
		<respStmt>
			<orgName>Measurement and Tuning of Computer Systems</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">M</forename><surname>Gardner</surname></persName>
		</author>
		<title level="m">Phaselock Techniques</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1979">1979</date>
		</imprint>
	</monogr>
	<note>2nd ed</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Some basic performance measurements of the 16x 16 CEDAR configuration</title>
		<author>
			<persName><forename type="first">K</forename><surname>Gallivan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Jalby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wijshoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Center for Supercomputing Res. and Develop</title>
		<imprint>
			<date type="published" when="1991-08">Aug. 1991</date>
			<pubPlace>Urbana, IL</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Tech. Rep. 1146</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">An Introduction to Ray Tracing</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Glassner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989">1989</date>
			<publisher>New York Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Initial experiences with a pattem-oriented parallel debugger</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Hough</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Cuny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices, Workshop on Parallel and Distrib. Debugging</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="195" to="205" />
			<date type="published" when="1989-01">Jan. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Performance evaluation and formal description</title>
		<author>
			<persName><forename type="first">U</forename><surname>Herzog</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Helmbold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Luckham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Computer Technology, Reliable Syst. and Applications. Proc</title>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Monaco</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Negrini</surname></persName>
		</editor>
		<meeting><address><addrLine>Bologna</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1985">May 1991. 1985</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="47" to="57" />
		</imprint>
	</monogr>
	<note>Debugging Ada tasking programs</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
		<title level="m">Communicating Sequential Processes</title>
		<meeting><address><addrLine>Englewood Cliffs, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice-Hall</publisher>
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Monitoring distributed systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Joyce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Lomow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Slind</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Unger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="121" to="150" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">VLSI-based monitoring of the interprocess-communication of multi-microcomputer systems with shared memory</title>
		<author>
			<persName><forename type="first">R</forename><surname>Klar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Luttenberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROMICRO &apos;86, Microprocessing and Microprogramming</title>
		<meeting>EUROMICRO &apos;86, Microprocessing and Microprogramming<address><addrLine>Venice, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-12">Dec. 1986</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="19" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Queueing Systems</title>
		<author>
			<persName><forename type="first">L</forename><surname>Kleinrock</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975">1975</date>
			<publisher>John Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName><forename type="first">H</forename><surname>Kobayashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Klar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Sotz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Modelling Techniques and Tools for Computer Performance Evalitation</title>
		<meeting>the 5th International Conference on Modelling Techniques and Tools for Computer Performance Evalitation<address><addrLine>Reading, MA; New York</addrLine></address></meeting>
		<imprint>
			<publisher>Elsevier Science</publisher>
			<date type="published" when="1978">Oct. 1981. 1992. July 1978</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="558" to="565" />
		</imprint>
	</monogr>
	<note>L. Lamport</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Performance evaluation of a communication subsystem prototype for broadband-ISDN</title>
		<author>
			<persName><forename type="first">N</forename><surname>Luttenberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Stieglitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Workshop on Future Trends of Distrib. Computing Syst. in the 1990&apos;s</title>
		<meeting>2nd Workshop on Future Trends of Distrib. Computing Syst. in the 1990&apos;s<address><addrLine>Cairo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Multiprocessor instrumentation: approaches for CEDAR</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Malony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Instrumentation for Future Parallel Computing Sjst</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Simmons</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><forename type="middle">.</forename><surname>Koskela</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Bucher</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press. Frontier Series</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="1" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">IPS-2: The second generation of a parallel program</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kierstead</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-S</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Torzewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel Disrrib. Syst</title>
		<imprint>
			<biblScope unit="volume">I</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="206" to="217" />
			<date type="published" when="1983-04">1983. Apr. 1990</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
	<note>measurement system</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Multiprocessor performance-measurement instrumentation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Mink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Nacht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Roberts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="63" to="75" />
			<date type="published" when="1990-09">Sept. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A distributed programs monitor for Berkeley UNM</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Macrander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sechrest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="183" to="200" />
			<date type="published" when="1986-02">Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">SIMPLE: A performance evaluation tool environment for parallel and distributed systems</title>
		<author>
			<persName><forename type="first">B</forename><surname>Mohr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Distrib. Memory Computing</title>
		<meeting><address><addrLine>2nd</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">European</forename><surname>Conference</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Edmccz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ed</forename><surname>Bode</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Germany</forename><surname>Munich</surname></persName>
		</author>
		<author>
			<persName><surname>Berlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">487</biblScope>
			<biblScope unit="page" from="80" to="89" />
			<date type="published" when="1991-04">Apr. 1991</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Tutorial: Computer system monitors</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Nutt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="1975-11">Nov. 1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Performance evaluation of a communication system for transputer-networks based on monitored event traces</title>
		<author>
			<persName><forename type="first">C.-W</forename><surname>Oehlrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Quick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 18th lnt</title>
		<meeting>18th lnt<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-05">May 1991. May</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="202" to="221" />
		</imprint>
	</monogr>
	<note>ACM SIGARCH</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An overview of the Pablo performance analysis environment</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Aydt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M R J</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Noe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">W</forename><surname>Shields</surname></persName>
		</author>
		<author>
			<persName><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tech. Rep., Univ. of Illinois</title>
		<imprint>
			<date type="published" when="1992-11">Nov. 1992</date>
			<pubPlace>Urbana</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">A Performance Monitor for Parallel Programs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Redly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>Academic Press</publisher>
			<pubPlace>San Diego, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Modellierung eines Kommunikationssystems fiir Transputernetzwerke</title>
		<author>
			<persName><forename type="first">K</forename><surname>Schimek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-10">Oct. 1991</date>
		</imprint>
		<respStmt>
			<orgName>Universitat Erlangen-Niimberg. IMMD VII</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Performance analysis and reliability analysis using directed acyclic graphs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sahner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Trivedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. So&amp;are Eng</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<date type="published" when="1987-10">Oct. 1987</date>
			<publisher>IO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SUPRENUM: System essentials and grid applications</title>
		<author>
			<persName><forename type="first">K</forename><surname>Solchenbach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Trottenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Computing. Amsterdam: North-Holland</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="265" to="281" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A noninvasive architecture to monitor real-time distributed systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J P</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="11" to="23" />
			<date type="published" when="1990-03">Mar. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Birds-of-a-feather session on standardizing parallel trace formats at Supercomputing &apos;90</title>
		<author>
			<persName><forename type="first">S</forename><surname>Utter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
	<note>Private communication</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Monitoring and measuring distributed systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wybranietz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Haban</surname></persName>
		</author>
		<editor>Performance Instrumentation and Wsualization, M. Simmons and R. Koskela</editor>
		<imprint>
			<date type="published" when="1990">1990. 1991</date>
			<publisher>Addison-Wesley Publishing Company, ACM Press</publisher>
			<biblScope unit="page" from="2" to="7" />
			<pubPlace>Frontier Series</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
