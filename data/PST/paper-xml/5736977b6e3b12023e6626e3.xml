<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Temporal Spatial-Keyword Top-k Publish/Subscribe</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Lisi</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Nanyang Te chnological University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gao</forename><surname>Cong #</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Nanyang Te chnological University</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Xin</forename><surname>Cao</surname></persName>
							<email>3x.cao@qub.ac.uk</email>
							<affiliation key="aff1">
								<orgName type="institution">Queen&apos;s University Belfast</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kian-Lee</forename><surname>Tan</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Temporal Spatial-Keyword Top-k Publish/Subscribe</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">36794793B64F8609119B59223352514B</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T05:26+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Massive amount of data that are geo-tagged and associated with text information are being generated at an unprecedented scale. These geo-textual data cover a wide range of topics. Users are interested in receiving up-to-date tweets such that their locations are close to a user specified location and their texts are interesting to users. For example, a user may want to be updated with tweets near her home on the topic "food poisoning vomiting." We consider the Iemporl!l §.patial-lieyword To p-k Subscription (TaSK) query. Given a TaSK query, we continuously maintain up-to-date top-k most relevant results over a stream of geo-textual objects (e.g., geo-tagged Tweets) for the query. The TaSK query takes into account text relevance, spatial proximity, and recency of geo-textual objects in evaluating its relevance with a geo-textual object. We propose a novel solution to efficiently process a large number of TaSK queries over a stream of geo textual objects. We evaluate the efficiency of our approach on two real-world datasets and the experimental results show that our solution is able to achieve a reduction of the processing time by 70-80% compared with two baselines.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Massive amount of data that contain both text information and geographical location information are being generated at an unprecedented scale on the Web. For example, Tweets, each containing up to 140 characters, can be associated with locations, which may be coordinates (latitude and longitude) or semantic locations; and some social photo sharing websites (e.g., Flickr) contain photos with both descriptive tags and geographical information. As another example, check-ins or reviews in location based social networks (e.g., Foursquare) contain both text descriptions and locations of points of interest (POls). We refer to such data with both textual content and geographical content as geo-textual objects.</p><p>These geo-textual objects can be modeled as continuously arriving streams, and many real-world applications can benefit from a publish/subscribe system for streams of such geo textual objects. The first example is annotation of POls. Social updates (e.g., Tweets) often offer the quickest first-hand reports of news events <ref type="bibr" target="#b23">[24]</ref>, comments and reviews, indicating the public view, business promotion information, etc. In order to provide users a better service, a POI service provider (e.g., Ye lp) may want to annotate each POI with its up-to-date relevant tweets in terms of both text relevance and spatial proximity. In addition, a manager for a POI may be interested in up-to-date tweets whose locations are close to each POI and whose text is relevant to the description of the POI. The second example application is that Groupon customers register their locations and keywords of their interests, and Groupon pushes to customers the Groupon messages whose locations are close to customers' locations and whose text is relevant to their interest keywords. As another example, users on Twitter 978-1-4799-7964-6/15/$3 1.00 © 2015 IEEE 255</p><p>want to be updated with tweets near their home on a topic (e.g., food poisoning vomiting). In these applications, user would prefer to be updated with a few most relevant tweets in tenns of distance, text relevance, and recency, rather than being overwhelmed by a large number of tweets.</p><p>The existing publish/subscribe systems for streams of geo textual objects <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b25">[26]</ref> allow users to receive up-to-date geo-textual objects whose locations have spatial overlap with a user specified region and texts contain the user specified key words. In these systems <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b25">[26]</ref>, both the user specified spatial region and the user specified keywords in a subscription query perform as boolean filters. Such subscription query has two problems: (1) A subscriber may receive very few matching geo-textual objects or may be overwhelmed by a huge volume of matching objects, depending on the specified query region and query keywords; (2) It may be difficult for a subscriber to specify the query keywords, and especially the size of a spatial region when they are used as boolean filters. For example, a larger region may result in too many results while a small one may result in no result.</p><p>To address these issues, in this work we consider the top k subscription query, for which we rank-order geo-textual objects and return only the top-ranked objects. The rationale behind is analogous to the reason that search engines rank order documents matching a query rather than employ the boolean retrieval model (e.g., the resulting number of matching documents of a boolean filter can far exceed the number a human user could possibly sift through <ref type="bibr">[19]</ref>). The recently proposed publish/subscribe system for tweets <ref type="bibr" target="#b23">[24]</ref> returns a subscriber top-k tweets that are ranked based on both keyword relevance and recency. However, it does not consider the spatial information.</p><p>In this paper, we propose a new type of top-k subscription query, which is referred to as Iempor.1!1 �patial-Keyword Top-k Subscription (TaSK) query, where TaSK queries are treated as subscriptions and geo-textual objects are published items in the publish/subscribe system. The TaSK query takes into account the following three aspects in evaluating its relevance with a geo-textual object: (1) Text relevance; (2) Spatial proximity;</p><p>(3) Recency of geo-textual object. The TaSK query contin uously maintains its up-to-date top-k results over a stream of geo-textual objects (e.g., tweets with locations). A TaSK query is triggered by a new published item (e.g., a tweet with location) only if the new tweet scores higher than the current k-th top result tweet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Challenges:</head><p>We aim at maintaining the up-to-date top-k results for a large number of TaSK queries, which arrive as a stream, over a stream of geo-textual objects. A straightforward ICDE Conference 2015 approach would work as follows: for each new geo-textual object a we compute its ranking score w.r.t. each TaSK query q; If the score is larger than the ranking score of the current kth result of q, a becomes a result and is used to update the current top-k results for q. Note that the ranking score of each object in the top-k results of q declines over time and we need to recompute them each time when a new object arrives. The straightforward approach is computationally expensive when the number of queries is large or the geo-textual objects arrive at a high rate. Hence, we need a more efficient mechanism to handle TaSK queries over geo-textual data stream.</p><p>We find that an underlying idea of many publish/subscribe systems and continuous query processing systems (e.g., [1], <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b26">[27]</ref>) is to group similar subscription queries such that they can be evaluated simultaneously for a new published object (more discussion can be found in Section III), thus improving the performance of query processing. However, it is challenging to achieve the similar optimization for TaSK queries. In this paper, we propose an approach including the following key techniques to representing, grouping, and indexing TaSK queries such that each group of queries can be processed simultaneously for a new geo-textual object.</p><p>(1) We propose a new concept Conditional In fluence Re gion (CIR) to represent the TaSK query, and utilize CIR to design a filtering condition of a TaSK query w.r.t. a spatial cell to determine whether a new object is a result of the query. Based on this, we develop an approach to grouping and indexing TaSK queries and generating filtering conditions for each group of queries such that they can be evaluated simultaneously. (Section IV) <ref type="bibr" target="#b1">(2)</ref> We develop an algorithm for making use of the filtering conditions (of each group of queries on each spatial cell) to efficiently retrieve the TaSK queries that have a new geo textual object as one of their top-k results. (Section V)</p><p>(3) In our method, each TaSK query needs to be associated with a set of non-overlapping spatial cells that can cover the whole spatial area. To select a set of cells for better perfor mance, we propose a cost model based approach. (Section VI) In summary, the paper's contributions are twofold. First, we define the TaSK query and present the first study on the problem of maintaining the up-to-date results for a large number of TaSK queries over a stream of geo-textual objects.</p><p>In particular, we propose a novel approach comprising the aforementioned key techniques. Second, we conduct an exten sive experimental study for evaluating the paper's proposals on real-world datasets of a large scale, collected from FourSquare and Twitter. The experimental results suggest that our proposed algorithm is able to achieve a reduction of the processing time by 70% to 80% compared with two baselines developed based on existing techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. PROBLEM STATEMENT</head><p>We define the geo-textual object and the Iempor�l .Spatial Keyword Top-k Subscription (TaSK) query.</p><p>Definition 1: Geo-Tex tual Object. A geo-textual object is represented with a triple a = ('IjJ, p, tc), where 'IjJ is a set of keywords, p is a location point with latitude and longitude, and tc is the creation time of object o.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D 256</head><p>In this paper, we consider a stream of geo-textual object data. For example, it can be geo-tagged tweets in Twitter, geo-tagged photos with tags in Flickr, check-ins with text descriptions in Foursquare, geo-tagged webpages, etc.</p><p>Intuitively, given a stream of geo-textual objects, a TaSK query is to continuously retrieve k objects over time such that these objects are relevant to the query keywords, their locations are close to the query location, and they are fresh. Note that in addition to text relevance and spatial proximity, recency is important for geo-textual data streams. For example, tweets are often tied to some event and their relevance to a query declines as time passes <ref type="bibr" target="#b23">[24]</ref>.</p><p>Definition 2: Te mporal Spatial-Keyword To p-k Subscrip tion (TaSK) Query. A TaSK query q = ('IjJ, p, k, a ) , where 'IjJ is a set of query keywords, p is the query location, k is the number of results to be maintained, and a E [0,1] is a preference parameter that balances the importance between distance proximity and text relevance, aims to continuously feed the user with new geo-textual objects whose temporal spatial-keyword scores are ranked within the top-k. The tem poral spatial-keyword score of a geo-textual object a at time te is defined as follows.</p><p>(1)</p><p>where Ssk (q,O) computes the spatial-keyword relevance be tween query q and object a and St (o.tc, te) computes the object recency. Following previous work (e.g., <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b5">[6]</ref>, [15], <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b29">[30]</ref>) we compute the spatial-keyword relevance Ssk (q, 0) between q and 0 as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S sk( q , O</head><p>) = a• Sp( dis t( q . p , o . p )) + ( 1 -a) . TRel ( q .'ljJ , o .'ljJ ), <ref type="bibr" target="#b1">(2)</ref> where Sp(dist(q.p, o.p)) is the spatial proximity score of the distance between query q and object 0, TRel(q.'IjJ, 0.'IjJ)</p><p>indicates the text relevance between q and o.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>Example 1: Consider the annotation application in Section I. Each POI (e.g., cotlee shop) will correspond to a TaSK query, where the location of the POI is the query location q.p and its text description (e.g., coffee, espresso, mocha, green tea latte) corresponds to the query keywords q.'IjJ, and we want to continuously feed each POI with the top-k tweets with the highest temporal spatial-keyword scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>Note that all the textual, spatial, and temporal information are important in continuously retrieving top-k results. If we ignore the spatial (or temporal) aspect in the ranking function, even if users can get tweets that are relevant to the query keywords, their distances may be faraway from the query location (or they are not the most recent).</p><p>The spatial proximity score is calculated by the normalized Euclidian distance: Sp(dist(q.p, o.p)) = 1-d iS�;;� �:,: ' p) ,where dist(q.p,o.p) is the Euclidian distance between q and 0, and distmax can be the maximal possible distance in the spatial area. The text relevance can be computed using any information retrieval model in our method. We use language models <ref type="bibr" target="#b5">[6]</ref> in this work, described as follows:</p><formula xml:id="formula_0">TRel ( q .'ljJ , o .'ljJ ) = II PS( o .'ljJ ,w ),<label>(3)</label></formula><p>wEq.1jJ</p><p>where PS(o.1jJ, w) is the partial score of text relevance for 0.1jJ w.r.t. keyword w, which is computed as follows:</p><p>PS ( "I. )= ( l_ .\ ) Num (o .� ,w ) .\Num (Coll,w ) 0. '1", w 1 0 .�1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>+</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IColll '</head><p>where Num(o.1jJ, w) indicates the count of w in 0.1jJ. Num( Coll, w) represents the count of w in the object col lection Coll, and A is a smoothing parameter of the lelinek Mercer smoothing method.</p><p>The recency of object 0 is calculated by the following exponential decay function:</p><formula xml:id="formula_1">(4)</formula><p>where D is base number that determines the rate of the recency decay. The function is monotonically decreasing with teo.te.</p><p>It is introduced in <ref type="bibr" target="#b13">[14]</ref> and is applied (e.g., <ref type="bibr" target="#b1">[2]</ref>, [16], <ref type="bibr" target="#b23">[24]</ref>) as the measurement of recency for stream data. Based on the experimental studies <ref type="bibr" target="#b6">[7]</ref>, the exponential decay function has been shown to be effective in blending the recency and text relevancy of objects.</p><p>Property: Our scoring method is general and guarantees that the relative ranking of two different objects w.r.t. a query is consistent over time, i.e., if Stsk(q, OJ, t) &gt; St sk(q, Ok , t), then V6.t &gt; 0 we have Stsk(q,Oj,t+ 6.t) &gt; Stsk(q,Ok ,t+ 6.t).</p><p>This property indicates that we need not re-rank query results over time. However, the difficulty is that the absolute ranking scores of the objects in top-k results will decrease over time, which may affect the judgment of whether a new object can be one of the results.</p><p>In our applications, the typical arrival rate of geo-textual objects (e.g., tweets) is in the scale of millions a day, while new TaSK queries are added at the rate of tens of thousands a day, and we may serve millions of TaSK queries at one time. We thus aim to develop a scalable solution to maintain the up to-date results for a large number of TaSK queries over a data stream of geo-textual objects. Millions of TaSK queries can easily fit into the available memory of modern servers. Hence, our solution is developed under this setting. In the rare case that the TaSK queries cannot fit into memory, we can employ our proposed solution on multiple servers, each handling a subset of TaSK queries independently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. FRAMEWORK OV ERVIEW</head><p>As mentioned in Section I, an underlying idea of many publish/subscribe systems is to group similar subscription queries such that they can be evaluated simultaneously for a new published object. For example, XFilter [1] employs Non deterministic Finite Automaton (NFA) to represent multiple XPath subscription queries so that they can be evaluated simultaneously; Shraer et al. <ref type="bibr" target="#b23">[24]</ref> propose an approach to grouping text subscription queries such that they can be evaluated simultaneously; In the continuous k nearest neighbor (CkNN) queries <ref type="bibr" target="#b19">[20]</ref>, each query is represented by a circular influence region with the query location as the center and the distance from the query location to its kth nearest object as the radius, and queries whose influence regions fall in the same spatial region are grouped together so that they can be processed simultaneously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>257</head><p>Motivated by these systems, we also expect to design an approach to grouping TaSK queries such that queries in one group can be evaluated simultaneously, thus reducing the computation of query processing. Moreover, the overhead of updating query groups should be small since TaSK queries arrive and expire as a stream. However, it is challenging to develop such an approach for TaSK queries, each of which has its own location, keywords, and preference parameter (0;), and the temporal spatial-keyword score of a current top-k result of a query decreases over time.</p><p>To address the challenge, we propose the concept of Con ditional ln fluence Region (CIR) to represent each TaSK query, and based on CIRs we develop an efficient mechanism to group queries such that each group can be handled simultaneously. Based on the grouping mechanism, we develop an algorithm for efficiently maintaining the up-to-date top-k results for each TaSK query over geo-textual object stream. Here we index queries instead of geo-textual objects, and run geo-textual objects as queries on that index.</p><p>Figure <ref type="figure">1</ref> shows our proposed architecture for processing TaSK queries. A user may issue a query or generate a geo textual object in the system. When our system receives a TaSK query, a complementary index-the object index component is used to initialize the top-k result when a new query arrives. The initialization is optional. Next, the query is represented as CIR and it is grouped and indexed by the query index component, utilizing the component of cost model fo r query insertion. The query table maintains the basic information of all queries (including query location, query keywords, query preference parameter 0;) and their current results with ranking scores. When a new geo-textual object arrives, the query index is utilized to find the queries whose top-k results include the new object, and their top-k results are updated and pushed to the users who issue these queries.</p><p>The concept of CIR, the approach to grouping and indexing TaSK queries, the algorithm for processing geo-textual objects on the query index, and the algorithm of query insertion are the techniques we develop in this paper. For object index, we can use any of the existing index structures (e.g., <ref type="bibr" target="#b29">[30]</ref>). We propose a novel approach to representing, grouping, and indexing TaSK queries such that each group of queries can be processed simultaneously for a new geo-textual object. We first propose the concept of Conditional Influence Region (CIR for short) to represent the TaSK query (Section IV-A).</p><p>Based on CIRs, we develop an approach to deriving a filtering condition of a TaSK query w.r.t. a spatial region, and show how to use the filtering condition to determine whether a new object falling in the region is a result of the query (Section IV-B). Finally we develop an approach to grouping and indexing TaSK queries and generating filtering conditions for each group of queries (Section IV-C).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Conditional In fluence Region (CIR)</head><p>We propose the concept of Conditional Influence Region (CIR) to represent the TaSK query. The idea of CIR is inspired by the influence region technique for processing continuous k nearest neighbor (CkNN) queries <ref type="bibr" target="#b19">[20]</ref> (as discussed in Section III). Each CkNN query is represented by a circular influence region with the query location as the center and the distance from the query location to its kth nearest object as the radius. The influence region plays the role of a filtering condition: If a spatial object falls in the influence region of a query, the object becomes a result of the query; otherwise, it cannot be a result.</p><p>However, we have no way to generate an influence region for a TaSK query. This is because the ranking score of an object for a TaSK query relies not only on the spatial prox imity, but also on the text relevance and the time gap between the object creation time and current time. We propose the conditional influence region (CIR) to help process the TaSK query. Given a query q, we define its CIR to be conditional on: (1) The text relevance score tr; (2) The timestamp t; (3) The current k-th result of q (Rq [k]). That is, for query q, we generate CIRs with different radii, each denoted by Clq(tr, t).</p><p>Intuitively, given a new geo-textual object 0 arriving at time t, of which text relevance to q is tr, 0 becomes a top-k result of q itT 0 falls in the CIR Clq(tr, t). Table <ref type="table">I</ref> summarizes the notations frequently used in the rest of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3: Conditional In fluence Region (CIR). Let</head><p>Clq(tr, t) be the CIR of q w.r.t. time t and text relevance score tr, and rq(tr, t) be the radius of Clq(tr, t). Based on Defini tion 2 the relationship among t, tr, Rq[k], and Sp(rq(tr, t)) can be expressed by Equation <ref type="formula">5</ref>.</p><p>S tsk ( q , R q [k], t) = a• Sp (r q( tr, t) ) + ( 1 -a) . tr</p><p>(5)</p><formula xml:id="formula_2">D Table I.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SUMMARY OF NOTATIONS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notation Description</head><p>Cl q( tr, t) CIR of q w.r.t. time t and text relevance score tr r q( tr, t) radius of Cl q( tr, t) Sp (r q( tr, t) )</p><p>the spatial proximity score of r q( tr, t) R q a list of top-k result of q sorted by S t sk R q lkj the k-th result of query q R q [k]. te the creation time of R q [kj dis t min ( q , c ) the minimum distance between q and cell c minD ( q , c ) spatial proximity score of dis t min ( q , c ) minT( q , c )</p><p>minimum conditional text score w.r.t. q and c</p><p>From Equation <ref type="formula">5</ref>, we can see that r q (tr, t) increases as the time t goes by, and a larger value of tr results in a larger rq(tr, t). Example 2 demonstrates the CIRs given q.</p><p>Example 2: Let tro and tr1 be the text relevance of geo textual object 00 and 01 to query q, respectively, and tro &lt; tr1' Let to and t1 be two timestamps and to &lt; t1' Figure <ref type="figure" target="#fig_15">2</ref> illustrates the CIRs of query q under different timestamps and different values of text relevance.</p><p>We observe that radius becomes larger as time passes and a larger value of tr corresponds to a larger radius. Object 00 falls outside both Clq(tro, to) and Clq(tro, td. Hence, 00 is not a result of q at both time to and time t1. Object 01 falls outside Clq(tr1, to) but inside Clq(tr1, td. Therefore, 01 is a result of q at time h but 01 is not a result of q at time to. D We first propose the method of deriving afiltering condition of a TaSK query w.r.t. objects falling in a spatial cell based on the concept of CIR, and then we develop an approach to associating a TaSK query and its filtering conditions with a spatial index. These techniques lay the foundation of our ap proach to grouping queries and generating a filtering condition of a group of queries (to be presented in Section V).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I)</head><p>Deriving filtering conditions of a TaSK query: Accord ing to Definition 3, the radii of CIRs of a query q depend on:</p><p>(1) The temporal spatial-keyword score between q and its kth result (in Rq); <ref type="bibr" target="#b1">(2)</ref> The text relevance between q and a new geo-textual object 0; (3) The arrival time of o. This renders it inapplicable to generate a CIR for q and then use the region as filtering condition to decide whether a new geo-textual object is a result of q (in the similar way as the influence region is used for the CkNN query <ref type="bibr" target="#b19">[20]</ref>).</p><p>To this end, we propose a novel way of generating CIRs and deriving their corresponding filtering conditions for a TaSK query with respect to a spatial cell. Our idea comprises three steps, which are detailed as follows.</p><p>Step 1: Given a spatial cell c and a TaSK query q, we generate the minimum circle, denoting minClq, whose ra dius distmin(q, c) is the minimum distance between q and c. Let minD(q, c) represent the spatial proximity score of distmin(q, c) . Formally, we have minD ( q , c ) = Sp ( dis t min ( q , C)).</p><p>(</p><formula xml:id="formula_3">)<label>6</label></formula><p>Note that when q is located in c, the radius denoted by minD(q, c) is 0; Figure <ref type="figure" target="#fig_8">3</ref>(a) illustrates the case when q is located within c and Figure <ref type="figure" target="#fig_8">3</ref>(b) illustrates the case when q is not located within c.</p><p>Step 2: Based on the circle generated in Step 1, we generate a CIR. Here we know the spatial proximity score of radius (minD(q, c) , the current time teur , and the current kth result object of q (Rq [k]), and we want to compute the current corresponding text relevance score, which is called minimum conditional text score. . T ( ) _ S t sk( q , R q [kJ, teur) a . minD ( q , c ) min q , c -1a -1a '</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>Step 3: This step utilizes the minimum conditional text score to check whether a new geo-textual object 0 is a result for query q if 0 falls in the spatial area of c. With the scores computed in Definition 4, we have the following lemma to determine whether 0 is a result.</p><p>Lemma 1: Let 0 be a new geo-textual object located in the spatial cell c. We have: (1) when TRel(q.'lj;, o.'lj;) � minT(q, c), 0 is not a result of q; and (2) when TRel(q.'lj;,o.'lj;) &gt; minT(q,c), 0 may be a result of q.</p><p>Proof If TRel(q.'lj;, o.'lj;) � minT(q, c), then we have S t sk( q , R q [kJ, teur) ;:: ( 1a) TRel ( q . 'IjJ , o . 'IjJ ) + a . minD ( q , c ).</p><p>Since \lo.p E c, Sp(dist(q.p, o.p)) � minD(q, c), we have:</p><p>S t sk( q , R q [kJ, teur) ;:: ( Ia) TRel ( q . 'IjJ , o . 'IjJ ) +a• Sp ( dis t( q . p , o . p ».</p><p>Thus 0 cannot be a result of q.</p><p>D Lemma 1 offers a filtering condition of query q for objects falling in cell c. Specifically, for a new geo-textual object 0 falling in cell c, we can apply Lemma 1 to check whether each of the queries stored in c will let 0 become a result.</p><p>2) Associating a TaSK query with a spatial index: In last subsection, we present an approach to deriving a filtering condition of a TaSK query w.r.t. objects falling in a cell based on CIRs, and the filtering condition enables us to check whether an object falling in the cell is a result of the query. However, a new geo-textual object may fall in any cell in the spatial area. Hence, to utilize Lemma 1 to handle all incoming geo-textual objects, we need to find a set of spatial cells that can cover the whole spatial area, and for each query we maintain its corresponding minimum conditional text score in each cell. Also, we need a spatial indexing structure to organize the cells, queries, and corresponding conditional text scores.</p><p>We choose the Quad-tree for the purpose. The reason is that Quad-tree is more suitable for update-intensive applica tions [11] compared with R-tree based indices, which will incur additional cost for maintaining the MBRs when new queries arrive.</p><p>For each query q, we select a set of non-overlapping cells from different levels of the Quad-tree that together cover the whole spatial area; q is associated with each of the selected cells, and for each selected cell c, we generate corresponding minT(q, c). Figure <ref type="figure" target="#fig_2">4</ref> exemplifies the set of Quad-tree cells (crossed by "X") associated with qo. The problem of selecting a set of cells in the Quad-tree for a query will be discussed in Section VI.</p><p>3) Storing a TaSK query and its minimum conditional text score: The next problem is that, given a query q and one of its selected cells c, how to store the minimum conditional text score (minT(q, c) .</p><p>259 Our basic idea is to separately store each component of minT(q, c) according to: (1) Whether it is time-dependent; <ref type="bibr" target="#b1">(2)</ref> Whether it is cell-dependent.</p><p>According to Equation <ref type="formula" target="#formula_4">7</ref>, minT(q, c) is computed by the following two parts: (1) l �aStsk(q, Rq[k], teur) l �a Ssk (q, Rq[k]) . D-( t cur-Rq[ k ]. t c); and (2) l �a minD(q, c).</p><p>We note that part (1) is time-dependent but cell independent, while part (2) is time-independent but cell dependent. In the rest of the paper, we use Seq, Rq[k]) and minD(q,c) to denote l �aSsk(q,Rq[k]) and l �aminD(q,c) which is separately maintained by each Quad-tree cell c, is used for storing the cell-dependent component -minD(q, c);</p><p>(2) Global query table, which is used for storing the cell independent components -Seq, Rq[k]) and Rq[k].te. Note that the global query table also stores q.o, q.p, and the current results for each q.</p><p>Example 3: Consider three TaSK queries, qo, ql, and q2, and a Quad-tree cell c, which is colored as grey in Figure <ref type="figure" target="#fig_14">5</ref>, where qo.p E C, ql'P tf-c, and q2'P tf-c. The infonnation for the three queries, the global query table, and the local query table for cell c are exemplified in Figure <ref type="figure" target="#fig_14">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D C. Grouping and indexing TaSK Queries</head><p>Based on the techniques in the last two subsections, we propose a new mechanism to group and index TaSK queries in each cell, as well as generate a filtering condition for a group such that the queries in a group can be processed simultaneously.</p><p>Our high-level structure in each cell is an inverted file <ref type="bibr">[19]</ref>. With the inverted file, for a geo-textual object we only need to consider the queries containing at least one keyword in the object since the object that does not contain any query keyword will not be a result of the query. Nevertheless, it is still inefficient of checking on each posting (query) in the postings lists <ref type="bibr">[19]</ref> of each word contained in the object.</p><p>To enable group filtering in a postings list for processing queries in a group simultaneously, we propose a technique to group the postings in each postings list into blocks, each of which contains a specified number of postings, and propose an approach to estimating the lower bound of minT for a block.</p><p>The bound can be used to generate the filtering condition of a block w.r.t. each new object. However, it is non-trivial to derive such a tight bound for a block. The challenge is that the value of minT is determined by each TaSK query, and different queries may have different location, keyword, preference parameter (0), and the top-k result set. To address the challenge, we propose an efficient method for estimating lower bounds of min T, and we develop the spatial-aware block structure to optimize the estimation of the lower bounds.</p><p>1) Estimating lower bounds of minT: Recall that minT(q, c) is computed by two parts, one is time-dependent and the other is time independent. So we are unable to acquire the exact current minimum minT (q, c) in bi unless we compute q, 1 q[ 0.7 q, 0.8 associated with qo Figure <ref type="figure" target="#fig_14">5</ref>. Combining TaSK queries with the Quad-tree Figure <ref type="figure">6</ref>. Temporal Effect of the TaSK Query minT(q, c) for each q E bi at the current time, which is what we want to avoid. Consequently, given a block bi, we compute the lower bound of minT(q, c) for all q E bi by computing the minimum value of l � cx Stsk(q, Rq[k], tcur) and the maximum value of l � cx minD(q, c) respectively for all q E bi, and combining them based on Equation <ref type="formula" target="#formula_4">7</ref>.</p><p>However, the challenge here is that ditlerent queries in bi may have different values of Rq <ref type="bibr">[k]</ref>.tc, which is called the the base time of q, and thus we still have to retrieve R y <ref type="bibr">[k]</ref>.tc for all q E bi � or computing the minimum valu � of S t sk( q ,R q [k], tc ur) = Sb sk( q ,R q [k], tb )' D -(tcur-tb)</p><p>Then we find that Stsk(q, 0, tcur) &gt; Stsk(q, Rq[k], tcur), and thus 0 becomes a result of q and we update Sbsk(q, Rq[k], tb).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>Based on Equations 7 and 8, we compute minT(q, c) as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S ( R [k] t) D-( t cur-tb)</head><p>. T ( ) b sk q , q ,b' min q , c = Ia a• minD ( q , c ) 1-a Hence, we have the following lemma for estimating the lower bound of minT(q, c) .</p><p>Lemma 2: Given a block bi, let bi.minT be the minimum value of minT(q, c) for all q E bi, bi.minS be the minimum value of l � cx Sbsk(q, Rq[k], tb) for all q E bi, and bi.minD be the maximum value of minD(q, c) for all q E bi, then Proof Given a block bi, assume that qm E bi S.t. \/q E bi, minT(qm' c) ::; minT(q, c) . We have Definition 6: minD-Bucket. We use minD-buckets to or ganize blocks in a cell. Each minD-bu5:: ket ("bucket" for short) corresponds to a score interval of minD, and is associated with an order number r. Namely, the rth bucket Br corresponds to the following interval: [r • 6.D, (r + 1) . 6.D), wher� 6.D is a specified parameter indicating the range of minD in a bucket. A query q is in bucket Br if: r• 6.D ::; minD(q, c) &lt; (r + 1) •6.D. minD(q, c) . For each bucket Bi, a separate block based inverted file is maintained where the queries in each list are sorted according to their query ids in ascending order. Each block bi contains at most Pmax queries, where Pmax is a specified parameter. Each posting of a query just stores its query id. To compute the lower bound based on Lemma 2, we augment each block bi with the following values: (1) bi.minID and bi.maxID, which respectively indicate the minimum and maximum ids of queries in bi; (2) bi.minS, which is the minimum value of l � aSbsk(q, Rq[k], tb) for all q E bi; (3) bi.minD, which is the maximum value of min D (q, c) for all q E bi (the maximum value of min D (q, c) corresponds to the minimum distance between q and c).</p><p>V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALGORITHM FOR PROCESSING TaSK QUERIE S</head><p>We proceed to present the algorithm for processing and updating indexed TaSK queries. Recall that each query q is associated with a set of non-overlapping cells that cover the whole space. Hence given a query q, for any location p in the space there must exist a cell c S.t. pEe and c contains q's posting. Consequently, when a new geo-textual object a arrives, we only traverse the inverted file in the cells whose areas cover o.p.</p><p>Based on the filtering condition of a block w.r.t. each new object, we propose an algorithm for traversing the inverted file with forward skipping. Our high-level idea is as follows. For a cell containing object a we traverse its postings lists of all the words contained in a simultaneously based on the Document at-a-Time (DAAT) technique [19]; for each postings list we maintain a cursor that specifies the query id we currently visit. Since�the query ids are sorted in ascending order within each minD-bucket, the queries whose ids are smaller than the id at the cursor position of the postings list of keyword W may belong to two cases: (1) they have been evaluated; or (2) they do not contain w. For each block bi from the postings lists of words in object 0, we generate a filtering condition (Lemma 3) to check whether bi can be safely filtered without evaluating each individual query in bi. TRe lm ax (o.'lj;, sgJ, a will not be a result of any query in bi.</p><p>Proof" Since the query ids in B are sorted in ascending order, if p,:!� &gt; bi.maxI D, then based on the DAAT scheme it suggests ' that: (1) a cannot be a result of any query in bi; or (2) queries in bi that can match a have already been found. Hence, unevaluated queries in bi cannot contain any keyword that does not belong to Sgi' So according to Equation 3 the text relevance between a and any query in bi cannot exceed TRelmax(o.'lj;, sg). Then based on Lemmas 1 and 2, if bi.minT 2: TRelmax(�.'lj;,sg), a cannot be a result of any query in bi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>' D</head><p>Lemma 3 offers a filtering condition for efficiently deter mining whether object a is not a result of any query in a block. If it can be determined, we move the cursor to the first query in the next block; otherwise the cursor is forwarded to the next query, and we need to check each individual query in the block to determine whether a is a result. We are now ready to present our algorithm for processing an incoming object a to maintain the top-k results of individual queries. The algorithm starts from the root cell of the Quad tree and iteratively visits the child cells that cover the object a until y!e reach the leaf cell; At each visited cell, queries in each minD-bucket Bi are separately evaluated. For evaluating the queries in each bucket, it traverses the postings lists for each word in a concurrently, and applies Lemma 3 to prune the search space.</p><note type="other">261</note><p>Algorithm 1 shows the pseudo code. For each bucket Bi in a visited cell, we first initialize the cursor of each postings list to be the first element in the list (lines 5-6). Here I( w, c, Bi) represents the postings list for keyword w in bucket Bi under cell c (line 6). Next, we choose the postings list of Wmin where its cursor is located at the posting with the minimum query id among all the postings lists of the words of a (line 8). Then we invoke function FindNext to evaluate the blocks/queries sequentially until Wmin is not the keyword with the minimum P � Bi for all W E Sw, where Sw represents the keyword set S.t. (VWj E Sw) P:'Bi &lt; I(wj, c, Bi).maxID (line 9). If the cursor reaches the end of the current block be, we update be.minS (line 10). We will remove Wmin if p W rn B'n reaches C, I the end of I(wmin,c,Bi) (lines 12-13). When Sw is empty, we move to the next bucket.</p><p>Function FindNext(w, {P � BJ W ESw' Result)</p><p>1 pc +-P':!B; 2 bc +the block containing pc;</p><p>3 if pc = bc. f i r s t then if TRel ( o . 7j;, q . 7j;) &gt; minT(q,c) then</p><formula xml:id="formula_5">9</formula><p>Compute S t sk( q , o , tc ur) ;</p><formula xml:id="formula_6">10</formula><p>if ° is the result of q then 11 I Return q as the query that matches 0 ;</p><p>12 Update the the result of q in the global query list;</p><p>13 pc +-pc.nex t ; 14 return pc;</p><p>Function FindNext is used for checking whether object 0 is a top-k result of the current block/query. First, Pe and be are respectively initialized as the current posting and block (lines 1-2). If Pe is the first posting in be, i.e., none of the queries in be have been evaluated, then we compare be.minT with TRelmax(o.'lj;,sgJ. If be•minT 2: TRelmax(o.'lj;,sgJ, none of the queries in be can have 0 as a result, and thus we skip be and forward the cursor to the next block (lines 4-6). However, if Pe is not the first posting in be, which indicates that be cannot be skipped as a whole, then we need to consider the following two cases: (1) If the text relevance between 0 and q (TRel(o.'lj;,q.'lj;) is larger than minT(q,c), we compute S t s k (q, 0, teur) and check whether 0 is a result of q. If so, q is returned and we update the result of q in the global query list (lines 9-1 3). ( <ref type="formula">2</ref>) If TRel(o.'lj;,q.'lj;) is smaller than minT(q,c), then 0 cannot be a result of q, and we just skip q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. QUERY INSERTION</head><p>Recall that each TaSK query needs to be associated with a set of non-overlapping spatial cells that can cover the whole spatial area. To choose such a set of cells for a better performance, we propose a cost model based approach.</p><p>Heuristic Method for Query Insertion: Before introducing our proposed method, we first give a heuristic method for associating a new query onto the Quad-tree cells:</p><p>Step 1: Starting from the root cell Croo t of the Quad-tree, we check whether each of croo t 'S children Ci covers q.p. If not, we associate q with Ci. If so, we invoke Step 2 with Ci as the input.</p><p>Step 2: Given an input cell c, we check whether each of c's children C j covers q. p. If not, we associate q with C j . If so, we recursively invoke Step 2 with C j as the input.</p><p>Such recursive procedure terminates when the input cell C in Step 2 reaches the m-th layer of the Quad-tree, where m is a tunable parameter. An example association by this heuristic method is given in Figure <ref type="figure" target="#fig_2">4</ref>, and this method is denoted by CIQ-H (Heuristic CIR based Quad-tree).</p><p>Next we present our cost-model based method denoted by CIQ (CIR based Quad-tree). The objective for selecting a set of cells to associate a new query q is twofold: (1) Minimize the number of evaluations of q, which occurs when q cannot be skipped according to Lemma 1 while processing a geo-textual object; (2) Decrease the number of cells used for associating q, which incurs cost. However, we need to strike a balance between the two objectives that have a trade-otI. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Cost Estimation</head><p>Because we do not know the text and location information of future geo-textual objects, it is impossible to compute the 262 exact number of evaluations for query q, So we estimate the expected number of evaluations of q by Definition 7.</p><p>Definition 7: Expected Number of Evaluations: Given query q and cell c, Fo denotes the arrival frequency of geo-textual objects, P( q. 'lj;) denotes the probability of an object containing any of the keywords in q.'lj;, P(c) is the probability of o.p E c, E(6.t) indicates the expected du ration of q (from the creation time to the deletion time), and PeTRel &gt; minT(q,c)) denotes the probability of TRel(q,o) &gt; minT(q,c). If q is associated with cell c, the expected number of evaluations for q is computed by E#( q , c ) = Fa' P( q .� )• P( c )• PeTRel &gt; minT( q , c ))• E(t:,. t) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>We estimate Fo, P(c), P(q.'lj;), and E(6.t) based on his torical data, which is straightforward. We estimate peT Rel &gt; min T (q, c)) through the probability density function for the text relevance between an arbitrary query and an arbitrary object that contains at least one query keyword.</p><p>Next, we illustrate the comparison between associating q with Co and associating q with co's children (C I , C2, C3, and C4 in Figure <ref type="figure">8</ref>). If we associate q with Co, then minT(q, co) = I �QSbsk (q, Rq[k], tb) -minD(q, co) and it will be used for checking new objects falling in co. If we associate q with co's children, for each Ci E co.children we have minT(q,ci) = I �QSbsk (q, Rq[k], tb) -minD(q, Ci), which will be used for checking incoming objects falling in Ci.</p><p>Lemma 4: Given a quad-tree cell c and a query q, we have <ref type="bibr" target="#b9">(10)</ref> Ci Ec.children Proof Since ('VCi E c.children) minD(q, c) 2: minD(q, Ci), ('VCi E c.children) minT(q, c) :s; minT(q, Ci). We know that P(c) = L e iE e . e h i l d ren P(Ci). Hence, we have E#(q, c) 2: L e iE e . e h i l d ren E#(q, Ci) based on Definition 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>According to Lemma 4, associating query q with the child cells of c will lead to smaller value of E# for the incoming objects falling in the area of c. However, both the space and the time cost for storing q will increase as the number of cells used for associating q mounts up. Hence, we need to balance the trade-off between E# and the cost for storing q.</p><p>To determine whether q is to be associated with cell c or its child cells, we compute the difference of their expected number of evaluations based on Lemma 4 as follows:</p><p>(11) Ci Ec.children Then we compute the difference of the number of insert operations between the two options as follows:</p><p>(12)</p><p>To make the two types of cost comparable, we introduce a cost normalization factor J that specifies the weight between the two types of cost. If 6.E#(q, c) &gt; 6.U#(q, c) x J, i.e., the benefit from associating the query with the child cells outperforms the overhead, then we associate q with the child cells of c; otherwise we associate q with c. The factor J is empirically set at 3.5 in our experiments. The method for query insertion is summarized as follows. It starts from the root cell of the Quad-tree and recursively checks whether we associate the query with the current cell or its child cells. Algorithm 2 shows the pseudo code for query insertion. Specifically, if 6.. E#(q,c) ::; 6.. U#(q,c) x &lt;5, the query will be associated with the current cell c; Otherwise we need to further check whether q will be associated with c's child nodes or lower level descendant nodes by invoking the comparison again for each child of c.</p><p>Algorithm 2: Query lnsertion(Query q, Cell c , Factor J)</p><p>if D.E# (q, c ) ::; D.U# (q, c ) x J then I Store the postings of q into c ;  I Queryl nsertion(q, Ci , J);</p><p>After we select a set of cells for assoclatmg query q, for each selected cell c, we map q to a bucket based on minD(q, c). Then for each keyword in q, we insert q into the postings list of the keyword in the bucket. Specifically, we maintain a temporary block bu for each postings list under each bucket, which serves as a "buffer" to receive the newly inserted queries. If bu becomes full, we compute bu ' minI D, bu .maxID, bu .minS, and bu .minD. Subsequently, we insert bu into the corresponding postings list and then create a new temporary block to replace bu .</p><p>Query Deletion: The operation for query deletion is conducted during query processing. When a deletion request for query q is received, we mark q as expired in the global query list. If we find that all the queries in a block bi are expired during the process of evaluating queries in bi, then we delete bi.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. EXPERIMENTAL STUDY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Baselines</head><p>We discuss how to exploit existing techniques for process ing TaSK queries. No algorithm exist for solving the problem. We develop two baselines by utilizing existing index structures.</p><p>1) Inverted File plus Query List (lFL): We use the in verted file to index TaSK queries. We also maintain a global query table. For each query q, the table stores the query id, Sbsk(q, Rq[k], tb), q.p, q.a, and its current query results. When a geo-textual object a arrives, we traverse the postings lists associated with the words in the object in the Document-at -a-Time (DAAT) [19] manner. For each posting, we get the query information from the query ta ble for computing the temporal spatial-keyword score be tween a and the query (Stsk(q,o,tcur »' Then we compare Stsk(q, 0, tcur) with St sk(q, Rq[k], tcur), which is computed from Sbsk(q, Rq[k], tb), to determine whether a is a result of q. If so, we update the result set of q with a in the query table. while processing each new object a we traverse the correspond ing postings lists with forward block skipping technique. Since BIF does not utilize any spatial partitioning scheme, we cannot derive minD(q, c) for each query. Hence, while computing the minimum value of minT(q, c) for each block bi, we use "1", which is the maximum possible value of the distance score, to replace minD(q, c) in Equation <ref type="formula">9</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Experimental Settings</head><p>Our experiments are conducted on two real datasets: FSQ and TWE I . FSQ is a real-life dataset collected from Foursquare, which contains 1.1 million worldwide POls with both location and text. The dataset TWE is a larger real-life dataset that comprises 40 million tweets with geo-Iocations.</p><p>The TaSK queries are generated as follows. For FSQ, each POI is mapped to a TaSK query, in which the text description of the POI becomes the query keywords, and the location of the POI becomes the query location. For TWE, we randomly select a number of keywords from the tweet keywords, and the query location is the same as the tweet location. In addition, for experiments on FSQ, we regard each tweet with geo-Iocation from TWE as a geo-textual object, and we use those tweets to annotate the POls from FSQ. For experiments on TWE, each tweet with geo-Iocation from TWE is considered to be a geo-textual object on TWE. Default value for parameters is presented in Table <ref type="table">II</ref>.</p><p>We implemented all algorithms in Java on a PC with Intel(R) Core(TM) i7-4770k @3.50GHz and 16GB RAM.</p><p>C. Experimental Result 1) the Ti me Effe ct: In this set of experiments, each method runs for 4,000 seconds (which is simulation duration, denoted by 6.. tsim) on both FSQ and TWE. We set the decaying scale D-c;' t sim at 0.5. Our proposed method is denoted by CIQ, and the variation of CIQ (without the cost-model based method for query insertion) is denoted by CIQ-H as presented in Section VI. The arrival rate of geo-tagged tweets in Twitter is around 100 (4,600 tweets/second [18] and 2. 17% of the tweets are geo-tagged 2 ). To make sure that all the methods can handle, we use the following setting: during each second 5 geo-textual objects are issued, 5 new queries are issued, and 5 queries become expired. At the beginning, each method is initialized with 1M and 10M TaSK queries, respectively, for FSQ and TWE.</p><p>We report the average runtime for processing an object and the average runtime for inserting a query during each period -+� --. -" -X --. --:</p><p>. . Xr . .. --: . �� .. =)( t: . = . . </p><formula xml:id="formula_7">� � 6 &lt;3 4 • • •x •• -••X-• • • •K••• • K• • -K•-' ) (•-X -••• � 2 --+-- � 0 L-.</formula><p>-��� �� ��---' . § 0 5 10 15 20 <ref type="bibr" target="#b24">25</ref>    of 500 seconds. Figure <ref type="figure">9</ref> shows that both CIQ-H and CIQ outperform the two baselines significantly in object processing, and CIQ exhibits the best performance. CIQ is able to improve the runtime perfonnance of the best baseline BIF by 70%-80% on both datasets. The reasons could be explained as follows.</p><formula xml:id="formula_8">_ � 6 BIF -----*----CIQ -B" - ���:�=&amp;= C4 � 2 -•• • •�••••••7(-• • ••X-• • --K••-' )(•-K-K -••</formula><p>For IFL, we need to check each posting in the postings list of each word of the incoming geo-textual object. While for BIF, postings are indexed by blocks, which may help prune the queries in a block-based manner during the search of postings list. As a result, ElF performs moderately better than IFL. However, compared with CIQ-H and CIQ, ElF does not include the spatial information of each query while building the index, and thus its pruning technique is not able to consider the spatial proximity between the queries and incoming objects. Consequently, CIQ-H and CIQ perform substantially better than ElF. In addition, CIQ improves the runtime perfonnance of CIQ-H by 10% to 30%. Such performance improvement is contributed by the cost-model based method for associating a new TaSK query onto the cells of the Quad-tree.</p><p>Figure <ref type="figure">10</ref> shows the performance of query insertion for each structure. Since CIQ-H and CIQ require the query to be stored in the postings list under each cell associated with the query, the runtime costs of query insertion for CIQ-H and CIQ are higher than IFL and ElF. However, the time for processing updates is negligible compared with the time for 264 object processing by comparing the runtime in Figure <ref type="figure">9</ref>. Here the frequency of object processing and the frequency of query insertion are the same. In the publish/subscribe scenario the frequency of query insert is normally much lower than that of object arrivals, and thus the portion of update cost will be even smaller than that shown here. Hence, in the rest of experiments, we only show the object processing cost while ignoring the update cost. Note that the deletion of queries is performed together with object processing as mentioned in Section VI and the time is included in that for object processing.</p><p>2) the Number of Query Keywords: We proceed to evaluate the effect of the number of keywords of each TaSK query. Figure <ref type="figure">11</ref> shows that all the methods present an increasing trend for the runtime of object processing as we increase the number of query keywords. This is because the number of query keywords is proportional to the number of postings required for indexing the query, which will lead to an increase in the length of each postings list. We also observe that CIQ is able to improve on the runtime of ElF by 60%-70%.</p><p>3) Effe ct of cx: In this experiment, we investigate the effect of the query preference parameter cx. We observe similar trends on both datasets. For IFL, the performance of object processing is not affected by cx. The reason is that IFL needs to retrieve and evaluate all the postings in each postings list of the object keyword while processing an incoming object, irrespective of the value of cx. Hence the value of cx will not affect the performance of IFL. However for BIF, the pruning strategy for traversing the postings lists is based on the text relevance. Consequently, more emphasis on the spatial aspect will lower the etlectiveness of the text-based pruning strategy. As for CIQ and CIQ-H, the pruning strategy is based on both spatial and text aspects. We observe that as cx becomes larger, the disparity between CIQ and BIF becomes larger. At cx = 0.9 (distance score has a high weight), CIQ improves over BIF by 70% on FSQ and 75% on TWE. When cx = 0. 1, the performances of CIQ and BIF are close.</p><p>4) the Number of Maintained Query Results: This ex periment evaluates the performance w.r.t. parameter "q.k". Figure <ref type="figure" target="#fig_8">13</ref> shows that the runtime for object processing slightly increases as we increase the value of q.k for each query. The reason is that the higher value of q.k will induce the lower value of the temporal spatial-keyword score between an incoming object and the kth result maintained for each query on average. Consequently, the average number of queries that have 0 as a result will increase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) the Number of Po stings in each Block:</head><p>This round of experiments is to evaluate the performance of the indices utilizing block structure, including CIQ, CIQ-H, and BIF, when we vary the block size. Figure <ref type="figure" target="#fig_2">14</ref> shows the trend of the object processing cost w.r.t. the block size. On FSQ, all the three indices perfonn best when each block contains 128 postings, while for TWE the value is changed to 1024. This can be explained as follows. If the block size is too small, then the number of blocks we need to evaluate will increase. On the other hand, if the block size is too large, the possibility for skipping a block will decrease despite the reduction of the number of blocks to be visited while processing an incoming object. Nevertheless, the performance is not significantly ailected by the block size for all indices.</p><p>6) the Number of Buckets in each Cell: In this experiment, we vary the number of buckets in each cell for CIQ-H and CIQ. Figure <ref type="figure" target="#fig_14">15</ref> shows that both methods exhibit better performance as we increase the number of buckets in a cell. However, when we increase the number of buckets from 16 to 64, the improvement is insignificant on both datasets. 7) the Decaying Scale: Figure <ref type="figure">16</ref> shows that the runtime for object processing decreases as we increase the decaying scale. The reason is that a lower value of decaying scale will increase the number of queries that have an incoming object to be their results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8) the Number of Indexed Queries:</head><p>We evaluate the effect of the number of indexed queries. The number of queries scales from 10M to 40M. Obviously, increasing the number of indexed queries leads to the increase of postings in each postings list. Hence, more postings will be retrieved and evaluated while processing a new object. Figure <ref type="figure">18</ref> shows that both the runtime for object processing and the index size exhibit a linearly increasing trend for all methods as we increase the number of indexed queries. Note that for CIQ the query tables (including both global query tables and local query tables) 70% to 75% of the total memory cost. We can see that memory cost would not be an issue considering the available memory of Pc. 265 9) Arrival Rate: We vary the arrival rates of both objects and queries. Figure <ref type="figure">18</ref>(a) presents the total costs in every 1 second for object processing when we vary the arrival rate of geo-textual objects from 2 to 32 object(s)/second with 10M TaSK queries indexed. We find that CIQ is capable of processing 32 geo-textual objects with 10M indexed queries while the other methods fail to handle.</p><p>Figure <ref type="figure">18</ref>(b) presents the total runtime of query insertion when we vary the arrival rate of TaSK queries. Although the query insertion cost of CIQ is moderately higher than the two baselines, the arrival rate of query is much lower than the arrival rate of object under the publish/subscribe scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. RELATED WORK</head><p>Continuous kNN Queries. Our problem is related to the problem of continuously monitoring spatial kNN queries over moving objects, which monitors the nearest k objects to a given query point among all the moving objects. Yu et al. <ref type="bibr" target="#b27">[28]</ref> and Xiong et al. <ref type="bibr" target="#b26">[27]</ref> study the problem of periodically updating results for continuous kNN queries over moving objects. Mouratidis et al. <ref type="bibr" target="#b19">[20]</ref> propose a method for evaluating continuous kNN queries based on a grid index and the concept of influence region. These proposals focus on moving objects while our work aims to handle a stream of geo-textual objects. We do not see a way to adapt them for handling TaSK queries.</p><p>Top -k Spatial Keyword Search. Top-k kNN Query (TkQ) returns k most spatial-textual relevant objects that are ranked by both spatial proximity and text relevancy. Several geo textual indices have been proposed to efficiently answer TkQ, such as the IR 2 -tree <ref type="bibr" target="#b9">[10]</ref>, the IR-tree <ref type="bibr" target="#b5">[6]</ref>, S21 <ref type="bibr" target="#b21">[22]</ref>, 1 3 <ref type="bibr" target="#b29">[30]</ref>, and IL-Quadtree <ref type="bibr" target="#b28">[29]</ref>. Among them, the IR 2 -tree <ref type="bibr" target="#b9">[10]</ref>, the IR tree <ref type="bibr" target="#b5">[6]</ref> and S21 <ref type="bibr" target="#b21">[22]</ref> are based on the R-tree, and the others are based on the Quad-tree. There exits no sensible way to adopt these methods to handle TaSK queries.</p><p>Reverse kNN Search. The TaSK query can be viewed as for each incoming geo-textual object finding the set of queries that take the geo-textual object as one of their top-k results according to the temporal spatial-textual scores. In this sense, the TaSK query is also related to the Reverse k Nearest Neighbor (RkNN) query, which is to find the set of objects that take a query as one of their kNN based on the spatial distance. The RkNN query has been studied extensively (e.g., <ref type="bibr" target="#b2">[3]</ref>, [12], <ref type="bibr" target="#b24">[25]</ref>). The textual relevance is also considered for the reverse kNN query <ref type="bibr" target="#b16">[17]</ref>. However, these techniques cannot be used for answering the TaSK query because they just consider the one-time query over static objects.</p><p>Content based Publish/Subscribe. Closest to our problem setting is the existing work on top-k publish/subscribe sys tems <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b20">[21]</ref>, <ref type="bibr" target="#b23">[24]</ref> that make published items trigger a subscription only if it ranks among the top-k published items. In the setting of most of these systems <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b20">[21]</ref>, the relevance of an item remains constant during a pre-specified time interval, and once its lifetime exceeds the item simply expires. The expired item is then replaced by the most relevant unexpired item. The setting is different from our setting where time is part of the ranking score. The setting of top k publish/subscribe system <ref type="bibr" target="#b23">[24]</ref> is similar to ours, where the published items are tweets and the subscriptions are news. The published items (e.g., tweets) do not have a fixed expiration time. Instead, time is a part of the relevance score, which decays as time passes. Older items retire from the top-k only when new items that score higher arrive. The inverted files are used as the indexes and the classic information retrieval methods are adapted for the ranking. Our work differs from this study in that both queries and objects in our work are geo textual. The spatial aspect is part of the ranking score, which renders the solution <ref type="bibr" target="#b23">[24]</ref> inapplicable, and also introduces new challenges for top-k publish/subscribe. Several publish/subscribe systems <ref type="bibr" target="#b3">[4]</ref> , <ref type="bibr" target="#b12">[13]</ref>, <ref type="bibr" target="#b25">[26]</ref> are de veloped for geo-textual objects. To index subscription queries, Chen et al. <ref type="bibr" target="#b3">[4]</ref> present a hybrid index based on Quad-tree and Inverted files, and Li et al. <ref type="bibr" target="#b12">[13]</ref> present a hybrid index based on R-tree and Inverted files. Recently, Wang et al. <ref type="bibr" target="#b25">[26]</ref> propose a novel adaptive spatial-textual partition tree that adaptively groups the subscription queries based on keyword and spatial partitions, guided by a cost model. However, their publish/subscribe problem is different from the top-k pub lish/subscribe problem, and their methods cannot be employed to handle TaSK queries.</p><p>News over Tweets Stream. Sankaranarayanan et al. <ref type="bibr" target="#b22">[23]</ref> develop a news processing system Tw itterStand to continuously acquire breaking news from the tweets generated by some selected users ("Seeders") who publish news. Their published tweets are clustered together, and each cluster of tweets is associated with a set of geographical locations by analyzing the tweet content and tweet meta-data. Users can specify the topics and geographical regions of interest, and summaries of clusters w.r.t. the specified topics and regions are displayed on the map. However, the queries in Tw itterStand are continuous spatial-keyword queries with boolean filtering expressions, which are different from our TaSK queries. More over, the work does not consider how to efficiently process a large number of subscription queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. CONCLUSION</head><p>We consider the problem of maintaining up-to-date results for a large number of TaSK queries that take into account text relevance, spatial proximity, and recency of geo-textual objects. We propose a mechanism to efficiently processing a large number of TaSK queries. In particular, based on the concept of conditional influence region, we develop an ap proach to grouping and indexing TaSK queries and generating filtering conditions for each group of queries to evaluate them simultaneously. The experimental results on two real-world datasets show that our solution is able to achieve a reduction of the processing time by 70-80% compared with two baselines.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure l .</head><label>l</label><figDesc>Figure l. Architecture for Processing TaSK Queries</figDesc><graphic coords="3,356.17,511.67,168.96,120.96" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .Figure 3 .</head><label>23</label><figDesc>Figure 2. ClRs of q</figDesc><graphic coords="4,315.85,180.48,91.20,60.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 4 :</head><label>4</label><figDesc>Minimum Conditional Te xt Score. Given query q, cell c, the kth result object Rq[k], and minD(q, c), based on Equation 5, the corresponding text relevance score at current time (teur) is computed by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>respectively. Since part (1) is time-dependent, we separately store Seq, Rq[k]) and Rq[k].te. Then given teu,.., part (1) can be computed through Seq, Rq[k]) and Rq[k].te. We also maintain two types of query tables: (1) Local query table,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 5 :DExample 4 :</head><label>54</label><figDesc>l _ cxStsk(q, Rq[k], tcur) 10 bi. To address the problem, our Idea is to unify different values of base time of all queries in a block to be a uniform base time, which is denoted by tb. In particular, for each query q we compute the equivalent spatial-keyword score of Ssk (q, Rq[k]) at the base time tb, rather than at the creation time of Rq [k] (Rq [k].tc). We next introduce how to compute equivalent spatial-keyword score. Equivalent Spatial-Keyword Score. Let q be a TaSK query, the equivalent spatial-keyword score between q and Rq[k] at time tb is computed by: S b sk( q , R q [k], tb ) = S sk( q , R q [k]) . DRq[ k J t c-tb (8) Figure6illustrates the variation of Stsk(q, Rq[k], tcur) w.r.t. the current time. t;;ur denotes the timestamp just before the current time and ttur represents the timestamp just after the current time. tb is the unified base time. Sbsk(q,Rq[k],tb) is the equivalent spatial-keyword score for q at tb. When a new object 0 arrives at tcur, we use Sbsk(q, Rq[k], tb) to compute Stsk(q, Rq[k], tcur) as follows according to Definition 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>260 bi.minS . D -( t cur-tb) -bi.minD can be the lower bound of bi.minT. Specifically, we have: bi.minT � bi.minS . D -(tcur-tb) -bi.min D (9)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>] t ) D-(tcu .. r-tb) . D ( ) i • mzn -1a b sk q m, q m ,b ' -mzn qm, C . Since l � cx Sbsk(qm' Rqm [kJ, tb) &gt; bi • minS and minD(qm, c) ::; bi.minD, we have Equation 9. D 2) Spatial-aware block structure: We proceed to present our proposed spatial-aware block structure for organizing postings lists. To filter as many blocks as possible in each postings list when a new geo-textual object arrives, we want to acquire a relatively tight lower bound for each block. If we can organize queries such that queries in a block have similar values of minT, it is more likely that we can estimate a tighter lower bound for minT. To achieve this, we partition the queries associated with cell c based on their corresponding minD(q, c) , which is invariable w.r.t. both the time and the kth result Rq [k]. Specif�cally, in each cell c queries are first partitioned by the minD-buckets (Definition 6), then queries in each bucket are indexed by a block based inverted file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .Figure 7</head><label>77</label><figDesc>Figure 7. Structure of Spatial-Aware Block Based Inverted FileFigure 7 illustrates the structure of the spatial-aware block based inverted file. The TaSK queries are firstly par titioned into a pre-specified number of buckets based on their</figDesc><graphic coords="6,372.49,560.63,138.24,62.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Lemma 3 :</head><label>3</label><figDesc>Let a be a geo-textual object, bi be a block in bucket B in the postings list of keyword W i (W i E o.'lj;), and Sgi be the subset of o.'lj; such that sg, = {wlw E o.'lj; /\p':! B ::; bi. maxI D} where P � B denotes the current position o f the cursor in the postings list of w in Bucket B under cell c. We use TRe lm ax (o.'lj;, sgJ to denote the maximum possible text relevance between o.'lj; and the queries containing keywords in Sgi' Then we have the following proposition: If bi• minT 2:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Algorithm 1 : 6 ' 9 P�Fii 11 I 14 C</head><label>1691114</label><figDesc>ObjectProcess(Object 0 ) Resul t +-0; c +-CIQ.root; 3 while cell c is not empty do 4 for each bucket Bi in c do 5 S w +-0 . 7j;; iw E S w, P'::', s, +id of the first query in I(w,c,Bi); 7 while S w =1= 0 do 8 Wm +term with the minimum P':! B for all wE S w; , , +-FindNext(wm, {P'::', BjWEsw' Resul t) ; 10 if p':Fi reaches the end of the current block bc then ' , update bc.minS ; 12 ifp�Fii reaches the end of I(wm,c,Bi) then 13 I S w +-S w \ wm; +-c's child node that contains o.p;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>4 I 5 I 7 q</head><label>457</label><figDesc>ifbc.minT2TRelmax( 0 . 7j;,s gJ then bc +-bc.nex t ; pc +-bc • hr s t ; +the query indicated by pc;8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>[J qo .�injjCqo'co) Ca) minD on Co . --:::-----&gt; minD(qo'cz) A------,.r =-----1 inD(%.c, VI / �VC3 C4 gO�:: -•l1l1IlD(qo.c,) minD(qo,c J ) (b) minDs on co's children Figure 8. minDs on cells from different layers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>mB.</head><label></label><figDesc>Inserting a TaSK Query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>3 else 4 I</head><label>34</label><figDesc>for each Ci E c . c hild re n do</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>5</head><label>5</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>2 )</head><label>2</label><figDesc>Block based Inverted File (BIF): This baseline uses a block based inverted file (ElF) to index the TaSK queries. Similar to the CIR based Quad-tree (CIQ), ElF partitions each postings list into blocks, each of which contains a pre specified number of postings. For each block bi, we maintain bi.minID, bi.maxID, and bi.minS. Similar to Algorithm 1, 263 Table II. DEFAULT VALUES FOR EACH PARAMETER Parameter Default Setting number of query keywords TWE: random from I to 5 preference parameter '" random from 0 to I number of maintained query results random from I 0 to 30 number of postings in each block FSQ: 128 TWE: I 024 number of minD-buckets for each cell 16</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>1</head><label></label><figDesc>Datasets are available at: http://www.ntu.edu.sglhome/gaocong/datacode.htm 2 http://journalistsresource.org/studies/society/social-medialmapping-global twitter-heartbeat-geography# -CIQ-H ....... 1IE .... . B lF ..... »(-.... CIQ - . § 0 L-��� �� ��----' -CIQ-H ....... 1IE ..... Btl' .... -)( ... -CIQ -B -� 150 £ 100 L . . _"' k-. .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 9 .Figure 1 L</head><label>91</label><figDesc>Figure 9. Effect of Time for Object Processing IFL -+-CIQ-H ....... 1IE .... . B[F -.. )(-... C[Q -x-.-.-�. _._ . -x-::;� �.4Number of Query Keywords (a) FSQ</figDesc><graphic coords="10,84.49,154.56,213.12,70.08" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>CC: Q -o _I �: -'1 -..... -c .. lIEc ... --, ..</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 10 .Figure 12 .</head><label>1012</label><figDesc>Figure 10. Effect of Time for Query Insertion � 40 [FL -+-ClQ-H ....... 1IE..... � IFL -+-C[Q-H ....... 1IE .... .</figDesc><graphic coords="10,315.85,154.55,212.16,55.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 13 .!Figure 16 .</head><label>1316</label><figDesc>Figure 13. Effect of # Query Results Figure 14. Effect of # Postings in a Block Figure 15. Effect of # Buckets in each Cell ! IFL --+--CIQ-I-' ....... *...... ! IFL --+--CIQ-H ...... "* ..... -� 50 BIF --*-CIQ -B-� 150 BIF .. --7( --CIQ -a--£40 2 ----x-::-:&gt;:--+---1</figDesc><graphic coords="10,236.17,349.44,332.16,50.88" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>This work is supported in part by a grant awarded by a Singapore MOE AcRF Tier 2 Grant (ARC30/ 12).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient filtering of xml documents for selective dissemination of information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Altinel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL DB</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="53" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Survival analysis for fre shness in microblogging search</title>
		<author>
			<persName><forename type="first">G</forename><surname>Amati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Amodeo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gaibisso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="2483" to="2486" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Influence zone: Efficiently processing reverse k nearest neighbors queries</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Cheema</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An efficient query indexing mechanism for filtering geo-textual data</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Cao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="749" to="760" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Spatial keyword query processing: an experimental evaluation</title>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient retrieval of the top-k most relevant spatial web objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sjensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PVLDB</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Estimation methods for ranking recent information</title>
		<author>
			<persName><forename type="first">M</forename><surname>Efron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Golovchinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGIR</title>
		<imprint>
			<publisher>ACM</publisher>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Evaluating top-k queries over incomplete data streams</title>
		<author>
			<persName><forename type="first">P</forename><surname>Haghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Aberer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="877" to="886" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The gist of everything new: Personalized top-k processing over web 2.0 streams</title>
		<author>
			<persName><forename type="first">P</forename><surname>Haghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><surname>Aberer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="489" to="498" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Keyword search on spatial databases</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Felipe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rishe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="656" to="665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Quadtree and r-tree indexes in oracle spatial: a comparison using GIS data</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Y R</forename><surname>Kanth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ravada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Abugov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="546" to="557" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Influence sets based on reverse nearest neighbor queries</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="201" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Location-aware publish/subscribe</title>
		<author>
			<persName><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="802" to="808" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Time-based language models</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Croft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="469" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Ir-tree: An efficient index for geographic document search</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>-C. Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Tra ns. Know!. Data Eng</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Time-aware topic recommendation based on micro-blogs</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Christen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1657" to="1661" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Congo Reverse spatial and textual k nearest neighbor search</title>
		<author>
			<persName><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Mercury: A memory-constrained spatio-temporal real-time search on microblogs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Magdy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Mokbel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="172" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Introduction to informa tion retrieval</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schutze</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Conceptual partitioning: An efficient method for continuous nearest neighbor mon itoring</title>
		<author>
			<persName><forename type="first">K</forename><surname>Mouratidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hadjieleftheriou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="634" to="645" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Top-klw publish/subscribe: Finding k most relevant publications in sliding time window W</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pripuzic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">P</forename><surname>Zarko</surname></persName>
		</author>
		<author>
			<persName><surname>Aberer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DEBS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="127" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient processing of top-k spatial keyword queries</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rocha-Junior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Gkorgkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jonassen</surname></persName>
		</author>
		<author>
			<persName><surname>Nprvag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSTD</title>
		<imprint>
			<biblScope unit="volume">201</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Tw itterstand: news in tweets</title>
		<author>
			<persName><forename type="first">J</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">E</forename><surname>Teitler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Lieberman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sperling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSPATlAL</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="42" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Top-k publish subscribe for social annotation of news</title>
		<author>
			<persName><forename type="first">A</forename><surname>Shraer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gurevich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fontoura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Josifovski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="385" to="396" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Reverse knn search in arbitrary dimensionality</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Lian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VL DB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="744" to="755" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Ap-tree: Efficiently support continuous spatial-keyword queries over stream</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sea-cnn: Scalable processing of continuous k-nearest neighbor queries in spatio-temporal databases</title>
		<author>
			<persName><forename type="first">X</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Mokbel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">G</forename><surname>Aref</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="643" to="654" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Monitoring k-nearest neighbor queries over moving objects</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Q</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="631" to="642" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Inverted linear quadtree: Efficient top k spatial keyword search</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="901" to="912" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Scalable top-k spatial keyword search</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K-L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Tung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="359" to="370" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
