<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fuzzing: State of the Art</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Hongliang</forename><surname>Liang</surname></persName>
							<email>hliang@bupt.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Western Michigan University</orgName>
								<address>
									<postCode>49008</postCode>
									<settlement>Kalamazoo</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaoxiao</forename><surname>Pei</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Western Michigan University</orgName>
								<address>
									<postCode>49008</postCode>
									<settlement>Kalamazoo</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaodong</forename><surname>Jia</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Member, IEEE</roleName><forename type="first">Wuwei</forename><surname>Shen</surname></persName>
							<email>wuwei.shen@wmich.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Senior Member, IEEE</roleName><forename type="first">Jian</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Beijing University of Posts and Telecommunications</orgName>
								<address>
									<postCode>100876</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Institute of Software</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<postCode>100190</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">X</forename><surname>Liang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Western Michigan University</orgName>
								<address>
									<postCode>49008</postCode>
									<settlement>Kalamazoo</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><surname>Jia</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Western Michigan University</orgName>
								<address>
									<postCode>49008</postCode>
									<settlement>Kalamazoo</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fuzzing: State of the Art</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">74A07041D36ACCAC9B1AD1F384152FCA</idno>
					<idno type="DOI">10.1109/TR.2018.2834476</idno>
					<note type="submission">received November 1, 2017; revised February 21, 2018 and April 25, 2018; accepted May 5, 2018.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-28T14:01+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Fuzzing</term>
					<term>reliability</term>
					<term>security</term>
					<term>software testing</term>
					<term>survey</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>As one of the most popular software testing techniques, fuzzing can find a variety of weaknesses in a program, such as software bugs and vulnerabilities, by generating numerous test inputs. Due to its effectiveness, fuzzing is regarded as a valuable bug hunting method. In this paper, we present an overview of fuzzing that concentrates on its general process, as well as classifications, followed by detailed discussion of the key obstacles and some stateof-the-art technologies which aim to overcome or mitigate these obstacles. We further investigate and classify several widely used fuzzing tools. Our primary goal is to equip the stakeholder with a better understanding of fuzzing and the potential solutions for improving fuzzing methods in the spectrum of software testing and security. To inspire future research, we also predict some future directions with regard to fuzzing.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>and experimental role. It serves as the standard of comparison by which other methods should be evaluated <ref type="bibr" target="#b5">[6]</ref>. Furthermore, fuzzing has gradually evolved into a synthesis technique to synergistically combine static and dynamic information of a target program so that better test cases can be produced and more bugs are detected <ref type="bibr" target="#b6">[7]</ref>.</p><p>Fuzzing simulates attacks by constantly sending malformed or semivalid test cases to the target program. Thanks to these irregular inputs, fuzzers, also named as fuzzing tools, can often find out previously unknown vulnerabilities <ref type="bibr" target="#b7">[8]</ref>- <ref type="bibr" target="#b10">[11]</ref>. That is one of the key reasons why fuzzing plays an important role in software testing. However, the blindness during a process of test case generation which can lead to low code coverage is the main drawback that fuzzing has been trying to overcome. As mentioned above, several methods have been utilized to mitigate this problem and fuzzing has made an impressive progress. Nowadays, fuzzing has been widely applied to test various software, including compilers, applications, network protocols, kernels, etc., and multiple application areas, such as evaluation of syntax error recovery <ref type="bibr" target="#b11">[12]</ref> and fault localization <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motivation</head><p>There are two reasons that motivate us to write this overview. 1) Fuzzing is getting more and more attention in the area of software security and reliability because of its effective ability to find bugs. Many IT companies such as Google and Microsoft are studying fuzzing techniques and further developing fuzzing tools (e.g., SAGE <ref type="bibr" target="#b13">[14]</ref>, Syzkaller <ref type="bibr" target="#b14">[15]</ref>, SunDew <ref type="bibr" target="#b15">[16]</ref>, etc.) to find bugs in the target program. 2) There is no systematic review of fuzzing in the past few years. Although some papers present overviews of fuzzing, they are usually review of selected articles <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b16">[17]</ref> or surveys on a specific testing topic <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref>. Therefore, we think it is necessary to write a comprehensive review to summarize the latest methods and new research results in this area. Thus, with this paper, we hope that not only the beginners can get a general understanding of fuzzing but also the professionals can have a thorough review of fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Outline</head><p>The rest of this paper is organized as follows: Section II presents the review methodology used in our survey as well as a brief summary and analysis of some selected papers. Section III describes the general process of fuzzing. Section IV introduces the classification of fuzzing methods. Section V This survey mainly aims to answer the following research questions about fuzzing.</p><p>1) RQ1: What are the key problems and the corresponding techniques in fuzzing research? 2) RQ2: What are the usable fuzzers and their known application domains? 3) RQ3: What are the future research opportunities or directions? RQ1, which is answered in Section V, allows us to explore an in-depth view on fuzzing outlining the state-of-the-art advancement in this area since its original introduction. RQ2, which is discussed in Section VI, is proposed to give an insight into the scope of fuzzing and its applicability to different domains. Finally, based on the answer to the previous questions, we expect to identify unresolved problems and research opportunities in response to RQ3, which is answered in Section VII.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Inclusion and Exclusion Criteria</head><p>We scrutinized the existing literature in order to find papers related to all aspects of fuzzing, such as methods, tools, applications to specific testing problems, empirical evaluations, and surveys. Articles written by the same authors with similar content were intentionally classified and evaluated as separate contributions for a more rigorous analysis. Then, we grouped these articles with no major differences in the presentation of results. We excluded those papers based on the following criteria:</p><p>1) not related to the computer science field; 2) not written in English; 3) not published by a reputed publisher; 4) published by a reputed publisher but with less than six pages; 5) not accessible via the Web. For instance, using the search interface of Wiley InterScience website with keywords, such as fuzzing/fuzz testing/fuzzer, we had 32 papers, seven of which are only related to computer science field according to their abstract.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Source Material and Search Strategy</head><p>In order to provide a complete survey covering all the publications relating to fuzzing, we constructed a fuzzing publication repository, which includes more than 350 papers from January 1990 to June 2017, via three steps. First, we searched some main online repositories such as IEEE XPlore, ACM Digital Library, Springer Online Library, Wiley InterScience, USENIX and Elsevier ScienceDirect Online Library, and collected papers with either "fuzz testing," "fuzzing," "fuzzer," "random testing," or "swarm testing" as keywords in their titles, abstracts, or keywords. Second, we used abstracts of the collected papers to exclude some of them based on our selection criteria. We did read through a paper if it cannot be decided by its abstract. This step was carried out by two different authors. The set of candidate papers was reduced to 171 publications within the scope of our survey. These papers are referred to as the primary studies <ref type="bibr" target="#b19">[20]</ref>. Table <ref type="table" target="#tab_0">I</ref> presents the number of primary studies retrieved from each source.</p><p>It is still possible for our search to not completely cover all the related papers since we focused on a subset of reputed publishers. However, we are confident that the overall trends in this paper are accurate and provide a fair picture of the state of the art on fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Summary of Results</head><p>The following sections summarize our primary studies in terms of publication trends, venues, authors, and geographical distribution on fuzzing.</p><p>1) Publication Trends: Fig. <ref type="figure" target="#fig_0">1</ref>(a) illustrates the number of publications about fuzzing between January, 1990 and June 30, 2017. The graph shows that the number of papers on this topic had a constant increase since 2004, especially after 2009. The cumulative number of publications is illustrated in Fig. <ref type="figure" target="#fig_0">1(b)</ref>. We calculated a close fit to a quadratic function with a high determination coefficient (R 2 = 0.992), indicating a strong polynomial growth, a sign of continued health and interest on this subject. If the trend continues, there will be more than 200 fuzzing papers published by reputed publishers by the end of 2018, three decades after this technique was first introduced.</p><p>2) Publication Venues: The 171 primary studies were published in 78 distinct venues. It means the fields covered by fuzzing literature are very wide. It is probably because this technique is very practical and has been applied to multiple testing, reliability, and security domains. Regarding the type of venues, most papers were presented at conferences and symposia (73%), followed by journals (15%), workshops (9%), and  3) Geographical Distribution of Publications: We related the geographical origin of each primary study to the affiliation country of its first coauthor. Interestingly, we found that all 171 primary studies originated from 22 different countries with USA, China, and Germany being the top three, as presented in Table <ref type="table" target="#tab_2">III</ref> (only the countries with over four papers). By continents, 43% of the papers are originated from America, 32% from Europe, 20% from Asia, and 5% from Oceania. This suggests that the fuzzing community is formed by a modest number of countries but fairly distributed around the world.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) Researchers and Organizations:</head><p>We identified 125 distinct coauthors in the 171 primary studies under review. Table <ref type="table" target="#tab_3">IV</ref> presents the top authors on fuzzing and their most recent affiliation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. GENERAL PROCESS OF FUZZING</head><p>Fuzzing is a software testing technique which can automatically generate test cases. Thus, we run these test cases on a target program, and then observe the corresponding program behavior to determine whether there is any bug or vulnerability in the target program. The general process of fuzzing is shown in Fig. <ref type="figure" target="#fig_1">2</ref>. Target program: A target program is the program under test. It could be either binary or source code. However, the source code of real-world software usually cannot be accessed easily, so fuzzers often target binary code.</p><p>Monitor: This component is generally built into a white-box or gray-box fuzzer. A monitor leverages the techniques, such as code instrumentation, taint analysis, etc., to acquire code coverage, taint data flow or other useful runtime information of the target program. A monitor is not necessary in a black-box fuzzer.</p><p>Test case generator: There are two main methods for fuzzers to generate test cases: mutation-based and grammar-based <ref type="bibr" target="#b0">[1]</ref> methods. The first method generates test inputs by mutating well-formed seed files randomly or using predefined mutation strategies which can be adjusted based on target-programoriented information gathered during runtime. On the contrary, the second method does not need any seed file. It generates inputs from a specification (e.g., grammar). In many cases, the test cases in fuzzing usually are semivalid inputs which are valid enough to pass the early parsing stage and invalid enough to trigger bugs in the deep logic of the target program.</p><p>Bug detector: To help users find potential bugs in a target program, a bug detector module is designed and implemented in a fuzzer. When the target program crashes or reports some errors, the bug detector module collects and analyzes related information (e.g., stack traces <ref type="bibr" target="#b21">[22]</ref>) to decide whether a bug exists. Sometimes, a debugger can be used manually to record exception information <ref type="bibr" target="#b22">[23]</ref>- <ref type="bibr" target="#b24">[25]</ref> as an alternative of this module.</p><p>Bug filter: Testers usually focus on correctness or security related bugs. Therefore, filtering exploitable bugs (i.e., vulnerabilities) from all the reported bugs is an important task and usually performed manually <ref type="bibr" target="#b22">[23]</ref>, which is not only time consuming but hard to tackle as well. Currently, some research works <ref type="bibr" target="#b25">[26]</ref> have proposed various approaches to mitigate this problem. For example, by sorting the fuzzer's outputs (bug-inducing test cases), the diverse, interesting test cases are prioritized, and testers do not need to manually search for wanted bugs, which is a process like looking for a needle in a haystack.</p><p>To explain the process of fuzzing more clearly, as an example, we use American fuzzy lop (AFL) <ref type="bibr" target="#b26">[27]</ref>, a mutation-based coverage-guided fuzzer, to test png2swf, a file converter. In this example, we provide the png2swf executable file for AFL as its target program. First, we provide a few seed files (the ideal seeds should be well formed and of small size) for AFL since it adopts the mutation-based technique. Second, we run AFL by a simple command (e.g., "afl-fuzz -i [input_directory] -o [output_directory] -Q -[target_directory] (@@)", if the target program gets input from a file, then "@@" is necessary). During the testing process, the "Monitor" component of AFL collects specific runtime information (path-coverage information in this case) by binary instrumentation, then passes these information to the "Test Case Generator" component to help guide its test case generation process. The general strategy is to save those test cases, which are able to cover new program paths for the next round of mutation, and discard those otherwise. Third, the newly generated test cases are passed back to the "Monitor" as the inputs of the target program. This process continues until we stop the AFL instance or a given time limit is reached. Besides, AFL also prints some useful information on the screen during the runtime, such as the execution time, the number of unique crashes, the execution speed, etc. So, we may get a set of test cases which can crash the target program. Finally, we analyze the test cases and identify those bugs that crash the target program manually or with the help of other tools. The bugs that AFL finds are mainly relative to memory operations, like buffer overflow, access violation, stack smash, etc., which usually cause the program crash or may be exploited by crackers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BLACK, WHITE, OR GRAY?</head><p>Fuzzing techniques can be divided into three kinds: black box, white box, and gray box depending on how much information they require from the target program at runtime <ref type="bibr" target="#b27">[28]</ref>. The information can be code coverage, data-flow coverage, program's memory usage, CPU utilization, or any other information to guide test case generation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Black-Box Fuzzing</head><p>Traditional black-box fuzzing is also known as "black-box random testing." Instead of requiring any information from the target program or input format, black-box random testing uses some predefined rules to randomly mutate the given well-formed seed file(s) to create malformed inputs. The mutation rules could be bit flips, byte copies, or byte removals <ref type="bibr" target="#b27">[28]</ref>, etc. Recent black-box fuzzing also utilizes grammar <ref type="bibr" target="#b28">[29]</ref> or input-specific knowledge <ref type="bibr" target="#b29">[30]</ref> to generate semivalid inputs.</p><p>Black-box fuzzers, such as fuzz <ref type="bibr" target="#b30">[31]</ref> and Trinity <ref type="bibr" target="#b31">[32]</ref>, are popular in software industry due to its effectiveness in finding bugs and simplicity for use. For instance, Trinity aims to fuzz system call interfaces of the Linux kernel. Testers should describe the type of input by using the provided templates first. Then, Trinity can generate more valid inputs which can reach higher coverage. This fuzzer has found plenty of bugs. 1  However, the drawback of this technique is also obvious. Consider the function shown in Fig. <ref type="figure" target="#fig_2">3</ref>. The abort() function at Line 7 has only 1/2 32 chance to be reached when the input parameter at line 1 is assigned randomly. This example intuitively explains why it is difficult for black-box fuzzing to generate test cases that cover large number of paths in a target program. Due to this blindness nature, black-box fuzzing often provides low code coverage in practice <ref type="bibr" target="#b32">[33]</ref>. That is why recent fuzzer developers have mainly focused on reverse engineering <ref type="bibr" target="#b33">[34]</ref>, code instrumentation <ref type="bibr" target="#b34">[35]</ref>, taint analysis <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b36">[37]</ref>, and other techniques to make the fuzzer "smarter" in order to mitigate this problem, which is why white-box and gray-box fuzzing have received more attention recently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. White-Box Fuzzing</head><p>White-box fuzzing is based on the knowledge of internal logic of the target program <ref type="bibr" target="#b16">[17]</ref>. It uses a method which in theory can explore all execution paths in the target program. It was first proposed by Godefroid et al. <ref type="bibr" target="#b37">[38]</ref>. In order to overcome the blindness of black-box fuzzing, they dedicated to exploring an alternative method and called it white-box fuzzing <ref type="bibr" target="#b13">[14]</ref>. By using dynamic symbolic execution (also known as concolic execution <ref type="bibr" target="#b38">[39]</ref>) and coverage-maximizing heuristic search algorithm, white-box fuzzing can search the target program thoroughly and quickly.</p><p>Unlike black-box fuzzing, white-box fuzzing requires information from the target program and uses the required information to guide test case generation. Specifically, starting execution with a given concrete input, a white-box fuzzer first gathers symbolic constraints at all conditional statements along the execution path under the input. Therefore, after one execution, the white-box fuzzer combines all symbolic constraints together using logic AND to form a path constraint (PC for short). Then, the white-box fuzzer systematically negates one of the constraints and solves the new PC. The new test case leads the program to run a different execution path. Using a coverage-maximizing 1 http://codemonkey.org.uk/projects/trinity/bugs-found.php heuristic search algorithm, white-box fuzzers can find bugs in the target program as fast as possible <ref type="bibr" target="#b37">[38]</ref>.</p><p>In theory, white-box fuzzing can generate test cases which cover all the program paths. In practice, however, due to many problems such as the numerous execution paths in a real software system and the imprecision of solving a constraint during symbolic execution (see Section V-B for details), the code coverage of white-box fuzzing cannot achieve 100%. One of the most famous white-box fuzzers is SAGE <ref type="bibr" target="#b13">[14]</ref>. SAGE targets large-scale Windows applications and uses several optimizations to deal with the huge number of execution traces. It can automatically find software bugs and has achieved impressive results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Gray-Box Fuzzing</head><p>Gray-box fuzzing stands in the middle of black-box fuzzing and white-box fuzzing to effectively reveal software errors with partial knowledge of the target program. The commonly used method in gray-box fuzzing is code instrumentation <ref type="bibr" target="#b39">[40]</ref>, <ref type="bibr" target="#b40">[41]</ref>. By this means, a gray-box fuzzer can obtain code coverage of the target program at runtime; then, it utilizes this information to adjust (e.g., by using a genetic algorithm <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b41">[42]</ref>) its mutation strategies to create test cases which may cover more execution paths or find bugs faster. Another method used in gray-box fuzzing is taint analysis <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b42">[43]</ref>- <ref type="bibr" target="#b44">[45]</ref>, which extends code instrumentation for tracing taint data flow. Therefore, a fuzzer can focus on mutating specific fields of input which can influence the potential attack points in the target program.</p><p>Gray-box and white-box fuzzing are quite similar in that both methods make use of information of the target program to guide test case generation. But there is also an obvious difference between them: gray-box fuzzing only utilizes some runtime information (e.g., code coverage, taint data flow, etc.) of the target program to decide which paths have been explored <ref type="bibr" target="#b27">[28]</ref>. Also, gray-box fuzzing only uses the acquired information to guide test case generation, but it cannot guarantee that using this piece of information will surely generate better test cases to cover new paths or trigger specific bugs. By contrast, white-box fuzzing utilizes source codes or binary codes of the target program to systemically explore all the execution paths. By using concolic execution and a constraint solver, white-box fuzzing can make sure that the generated test cases will lead the target program to explore new execution paths. Thus, white-box fuzzing helps reducing the blindness during fuzzing process more thoroughly. In summary, both methods make use of information of the target program to mitigate blindness of black-box fuzzing, but to different degrees.</p><p>BuzzFuzz <ref type="bibr" target="#b45">[46]</ref> is a good example of showing how gray-box fuzzer works, although the developer of BuzzFuzz called it a white-box fuzzer. We regard this tool as a gray-box fuzzer, because it only acquires partial knowledge (taint data flow) of the target program. BuzzFuzz works as follows. First, it instruments the target program to trace tainted well-formed input data. Then, based on the collected taint propagation information, it calculates which part of the input data may influence the predefined attack points (BuzzFuzz regards lib calls as potential attack points) in the target program. Next, it mutates sensitive parts of the input data to create new test cases. Finally, it executes the new test cases and observes whether the target program crashes or not. By this means, BuzzFuzz can find bugs in a more targetoriented and effective manner. More importantly, attack points can be defined as specific lib calls, or vulnerability patterns, etc., depending on a developer's concern.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. How to Choose?</head><p>According to the possibilities of being triggered or found, bugs can be classified into two categories: "shallow" bugs and "hidden" bugs. The bugs that cause the target program crash in the early stage of execution are regarded as "shallow" bugs, e.g., a potential divide-by-zero operation without any precedent conditional branch. On the contrary, the bugs which exist deeply in the program logic and are hard to trigger are regarded as "hidden" bugs, such as bugs existing in complex conditional branches. There is no standard way to identify "shallow" and "hidden" bugs; therefore, the commonly used evaluation criteria of a fuzzer are the code coverage it achieves, the number and exploitability of bugs it finds. In general, a traditional black-box fuzzer, which only uses random mutation method to generate test cases, cannot reach high code coverage and thus usually finds shallow bugs; however, it is lightweight, fast, and easy to use. By comparison, white-box or gray-box fuzzers can achieve higher code coverage and usually find more hidden bugs than black-box fuzzers, but these fuzzers are more complicated to build and the fuzzing processes are more time consuming than black-box fuzzers.</p><p>Fuzzing techniques that only use simple mutation methods are usually regarded as "dumb" fuzzing, such as the famous "5-lines of Python" method used by Charlie Miller,<ref type="foot" target="#foot_0">2</ref> which only randomly mutates some bytes of an input file without knowing its format. On the contrary, those techniques utilizing the input's specification or other knowledge or adopting runtime information (e.g., path coverage) to guide the test case generation are usually considered as "smart" fuzzing. In general, "dumb" and "smart" fuzzing methods provide different cost/precision tradeoffs and are suitable for different situations. For testers, which kind of fuzzer to choose mainly depends on two factors: 1) the type of the target program and 2) the test requirements (time/cost, etc.). In case that the input format of a target program (e.g., complier, system call, network protocol, etc.) is specific or strict, it will be more effective to choose a grammar-based fuzzer (many of this kind of fuzzers are black-box, such as Trinity <ref type="bibr" target="#b31">[32]</ref> but developers recently built gray-box fuzzers targeting this sort of software, like Syzkaller <ref type="bibr" target="#b14">[15]</ref>). In other cases, testers should consider more about the test requirements. If the primary goal of testing is efficiency rather than precision or high-quality output, black-box fuzzing will be a good choice. For instance, if a software system is not tested before and testers want to find and eliminate "shallow" bugs as quickly as possible, black-box fuzzing is a good start. On the contrary, if testers focus more on the quality of output (i.e., the variety, exploitability, and number of the discovered bugs) and want to achieve a higher code coverage, gray-box (sometimes white-box) fuzzing is usually more suitable <ref type="bibr" target="#b13">[14]</ref>. Compared with gray-box fuzzing, whitebox fuzzing is not very practical in industry (although SAGE is a famous white-box fuzzer in the market) because this technique is very expensive (time/resource-consuming) and faces many challenges (e.g., path explosion, memory modeling, constraint solving, etc.). However, white-box fuzzing is a popular research direction with lots of potential.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. STATE OF THE ART IN FUZZING</head><p>According to the general process of fuzzing described in Section III, the following questions should be considered at the time of building a fuzzer:</p><p>1) how to generate or select seeds and other test cases;</p><p>2) how to validate those inputs against the specification of the target program; 3) how to deal with those crash-inducing test cases; 4) how to leverage runtime information; 5) how to improve the scalability of fuzzing. In this section, we address RQ1 by summarizing the main contributions to above five issues of fuzzing in the literature. We review the papers related to seed generation and selection in Section V-A, input validation and coverage in Section V-B, runtime information and effectiveness in Section V-C, crashinducing test cases handling in Section V-D, and scalability in fuzzing in Section V-E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Seeds Generation and Selection</head><p>Given a target program to fuzz, the tester first needs to find the input interface (e.g., stdin file) so that the target program could read from a file, then determine the file formats which the target program can accept, and then choose a subset of collected seed files to fuzz the target program. The quality of seed files may highly influence the fuzzing result. Therefore, how to generate or select suitable seed files in order to discover more bugs is an important issue. Some research works have been carried out to address this problem. Rebert et al. <ref type="bibr" target="#b46">[47]</ref> tested six kinds of selection algorithms:</p><p>1) the set cover algorithm from Peach; 2) a random seed selection algorithm; 3) a minimal set cover (same as minset, which can be calculated by the greedy algorithm); 4) a minimal set cover weighted by size; 5) a minimal set cover weighted by execution time; 6) a hotset algorithm (which fuzz tests each seed file for t seconds, ranks them by the number of unique found bugs, and returns the top several seed files in the list). By spending 650 CPU days on Amazon Elastic Compute Cloud for fuzzing ten applications, they drew the following conclusions.</p><p>1) The algorithms employing heuristics perform better than fully random sampling.</p><p>2) The unweighted minset algorithm performs the best among these six algorithms.</p><p>3) A reduced set of seed files performs more efficiently than the original set in practice. 4) Reduced set of seeds can be applied to different applications parsing the same file type. Kargén and Shahmehri <ref type="bibr" target="#b47">[48]</ref> claimed that by performing mutations on the generating program's machine code instead of directly on a well-formed input, the resulting test inputs are closer to the format expected by the program under test, and thus yield better code coverage. To test complex software (e.g., PDF readers) that usually take various inputs embedded with multiple objects (e.g., fonts, pictures), Liang et al. <ref type="bibr" target="#b48">[49]</ref> leveraged the structure information of the font files to select seed files among the heterogeneous fonts. Skyfire <ref type="bibr" target="#b49">[50]</ref> took as inputs a corpus and a grammar, and used the knowledge in the vast number of existing samples to generate well-distributed seed inputs for fuzzing programs that process highly structured inputs. An algorithm was presented in <ref type="bibr" target="#b50">[51]</ref> to maximize the number of bugs found for black-box mutational fuzzing given a program and a seed input. The main idea behind this is to leverage white-box symbolic analysis on an execution trace for a given programseed pair to detect dependences among the bit positions of an input, and then use this dependence relation to compute a probabilistically optimal mutation ratio for this program-seed pair. Furthermore, considering fuzzing as an instance of the coupon collector's problem in probability analysis, Arcuri et al. <ref type="bibr" target="#b51">[52]</ref> proposed and proved nontrivial, optimal lower bounds for the expected number of test cases sampled by random testing to cover predefined targets, although how to achieve the bounds goal in practice is not given.</p><p>For random generation of unit tests of object-oriented programs, Pacheco et al. <ref type="bibr" target="#b52">[53]</ref> proposed to use feedback obtained from executing the sequence as it is being constructed, in order to guide the search toward sequences that yield new and legal object states. Therefore, inputs that create redundant or illegal states are never extended. However, Yatoh et al. <ref type="bibr" target="#b53">[54]</ref> argued that feedback guidance may overdirect the generation and limit the diversity of generated tests, and proposed an algorithm named feedback-controlled random testing, which controls the amount of feedback adaptively.</p><p>How can we get original seed files in the first place? For some open-source projects, the applications are published with a vast of input data for testing, which can be freely obtained as quality seeds for fuzzing. For example, FFmpeg automated testing environment (FATE) <ref type="bibr" target="#b54">[55]</ref> provides various kinds of test cases which can be hard to collect on testers' own strength. Sometimes, the testing data are not publicly available, but the developers are willing to exchange it with people who will report program bugs in return. Some other open-source projects also provide format converters. Therefore, with a variety of file sets in certain format, the tester can obtain decent seeds for fuzzing by using format converter. For instance, cwebp <ref type="bibr" target="#b55">[56]</ref> can convert TIFF/JPEG/PNG to WEBP images. Furthermore, reverse engineering is helpful to provide seed input for fuzzing. Prospex <ref type="bibr" target="#b56">[57]</ref> can extract network protocol specifications including protocol state machines and use them to automatically generate input for a stateful fuzzer. Adaptive random testing (ART) <ref type="bibr" target="#b57">[58]</ref> modifies random testing by sampling the space of tests and only execut-ing those most distant, as determined by a distance metric over inputs, from all previously executed tests. ART has not always been shown to be effective for complex real-world programs <ref type="bibr" target="#b58">[59]</ref>, and has mostly been applied to numeric input programs.</p><p>Compared to the approaches mentioned above, gathering seed files by crawling the Internet is more general. Based on specific characters (e.g., file extension, magic bytes, etc.), testers can download required seed files. It is not a severe problem if the gathered corpus is huge, since storage is cheap and the corpus can be compacted to a smaller size while reaching equivalent code coverage <ref type="bibr" target="#b59">[60]</ref>. To reduce the number of fault-inserted files and maintain the maximum test case coverage, Kim et al. <ref type="bibr" target="#b60">[61]</ref> proposed to analyze fields of binary files by tracking and analyzing stack frames, assembly codes, and registers as the target software parses the files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Input Validation and Coverage</head><p>The ability of automatically generating numerous test cases to trigger unexpected behaviors of the target program is a significant advantage of fuzzing. However, if the target program has input validation mechanism, these test cases are quite likely to be rejected in the early stage of execution. Therefore, how to overcome this obstacle is a necessary consideration when testers start to fuzz a program with such a mechanism.</p><p>1) Integrity Validation: During the transmission and storage, errors may be introduced into the original data. In order to detect these "distorted" data, the checksum mechanism is often used in some file formats (e.g., PNG) and network protocols (e.g., TCP/IP) to verify the integrity of their input data. Using the checksum algorithm (e.g., hash function), the original data are attached with a unique checksum value. For the data receiver, the integrity of the received data can be verified by recalculating checksum value with the same algorithm and comparing it to the attached one. In order to fuzz this kind of system, additional logic should be added into the fuzzer, so that the correct checksum values of newly created test cases can be calculated. Otherwise, the developer must utilize other methods to remove this obstacle. Wang et al. <ref type="bibr" target="#b35">[36]</ref>, <ref type="bibr" target="#b61">[62]</ref> proposed a novel method to solve this problem and developed a fuzzer named TaintScope. TaintScope first uses dynamic taint analysis and predefined rules to detect potential checksum points and hot input bytes which can contaminate sensitive application programming interfaces (APIs) in the target program. Then, it mutates the hot bytes to create new test cases and changes the checksum points to let all created test cases pass the integrity validation. Finally, it fixes the checksum value of those test cases which can make the target program crash by using symbolic execution and constraint solving. By this means, it can create test cases which can both pass the integrity validation and cause the program to crash.</p><p>Given a set of sample inputs, Höschele and Zeller <ref type="bibr" target="#b62">[63]</ref> used dynamic tainting to trace the data flow of each input character, and aggregated those input fragments into lexical and syntactical entities. The result is context-free grammar that reflects valid input structure, which is helpful for the later fuzzing process. To mitigate coverage-based fuzzers' limitation to exercise the paths protected by magic bytes comparisons, Steelix <ref type="bibr" target="#b63">[64]</ref> lever-aged lightweight static analysis and binary instrumentation to provide not only coverage information but comparison progress information to a fuzzer as well. Such program state information informs a fuzzer about where the magic bytes are located in the test input and how to perform mutations to match the magic bytes efficiently. There are some other efforts <ref type="bibr" target="#b64">[65]</ref>, <ref type="bibr" target="#b65">[66]</ref>, which have made progress in mitigating this problem.</p><p>2) Format Validation: Network protocols, compilers, interpreters, etc., have strict requirements on input formats. Inputs that do not meet format requirements will be rejected at the beginning of program execution. Therefore, fuzzing this kind of target systems needs additional techniques to generate test cases which can pass the format validation. Most solutions of this problem are to utilize input specific knowledge or grammar. Ruiter and Poll <ref type="bibr" target="#b29">[30]</ref> evaluated nine commonly used transport layer security (TLS) protocol implementations by using blackbox fuzzing in combination with state machine learning. They provided a list of abstract messages (also known as input alphabet) which can be translated by test harness into concrete messages sent to the system under test. Dewey et al. <ref type="bibr" target="#b66">[67]</ref>, <ref type="bibr" target="#b67">[68]</ref> proposed a novel method to generate well-typed programs which use complicated type system by means of constraint logic programing (CLP) and applied their method to generate Rust or JavaScript programs. Cao et al. <ref type="bibr" target="#b68">[69]</ref> first investigated the input validation situation of Android system services and for Android devices they built an input validation vulnerability scanner. This scanner can create semivalid arguments which can pass the preliminary check implemented by the method of target system service. There are some other works, such as <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b69">[70]</ref>, and <ref type="bibr" target="#b70">[71]</ref>, that focus on solving this problem.</p><p>3) Environment Validation: Only under certain environment (i.e., particular configurations, a certain runtime status/condition, etc.), will many software vulnerabilities reveal themselves. Typical fuzzing cannot guarantee the syntactic and semantic validity of the input, or the percentage of the explored input space. To mitigate these problems, Dai et al. <ref type="bibr" target="#b71">[72]</ref> proposed the configuration fuzzing technique whereby the configuration of the running application is mutated at certain execution points, in order to check for vulnerabilities that only arise in certain conditions. FuzzDroid <ref type="bibr" target="#b72">[73]</ref> can also automatically generate an Android execution environment where an app exposes its malicious behavior. FuzzDroid combines an extensible set of static and dynamic analyses through a search-based algorithm that steers the app toward a configurable target location.</p><p>4) Input Coverage: Tsankov et al. <ref type="bibr" target="#b73">[74]</ref> defined semivalid input coverage (SVCov) that is the first coverage criterion for fuzz testing. The criterion is applicable whenever the valid inputs can be defined by a finite set of constraints. By increasing coverage under SVCov, they discovered a previously unknown vulnerability in a mature Internet Key Exchange (IKE) implementation. To address shortcomings of existing grammar inference algorithms, which are severely slow and overgeneralized, Bastani et al. <ref type="bibr" target="#b74">[75]</ref> presented an algorithm for synthesizing a contextfree grammar encoding the language of valid program inputs from a set of input examples and black-box access to the program. Unlike many methods which take the crash of the target program to determine whether an input is effective, ArtFuzz <ref type="bibr" target="#b75">[76]</ref> aims at catching the noncrash buffer overflow vulnerabilities. It leverages type information and dynamically discovers likely memory layouts to help the fuzzing process. If a buffer border identified from the memory layout is exceeded, an error will be reported.</p><p>Considering increased diversity leads to improved coverage and fault detection, Groce et al. <ref type="bibr" target="#b76">[77]</ref> proposed a low-cost and effective approach, called swarm testing, to increase the diversity of (randomly generated) test cases, which uses a diverse swarm of test configurations, each of which deliberately omits certain API calls or input features. Furthermore, to mitigate the inability to focus on part of a system under test, directed swarm testing <ref type="bibr" target="#b77">[78]</ref> leveraged swarm testing and recorded statistical data on past testing results to generate new random tests that target any given source code element. Based on the observation that developers sometimes accompany submitted patches with a test case that partially exercises the new code, and this test case could be easily used as a starting point for the symbolic exploration, Marinescu and Cadar <ref type="bibr" target="#b78">[79]</ref> provided an automatic way to generate test suites that achieve high coverage of software patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Handling Crash-Inducing Test Cases</head><p>Software companies (e.g., Microsoft) and open-source projects (e.g., Linux) often use fuzzing to improve the quality and reliability of their products <ref type="bibr" target="#b16">[17]</ref>. Although fuzzing is good at generating crash-inducing test cases, it is usually not smart enough to analyze the importance of these test cases automatically. If fuzzing results in a bunch of raw crash-inducing test cases, it takes testers a large amount of time to find different bugs in the target program by analyzing these test cases. Due to time or budget constraints, developers prefer to fix those severe bugs.</p><p>Currently, only a few efforts focus on how to filter raw fuzzing outputs that make the fuzzing results more useful to testers. Given a large collection of test cases, each of which can trigger program bugs, Chen et al. <ref type="bibr" target="#b25">[26]</ref> proposed a ranking-based method by which the test cases inducing different bugs are put on the top in the list. This ranking-based method is more practical compared with traditional clustering methods <ref type="bibr" target="#b79">[80]</ref>, <ref type="bibr" target="#b80">[81]</ref>. Therefore, testers can focus on analyzing the top crash-inducing test cases. Besides filtering crash-inducing test cases directly, there are also some other methods to help reduce expensive manual work, such as generating unique crash-inducing test cases, trimming test cases, and providing useful debug information.</p><p>The uniqueness of crash-inducing test cases can be quite reliably determined by the call stack of the target thread and the address of fault-causing instruction <ref type="bibr" target="#b81">[82]</ref>. If two distinct test cases cause the target program to crash with identical call stacks, it is very likely that these two test cases correspond to the same bug; therefore, only one of them needs to be reserved for manual analysis. On the contrary, if they cause the target program to crash at the same location but with different stack traces, it is quite possible that they correspond to two distinct bugs, and thus both of them are worth analyzing separately. Compared with recording the call stack, tracing execution path is a simpler but less reliable way to determine uniqueness. AFL <ref type="bibr" target="#b26">[27]</ref>, one of the most popular fuzzers, treats a crash-inducing test case as unique if it finds a new path or does not find a common path. This easy-to-implement approach is similar to the execution path record method which is the foundation of AFL. Producing unique crash-inducing test cases can help reduce the redundant fuzzing outputs, thus can save time and effort for manual analysis.</p><p>The size of test cases can greatly influence the efficiency of manual analysis, because larger test cases cost more time to execute and locate fault-causing instructions. For a mutation-based fuzzer, if low-quality seed files are used, the size of the generated test cases can be iteratively increased under some kinds of mutation methods. Therefore, during the process of fuzzing, periodically trimming the generated test cases can improve the overall efficiency, thus reducing the workload of manual analysis of crash-inducing test cases. The principle of trimming is simple: behavior of the processed one should be identical to the original one; in other words, they should follow the same execution path. The general steps of trimming are sequentially removing data blocks from a test case and re-evaluating the rest of the test case; those data blocks that cannot influence the execution path will be trimmed.</p><p>Evaluating the exploitability of fuzzing outputs usually needs code analysis and debugging work which can benefit from specialized tools, such as GDB, Valgrind <ref type="bibr" target="#b40">[41]</ref>, AddressSanitizer <ref type="bibr" target="#b82">[83]</ref>, etc. These tools provide runtime context (e.g., the state of call stack and registers, the address of fault-inducing instruction, etc.) of the target program or can detect particular kind of program fault such as memory error. With their assistance, testers are able to discover and evaluate program bugs more efficiently. Additionally, Pham et al. <ref type="bibr" target="#b83">[84]</ref> presented a method for generating inputs which reach a given "potentially crashing" location. The test input generated by their method served as a witness of the crash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Leveraging Runtime Information</head><p>As two of popular program analysis techniques, symbolic execution and dynamic taint analysis are often leveraged to make fuzzing smart because they can provide much runtime information (such as code coverage, taint data flow) and help fuzzing find "hidden" bugs <ref type="bibr" target="#b84">[85]</ref>, <ref type="bibr" target="#b85">[86]</ref>. However, the problems they have also hinder fuzzing from pursuing higher efficiency <ref type="bibr" target="#b86">[87]</ref>. In this section, we will discuss the problems, such as path explosion, imprecise symbolic execution faced by concolic execution and undertainting, and overtainting faced by dynamic taint analysis, and summarize the corresponding solutions. Knowing them can help readers have a more thorough understanding of smart fuzzing.</p><p>1) Path Explosion: Path explosion is an inherent and the toughest problem in symbolic execution because conditional branches in the target program are usually numerous, even a small-size application can produce a huge number of execution paths.</p><p>From the aspects of program analysis method and path search algorithm, several researches have tried to mitigate this problem.</p><p>For example, function summaries <ref type="bibr" target="#b87">[88]</ref>, <ref type="bibr" target="#b88">[89]</ref> are used to describe properties of low-level functions so that high-level functions can reuse them to reduce the number of execution paths. Redundant path pruning is used to avoid execution of those paths which have the same side effects with some previously covered paths. For instance, Boonstoppel et al. <ref type="bibr" target="#b89">[90]</ref> proposed a technique for detecting and discarding large number of redundant paths by tracking read and write operations performed by the target program. The main idea behind this technique is that if a path reaches a program point under the same condition as some previously explored paths, then the path leading to an identical subsequent effect can thus be pruned. Besides, merging states <ref type="bibr" target="#b90">[91]</ref> obtained on different paths can also reduce the path search space, but this method aggravates the solver's burden.</p><p>Heuristic search algorithms, on the other hand, can explore the most relevant execution paths as soon as possible within a limited time. For example, random path selection <ref type="bibr" target="#b91">[92]</ref> and automatic partial loop summarization <ref type="bibr" target="#b92">[93]</ref> were proven successful in practice mainly because they avoid being stuck when meeting some tight loop which can rapidly create new states. Another example is the control flow graph (CFG)-directed path selection <ref type="bibr" target="#b93">[94]</ref>, which utilizes static control flow graph to guide the test case generation to explore the closest uncovered branch. Experiment shows that this greedy approach can help improve coverage faster and achieve a higher percentage of code coverage. Besides, there is also generational search <ref type="bibr" target="#b37">[38]</ref> which explores all subpaths of each expanded execution, scores them, and finally picks a path with the highest score for next execution. Considering that existing coverage-based gray-box fuzzing tools visit too many states in high-density regions; Böhme et al. <ref type="bibr" target="#b94">[95]</ref> proposed and implemented several strategies to force AFL <ref type="bibr" target="#b26">[27]</ref> to generate fewer inputs for states in a high-density region via visiting more states that are otherwise hidden in a low-density region. To mitigate the path explosion problem, DeepFuzz <ref type="bibr" target="#b95">[96]</ref> assigned probabilities to execution paths and applied a new search heuristic that can delay path explosion effectively into deeper layers of the tested binary. Given a suite of existing test cases, Zhang et al. <ref type="bibr" target="#b96">[97]</ref> leveraged test case reduction and prioritization methods to improve the efficiency of seeded symbolic execution, with the goal of gaining incremental coverage as quickly as possible.</p><p>2) Imprecise Symbolic Execution: The imprecision of symbolic execution is mainly caused by complicated program structures (e.g., pointers) modeling, library, or system calling and constraint solving. Some simplification methods are necessary to be carried out in the aforementioned areas in order to make symbolic execution practicable. Therefore, the key point for developers is to find a balance between scalability and precision.</p><p>Currently, some methods have been proposed to make symbolic execution more practical at the cost of precision. The operations of pointer are simplified in CUTE <ref type="bibr" target="#b97">[98]</ref>, which only considers equality and inequality predicates when dealing with symbolic pointer variables. Pointers are regarded as arrays in KLEE <ref type="bibr" target="#b91">[92]</ref>. KLEE copies the present state N times, when a pointer p indirectly refers to N objects, and in each state, it implements proper read or write operation in the premise that p is not beyond the bounds of the corresponding object. It will use concrete values instead of symbolic values at the library or system call sites where the source code is not accessible <ref type="bibr" target="#b98">[99]</ref>. In addition, constraint solving is added with lots of constraint optimizations <ref type="bibr" target="#b99">[100]</ref> (e.g., SAGE uses unrelated constraint elimination, local constraint caching, flip count limit, etc., to improve the memory usage and speed when generating constraints) or even input grammar (e.g., Godefroid et al. <ref type="bibr" target="#b35">[36]</ref> proposed an approach by which constraints based on input grammar can be directly generated by symbolic execution. Then, the satisfiability of these constraints will be verified by a customized constraint solver which also leverages input grammar. Therefore, it can generate highly structured inputs).</p><p>To fuzz testing floating-point (FP) code which may also result in imprecise symbolic execution, Godefroid and Kinder <ref type="bibr" target="#b101">[102]</ref> combined a lightweight local path-insensitive "may" static analysis of FP instructions with a high-precision whole-program path-sensitive "must" dynamic analysis of non-FP instructions. Fu and Su <ref type="bibr" target="#b102">[103]</ref> turned the challenge of testing FP code into the opportunity of applying unconstrained programming-the mathematical solution for calculating function minimum points over the entire search space. They derived a representing function from the FP code, any of whose minimum points is a test input guaranteed to exercise a new branch of the tested program.</p><p>3) Undertainting: Undertainting happens when implicit data flow in which data transmission is associated with control flow, and array operation, etc., are totally neglected. As shown in Fig. <ref type="figure" target="#fig_3">4</ref>, during the conversion from plain text to Rich Text Format, the value of the input variable is transferred into output array without a direct assignment. Therefore, if input is tainted, neglecting this implicit data flow will cause undertainting. Kang et al. <ref type="bibr" target="#b43">[44]</ref> have made a progress to solve this problem. According to their experiment, taint propagation for all implicit flows also leads to unacceptable-large overtainting. Therefore, they only focused on the taint propagation for complete informationpreserving implicit flows like the example shown in Fig. <ref type="figure" target="#fig_3">4</ref>.</p><p>4) Overtainting: Overtainting happens when taint propagation is not implemented at finer grained granularity. It causes taint explosion and false positive. Yadegari et al. <ref type="bibr" target="#b103">[104]</ref> proposed an approach which fulfills taint propagation at bit level to mitigate this problem. Another method of dealing with this issue is to use underapproximations to check existential "for-some-path" properties. Godefroid <ref type="bibr" target="#b88">[89]</ref> proposed a new approach to test generation where tests are derived from validity proofs of first-order logic formulas, rather than satisfying assignments of quantifier-free first-order logic formulas as most current approaches do. For more detailed information about symbolic execution and taint analysis, refer to professional literatures <ref type="bibr" target="#b38">[39]</ref>, <ref type="bibr" target="#b104">[105]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Scalability in Fuzzing</head><p>Facing the size and complexity of real-world applications, modern fuzzers tend to be either scalable but not effective in exploring bugs located deeper in the target program, or not scalable yet capable of penetrating deeper in the application. Arcuri et al. <ref type="bibr" target="#b105">[106]</ref> discussed the scalability of fuzzing, which under certain conditions, can fare better than a large class of partition testing techniques.</p><p>Bounimova et al. <ref type="bibr" target="#b106">[107]</ref> reported experiences with constraintbased white-box fuzzing in production across hundreds of large Windows applications and over 500 machine years of computation from 2007 to 2013. They extended SAGE with logging and control mechanisms to manage multimonth deployments over hundreds of distinct application configurations. They claimed their work as the first production use of white-box fuzzing and the largest scale deployment of white-box fuzzing to date. Some approaches leveraged application-aware fuzzing or fuzzing by cloud services methods for this issue. Rawat et al. <ref type="bibr" target="#b107">[108]</ref> presented an application-aware evolutionary fuzzing strategy that does not require any prior knowledge of the application or input format. In order to maximize coverage and explore deeper paths, they leveraged control-and data-flow features based on static and dynamic analysis to infer fundamental properties of the application, which enabled much faster generation of interesting inputs compared to an application-agnostic approach.</p><p>A method for improving scalability is to reduce the scope of the analysis. Regression analysis is a well-known example where the differences between program versions serve as the basis to reduce the scope of the analysis. DiSE <ref type="bibr" target="#b108">[109]</ref> combines two phases: static analysis and symbolic execution. The set of affected program instructions is generated in the first phase. The information generated by the static analysis is then used to direct symbolic execution to explore only the parts of the programs affected by the changes, potentially avoiding a large number of unaffected execution paths.</p><p>To test mobile apps in a scalable way, every test input needs to be running with a variety of contexts, such as: device heterogeneity, wireless network speeds, locations, and unpredictable sensor inputs. The range of values for each context, e.g., location, can be very large. Liang et al. <ref type="bibr" target="#b109">[110]</ref> presented Caiipa, a cloud service for testing apps over an expanded mobile context space in a scalable way and implemented on a cluster of VMs and real devices that can emulate various combinations of contexts for mobile apps. Mobile vulnerability discovery pipeline (MVDP) <ref type="bibr" target="#b110">[111]</ref> is also a distributed black-box fuzzing system for Android and iOS devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. TOOLS IN DIFFERENT APPLICATION AREAS</head><p>Fuzzing is a practical software testing technique which has been widely applied in industry. Any software accepting user inputs can be regarded as a fuzzing target. Currently, there are various fuzzers targeting different software systems. In this section, we answer RQ2 by investigating some of the most popular and efficient fuzzers classified by their application areas, i.e., the type of their target software platform. Tables V and VI summarize the typical fuzzers we are going to introduce, from application areas and problem domains, respectively.</p><p>A. General Purpose Fuzzers 1) Peach: Peach <ref type="bibr" target="#b111">[112]</ref> is a well-known general purpose fuzzer of which the most common targets are drivers, file consumers, network protocols, embedded devices, systems, etc. It is constructed with the following components: 1) predefined input format definitions called Peach Pits, which are available as individual Pits or groups of related Pits called Pit Packs; 2) test passes, which can weight mutators to perform more test cases; and 3) minset, which helps pare down the file count for test case coverage. Peach plays a critical role in this area because it has many outstanding features, such as threat detection, outof-the-box fuzzing definitions (Peach Pits), and scalable testing options. However, there are also some problems in Peach (specifically in open-source version). A major one is that it is time consuming to build Pit file using syntax provided by Peach to describe the target file format. Built on Peach, eFuzz <ref type="bibr" target="#b112">[113]</ref> tested smart metering devices based on the communication protocol DLMS/COSEM, the standard protocol used in Europe, for possible faults. Honggfuzz <ref type="bibr" target="#b113">[114]</ref> is also built on Peach.</p><p>2) beSTORM: beSTORM <ref type="bibr" target="#b114">[115]</ref> is a commercial black-box fuzzer. It can be used to test the security of target application : The fuzzer provides some high-quality seeds for testers to choose (usually for mutation-based fuzzers). ×: The seeds are collected by testers manually. /: The fuzzer does not require seeds in random (usually for grammar-based fuzzers).</p><p>2) Input validation and coverage Ý: The fuzzer utilizes input grammars or other knowledge to generate test cases, or adopts some ways to pass through input validation.</p><p>: The fuzzer uses some methods to mitigate the problem caused by input validation. ×: The fuzzer does not use any input information or approach to pass through input validation.</p><p>3) Handling crash-inducing test cases Ý: The fuzzer can analyze the found bugs automatically and generate a detailed bug report.</p><p>: The fuzzer can provide some useful information, like log file, to help subsequent bug analysis. ×: The only generates crash-inducing test cases. 4) Leveraging runtime information Ý: The fuzzer uses runtime information to guide test case generation. ×: The fuzzer does not use any feedback information during runtime. 5) Scalability in fuzzing Ý: The fuzzer can test real-world applications effectively and has found plenty of bugs.</p><p>: The fuzzer is in its experiment period and applied to some real-world programs. ×: The fuzzer can only test some experimental programs.</p><p>or to check the quality of networked hardware and software products. It does not need source code but only binaries of the target program. The fuzzing strategy beSTORM takes is to first test the likely, common failure-inducing area and then expand to a near-infinite range of attack variations; therefore, it can quickly deliver a result. beSTORM can be used in the test of protocols, applications, hardware, files, WIFI, and embedded device security assurance (EDSA). For example, it is able to find bugs in the application which implements the EDSA 402 Standards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Fuzzers for Compilers and Interpreters</head><p>1) jsfunfuzz: jsfunfuzz <ref type="bibr" target="#b115">[116]</ref> is a grammar-based black-box fuzzer designed for Mozilla's SpiderMonkey JavaScript engine. It is the first publicly available JavaScript fuzzer. Since developed in 2007, it has found over 2000 bugs in SpiderMonkey. It combines differential testing with detailed knowledge of the target application; therefore, it can efficiently find both correctness-related bugs and crash-triggering bugs in different JavaScript engines. However, for each new language feature, jsfunfuzz has to adjust itself to respond to the new feature in the fuzzing process.</p><p>2) Csmith: Csmith was proposed by Yang et al. <ref type="bibr" target="#b116">[117]</ref> in 2011. It is a C compiler fuzzer which can generate random C programs with specified grammar according to the C99 standard. It utilizes random differential testing <ref type="bibr" target="#b117">[118]</ref> to help find correctness bugs which are caused by potentially undefined behavior and other C-specific problems. Csmith has been used for years and has found hundreds of previously unknown bugs in both commercial and open source C compilers (e.g., GNU Compiler Collection (GCC), low level virtual machine (LLVM)). Since it is an open-source project, the latest information and version about Csmith can be accessed at <ref type="bibr" target="#b118">[119]</ref>. Although Csmith is a practical fuzzer which is good at generating error-inducing test cases, as many other fuzzers do, it does not prioritize the bugs found according to the importance. Therefore, testers must spend a lot of time in deciding the novelty and the severity of each bug.</p><p>3) LangFuzz: Inspired by jsfunfuzz, Holler et al. <ref type="bibr" target="#b119">[120]</ref> presented LangFuzz in 2012. LangFuzz does not aim at a particular language. So far, it has been tested on JavaScript and hypertext preprocessor (PHP). After applied to JavaScript engine, Lang-Fuzz has found more than 500 previously unknown bugs in SpiderMonkey <ref type="bibr" target="#b25">[26]</ref>. Applied to PHP interpreter, it also discovered 18 new defects that can result in crash. LangFuzz makes use of both stochastic generation and code mutation to create test cases, but regards mutation as the primary technique. It is designed as a language-independent fuzzer, but adapting it to a new language needs some necessary changes.</p><p>4) CLsmith: Lidbury et al. <ref type="bibr" target="#b69">[70]</ref> leveraged random differential testing and equivalence modulo inputs (EMI) testing to fuzzing many-core compiler and identified and reported more than 50 OpenCL compiler bugs, which is the most in commercial implementations. Specifically, they employed random differential testing to the many-core setting for generating deterministic, communicating, feature-rich OpenCL kernels, and proposed and evaluated injection of dead-by-construction code to enable EMI testing in the context of OpenCL.</p><p>Other fuzzers in this category include MongoDB's JavaScript Fuzzer which detected almost 200 bugs over the course of two release cycles <ref type="bibr" target="#b120">[121]</ref>; Ifuzzer is another JavaScript interpreter fuzzer using genetic programming <ref type="bibr" target="#b121">[122]</ref>.</p><p>C. Fuzzers for Application Software 1) SAGE: SAGE <ref type="bibr" target="#b13">[14]</ref> is a well-known white-box fuzzer developed by Microsoft. It is used to fuzz large file-reading Windows applications (e.g., document parsers, media players, image processors, etc.) running on x86 platform. Combining concolic execution with a heuristic search algorithm to maximize code coverage, SAGE tries its best to reveal bugs effectively. Since 2008, this tool has been running incessantly on an average of 100-plus machines/cores and fuzzing automatically a few hundred applications of Microsoft. SAGE is the first fuzzer realizing the white-box fuzzing technique and able to test real-world applications. Nowadays, Microsoft is promoting an online fuzzing project called Springfield <ref type="bibr" target="#b122">[123]</ref>. It provides multiple methods including Microsoft white-box fuzzing technology to find bugs in the binary programs uploaded by customers. Future work of SAGE consists of improving its search method, enhancing the precision of its symbolic execution and increasing the capability of its constraint solving for discovering more bugs <ref type="bibr" target="#b37">[38]</ref>.</p><p>2) AFL: AFL <ref type="bibr" target="#b26">[27]</ref> is a well-known code-coverage guide fuzzer. It gathers the information of runtime path coverage by code instrumentation. For open-source applications, the instrumentation is introduced at compile time and for binaries the instrumentation is introduced at runtime via a modified QEMU <ref type="bibr" target="#b123">[124]</ref>. The test cases which can explore new execution paths have more chance to be chosen in the next round of mutation. The experimental result shows that AFL is efficient at finding bugs in real-world use cases, such as file compression libraries, common image parsing, and so on. AFL supports C, C++, Objective C, or executable programs and works on Linux-like OS. Besides, there is also some work to extend the application scenarios of AFL, such as TriforceAFL <ref type="bibr" target="#b124">[125]</ref>, which is used to fuzz kernel syscalls, WinAFL <ref type="bibr" target="#b125">[126]</ref>, which ports AFL to Windows, and the work from ORACLE <ref type="bibr" target="#b126">[127]</ref>, which uses AFL to fuzz some filesystems. Although AFL is efficient and easy to use, there is still room to improve. Like many other brute-force fuzzers, AFL provides limited code coverage when the actual input data are compressed, encrypted, or bundled with checksum. Besides, AFL takes more time when dealing with 64-bit binaries and does not support fuzzing network services directly.</p><p>3) QuickFuzz: QuickFuzz <ref type="bibr" target="#b127">[128]</ref> leverages Haskell's QuickCheck (the well-known property-based random testing library) and Hackage (the community Haskell software repository) in conjunction with off-the-shelf bit-level mutational fuzzers to provide automatic fuzzing for more than a dozen common file formats, without providing external set of input files nor developing models for the file types involved. Quick-Fuzz generates invalid inputs using a mix of grammar-based and mutation-based fuzzing techniques to discover unexpected behavior in a target application.</p><p>To test the server side software, Davis et al. <ref type="bibr" target="#b128">[129]</ref> presented Node.fz, which is a scheduling fuzzer for event-driven programs, embodied for server-side Node.js programs. Node.fz randomly perturbs the execution of a Node.js program, allowing Node.js developers to explore a variety of possible schedules. Work in this category also includes Dfuzzer <ref type="bibr" target="#b129">[130]</ref>, which is a fuzzer for D-bus service.</p><p>To test mobile applications, some fuzzers have been presented in recent years, such as Droid-FF <ref type="bibr" target="#b130">[131]</ref>, memory-leak fuzzer <ref type="bibr" target="#b131">[132]</ref>, DroidFuzzer <ref type="bibr" target="#b132">[133]</ref>, intent fuzzer <ref type="bibr" target="#b133">[134]</ref>, and Android Ripper MFT tool <ref type="bibr" target="#b134">[135]</ref> for Android apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Fuzzers for Network Protocols</head><p>1) Sulley: Sulley <ref type="bibr" target="#b135">[136]</ref> is an open-source fuzzing framework targeting network protocols. It utilizes a block-based approach to generate individual "requests." It provides lots of needed data formats for users to build protocol descriptions. Before testing, users should use these formats to define all necessary blocks which will be mutated and merged in the fuzzing process to create new test cases. Sulley can classify the detected faults, work in parallel, and trace down to a unique sequence of a test case triggering a fault. However, it is currently not well maintained. Boofuzz <ref type="bibr" target="#b136">[137]</ref> is a successor to Sulley.</p><p>2) TLS-Attacker: Somorovsky <ref type="bibr" target="#b137">[138]</ref> presented TLS-Attacker, an open-source framework for evaluating the security of TLS libraries. TLS-Attacker allows security engineers to create customized TLS message flows and arbitrarily modify message contents by using a simple interface to test the behavior of their libraries. It successfully found several vulnerabilities in widely used TLS libraries, including OpenSSL, Botan, and MatrixSSL.</p><p>There are some other works about fuzzing network protocols <ref type="bibr" target="#b138">[139]</ref>, <ref type="bibr" target="#b139">[140]</ref>. T-Fuzz <ref type="bibr" target="#b140">[141]</ref> is a model-based fuzzer for robustness testing of telecommunication protocols, Secfuzz <ref type="bibr" target="#b141">[142]</ref> for IKE protocol, and both SNOOZE <ref type="bibr" target="#b142">[143]</ref> and KiF <ref type="bibr" target="#b143">[144]</ref>, <ref type="bibr" target="#b144">[145]</ref> for the VOIP/SIP protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Fuzzers for OS Kernels</head><p>Kernel components in OS are difficult to fuzz as feedback mechanisms (i.e., guided code coverage) cannot be easily applied. Additionally, nondeterminism is due to interrupts, kernel threads, and statefulness poses problems <ref type="bibr" target="#b145">[146]</ref>. Furthermore, if a process fuzzes its own kernel, a kernel crash highly impacts the performance of the fuzzer because of the reboot of the OS.</p><p>1) Trinity: In recent years, Trinity <ref type="bibr" target="#b146">[147]</ref> has gained a lot of attention in the area of kernel fuzzing. It implements several methods to send syscalls semi-intelligent arguments. The methods used to generate arguments of system call are described as follows: 1) If a system call expects a certain data type as an argument (e.g., descriptor), it gets passed one; 2) if a system call only accepts certain values as an argument (e.g., a 'flags' field), it has a list of all the valid flags that may be passed; and 3) if a system call only takes a range of values, a random value passed to an argument usually fits that range. Trinity supports a variety of architectures including x86-64, SPARC-64, S390x, S390, PowerPC-64, PowerPC-32, MIPS, IA-64, i386, ARM, Aarch64, and Alpha.</p><p>2) Syzkaller: Syzkaller <ref type="bibr" target="#b14">[15]</ref> is another fuzzer targeting Linux kernels. It depends on predefined templates which specify the argument domains of each system call. Unlike Trinity, it also makes use of code coverage information to guide the fuzzing process. Because Syzkaller combines the coverage-guided and template-based techniques, it does work better than provided only with the pattern of argument usages for system calls. This tool is under active development but the early results look impressive.</p><p>3) IOCTL Fuzzer: IOCTL Fuzzer <ref type="bibr" target="#b147">[148]</ref> is a tool designed to automatically search for vulnerabilities in Windows kernel drivers. Currently, it supports Windows 7 (x32 and x64), 2008 Server, 2003 Server, Vista, and XP. If an IOCTL operation is conformed to conditions specified in the configuration file, the fuzzer replaces its input field with randomly generated data.</p><p>4) Kernel-AFL (kAFL): Schumilo et al. <ref type="bibr" target="#b148">[149]</ref> proposed coverage-guided kernel fuzzing in an OS-independent and hardware-assisted way. They utilize a hypervisor to produce coverage and Intel's Processor Trace technology to provide control flow information on running code. They developed a framework called kAFL to assess the reliability or security of Linux, MacOS, and Windows kernel components. Among many crashes, they uncovered several flaws in the ext4 driver for Linux, the HFS and APFS file system of MacOS, and the NTFS driver of Windows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5) CAB-FUZZ:</head><p>To discover the vulnerabilities of commercial off-the-shelf (COTS) operating systems (OSes), Kim et al. <ref type="bibr" target="#b149">[150]</ref> proposed CAB-FUZZ, a practical concolic testing tool to explore relevant paths that are most likely triggering bugs. This fuzzer prioritized the boundary states of arrays and loops and exploited real programs interacting with COTS OSes to construct proper contexts to explore deep and complex kernel states without debug information. It found 21 undisclosed unique crashes in Windows 7 and Windows Server 2008, including three critical vulnerabilities. Five of those found vulnerabilities have been existing for 14 years and could be triggered even in the initial version of Windows XP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Fuzzers for Embedded Devices, Drivers and Components</head><p>1) YMIR: Kim et al. <ref type="bibr" target="#b28">[29]</ref> proposed the automatic generation of fuzzing grammars using API-level concolic testing, and implemented a tool (named YMIR) to automate white-box fuzz testing on ActiveX controls. It takes an ActiveX control as input and delivers fuzzing grammars as its output. API-level concolic testing collects constraints at the library function level rather than the instruction level, and thus may be faster and less accurate.</p><p>2) vUSBf: vUSBf <ref type="bibr" target="#b150">[151]</ref> was first proposed at Black Hat Europe 2014. It is a fuzzing framework for USB drivers. This framework implements a virtual USB fuzzer based on Kernel Virtual Machine (in Linux) and the USB redirection protocol in QEMU. It allows the dynamic definition of several million test cases using a simple XML configuration. Each test is marked using a unique identification and thus is reproducible. It can trigger the following bugs in Linux kernels and device drivers: nullpointer dereferences, kernel paging requests, kernel panic, bad page state, and segmentation fault. There are some other works in this area, such as a cost-effective USB testing framework <ref type="bibr" target="#b151">[152]</ref>, VDF-a targeted evolutionary fuzzer of virtual devices <ref type="bibr" target="#b152">[153]</ref>.</p><p>Besides the aforementioned fuzzers, there are also many other practical tools, including perf_fuzzer [154] for perf_event_open() system call, libFuzzer <ref type="bibr" target="#b153">[155]</ref> for library, Modbus/TCP Fuzzer for internetworked industrial systems <ref type="bibr" target="#b154">[156]</ref>, a fuzzer for I/O buses <ref type="bibr" target="#b155">[157]</ref>, a fuzzer for digital certificates <ref type="bibr" target="#b156">[158]</ref>, Gaslight <ref type="bibr" target="#b157">[159]</ref> for memory forensics frameworks, etc. Moreover, along with memory error detectors (e.g., Clang's Ad-dressSanitizer <ref type="bibr" target="#b82">[83]</ref>, MemorySanitizer <ref type="bibr" target="#b158">[160]</ref>, etc.), fuzzers can be reinforced to expose more hidden bugs rather than shallow bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. FUTURE DIRECTIONS</head><p>In this section, we answer RQ3 by discussing some of the possible future directions of the fuzzing technique. Although we cannot accurately predict the future directions that the study of fuzzing will follow, it is possible for us to identify and summarize some trends based on the reviewed papers, which may suggest and guide directions of future research. We will discuss the future work in the following directions, with the hope that the discussion could inspire follow-up researches and practices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Input Validation and Coverage</head><p>Overly complex, sloppily specified, or incorrectly implemented input languages, which describe the set of valid inputs an application has to handle, are the root causes of many security vulnerabilities <ref type="bibr" target="#b159">[161]</ref>. Some systems are strict on input formats (e.g., network protocols, compilers and interpreters, etc.); inputs that do not satisfy the format requirement will be rejected in the early stage of execution. In order to fuzz this kind of target program, the fuzzer should generate test cases which can pass the input validation. Many researches targeted this problem and made an impressive progress, such as <ref type="bibr" target="#b160">[162]</ref> for string bugs, <ref type="bibr" target="#b161">[163]</ref>, <ref type="bibr" target="#b162">[164]</ref> for integer bugs, <ref type="bibr" target="#b163">[165]</ref> for e-mail filters, and <ref type="bibr" target="#b164">[166]</ref> for buffer bugs. Open issues in this area include dealing with FP operations (e.g., Csmith, well-known C compiler fuzzer, does not generate FP programs), applying existing techniques to other languages (e.g., applying CLP on C language), etc. Furthermore, Rawat et al. <ref type="bibr" target="#b107">[108]</ref> demonstrated that inferring input properties by analyzing application behavior is a viable and scalable strategy to improve fuzzing performance, as well as a promising direction for future research in the area. As we mentioned in Section V-A, although TaintScope can locate the checksum points accurately and increase the effectiveness of fuzzing dramatically, there is still room for improvement. First, it cannot deal with digital signature and other secure check schemes. Second, its effectiveness will be highly influenced by encrypted input data. Third, it ignores control flow dependences and does not instrument all kinds of ×86 instructions. These are still open problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Smart Fuzzing</head><p>Many other program analysis techniques are merged into smart fuzzing <ref type="bibr" target="#b165">[167]</ref>, <ref type="bibr" target="#b166">[168]</ref>, such as concolic execution, dynamic taint analysis, and so on. Although these techniques bring many benefits, they also cause some problems: such as path explosion, imprecise symbolic execution in concolic test and undertainting, overtainting in dynamic taint analysis. As an example, Dolan-Gavitt et al. <ref type="bibr" target="#b167">[169]</ref> have injected thousands of bugs into eight real-world programs, including bash, tshark, and the GNU Coreutils. They evaluated and found that a prominent fuzzer and a symbolic execution-based bug finder were able to locate some but not all injected bugs. Furthermore, fuzzing in a scalable and efficient way is still challenging. Bounimova et al. <ref type="bibr" target="#b106">[107]</ref> presented key challenges with running white-box fuzzing on a large scale, which involve those challenges in symbolic execution, constraint generation and solving, long-running state-space searches, diversity, fault tolerance, and always-on usage. These problems all deserve to be studied in more depth.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Filtering Fuzzing Outputs</head><p>During a software development life cycle, time and budget for fixing bugs are usually constrained. Therefore, the main concern of the developer is to solve those severe bugs under these constraints. For example, Podgurski et al. <ref type="bibr" target="#b79">[80]</ref> proposed automated support for classifying reported software failures to facilitate prioritizing them and diagnosing their causes. Zhang et al. <ref type="bibr" target="#b168">[170]</ref> proposed to select test cases based on test case similarity metric to explore deep program semantics. Differential testing may be helpful to determine the cost of evaluating test results <ref type="bibr" target="#b169">[171]</ref>, <ref type="bibr" target="#b170">[172]</ref>. In short, at present, there has been little research on filtering more important failure-inducing test cases from the large fuzzing outputs. This research direction is of practical importance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Seed/Input Generation and Selection</head><p>The result of fuzzing is correlated with the quality of seed/input files. Therefore, how to select suitable seed files in order to find more bugs is an important issue. By attempting to maximize the testing coverage of the input domain, the methods or algorithms of dealing with test cases in ART <ref type="bibr" target="#b57">[58]</ref>, <ref type="bibr" target="#b171">[173]</ref>, <ref type="bibr" target="#b172">[174]</ref>- <ref type="bibr" target="#b174">[176]</ref> may be useful. For example, Pacheco et al. <ref type="bibr" target="#b52">[53]</ref> presented a feedback-directed random test generation technique, where a predesigned input was executed and checked against a set of contracts and filters. The result of the execution determines whether the input is redundant, illegal, contract violating, or useful for generating more inputs. However, in the massive experiments, Arcuri and Briand <ref type="bibr" target="#b58">[59]</ref> showed that ART was highly inefficient even on trivial problems when accounting for distance calculations among test cases. Classfuzz <ref type="bibr" target="#b175">[177]</ref> mutated seeding class-files using a set of predefined mutation operators, employed Markov Chain Monte Carlo sampling to guide mutator selection, and used coverage uniqueness as a discipline for accepting representative ones. Shastry et al. <ref type="bibr" target="#b176">[178]</ref> proposed to automatically construct an input dictionary by statically analyzing program control and data flow, and the input dictionary is supplied to an off-the-shelf fuzzer to influence input generation. To design and implement more effective, sound, and accurate seed generation and selection algorithms is an open research problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Combining Different Testing Methods</head><p>As discussed in Section IV, black-box and white-box/graybox fuzzing methods have their own advantages and disadvantages. Therefore, how to combine these techniques to build a fuzzer which is both effective and efficient is an interesting research direction. There are a few attempts <ref type="bibr" target="#b123">[124]</ref>, <ref type="bibr" target="#b177">[179]</ref>, <ref type="bibr" target="#b47">[48]</ref> in this area, for example, SYMFUZZ <ref type="bibr" target="#b50">[51]</ref> augmented blackbox mutation-based fuzzing with a white-box technique, which helps to calculate an optimal mutation ratio based on the given program-seed pairs. From microperspective, SYMFUZZ has two main steps to generate test cases, and each step uses a different fuzzing techniques which are white-box fuzzing and blackbox fuzzing. However, from a macroperspective, this method can also be regarded as gray-box fuzzing. Because the mutation ratio of its black-box fuzzing process is computed during its white-box fuzzing process, so the whole fuzzing utilizes partial knowledge of the target program and can be regarded as gray-box fuzzing. It is also an interesting direction to combine fuzzing with other testing techniques. Chen et al. <ref type="bibr" target="#b178">[180]</ref> reported how metamorphic testing <ref type="bibr" target="#b179">[181]</ref>- <ref type="bibr" target="#b181">[183]</ref>, which is a relatively new testing method which looks at the relationships among the inputs and outputs of multiple program executions, detected previously unknown bugs in real-world critical applications, showing that using diverse perspectives and combining multiple methods can help software testing achieve higher reliability or security. Garn and Simos <ref type="bibr" target="#b182">[184]</ref> showed the applicability of a comprehensive method utilizing combinatorial testing and fuzzing to system call interfaces of Linux kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Combining Other Techniques With Fuzzing</head><p>Fuzzers are limited by the extent of test coverage and the availability of suitable test cases. Since static analysis can perform a broader search for vulnerable code patterns, starting from a handful of fuzzer-discovered program failures, Shastry et al. <ref type="bibr" target="#b183">[185]</ref> implemented a simple yet effective matchranking algorithm which used test coverage data to focus attention on matches which comprised untested code and demonstrated that static analysis could effectively complement fuzzing. Static analysis techniques, such as symbolic execution and control/data flow analysis, can provide useful structural information for fuzzing <ref type="bibr" target="#b184">[186]</ref>; however, there are some limitations of symbolic execution for fuzzing thus leaving some open problems: IEEE TRANSACTIONS ON RELIABILITY 1) Only generic properties are checked-many deviations from a specified behavior are not found; and 2) many programs are not entirely amenable to symbolic execution because they give rise to hard constraints so that some parts of a program remain uncovered <ref type="bibr" target="#b185">[187]</ref>. Havrikov <ref type="bibr" target="#b186">[188]</ref> proposed a combination approach by which fuzzing can benefit from different lightweight analyses. The analyses leveraged multiple information sources apart from the target program, such as input and execution (e.g., descriptions of the targeted input format in the form of extended context-free grammars) or hardware counters.</p><p>Machine learning techniques are helpful for automatically generating input grammars for grammar-based fuzzing <ref type="bibr" target="#b187">[189]</ref>. Optimization theory can also be used to build effective search strategies in fuzzing <ref type="bibr" target="#b82">[83]</ref>, <ref type="bibr" target="#b188">[190]</ref>, <ref type="bibr" target="#b189">[191]</ref>. Genetic programming or algorithm is used in <ref type="bibr" target="#b121">[122]</ref>, <ref type="bibr" target="#b190">[192]</ref>, and <ref type="bibr" target="#b191">[193]</ref> to guide their fuzzers. Dai et al. <ref type="bibr" target="#b192">[194]</ref> proposed a novel UI fuzzing technique aiming at running apps such that different execution paths can be exercised, and this method required the tester to build a comprehensive network profile. We believe that there is still some room for improving the existing combination methods and leveraging other techniques with fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>Fuzzing is an automatic and effective software testing technique which is able to discover both correctness and security bugs. It can be classified into black-box, white-box, and graybox categories according to how much information it acquires from the target program. During the fuzzing process, the basic way to find bugs is to generate numerous test cases which are hopeful to trigger bug-inducing code fragments in the target program. However, there is no fixed pattern in fuzzing to generate test cases, and thus it mostly depends on the developers' creativity. We presented a survey on fuzzing covering 171 papers published between January 1990 and June 2017. The results of the survey show that fuzzing is a thriving topic with an increasing trend of contributions on the subject. Currently, merged techniques with fuzzing include genetic algorithm, taint analysis, symbolic execution, coverage-guided methods, etc. Existing fuzzing tools have been widely applied in many kinds of industry products including compilers, network protocol, applications, kernels, etc., ranging from binaries to source codes and found tens of thousands of software bugs, many of which are exploitable. Last but not least, we discuss some open problems with regard to fuzzing. We encourage further research and practices to address these problems toward a wide adaption of fuzzing in continuous integration of a software system.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Fuzzing papers published between January 1, 1990 and June 30, 2017. (a) Number of publications per year. (b) Cumulative number of publications per year.</figDesc><graphic coords="3,48.95,67.77,492.48,144.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. General process of fuzzing.</figDesc><graphic coords="4,47.65,68.50,240.00,194.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Example function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Code snippet that shows implicit data flow.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I PUBLISHERS</head><label>I</label><figDesc>AND NUMBER OF PRIMARY STUDIES</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II TOP</head><label>II</label><figDesc>VENUES ON FUZZING technical reports (3%). Table II lists the venues where at least three fuzzing papers have been presented.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE III GEOGRAPHICAL</head><label>III</label><figDesc>DISTRIBUTION OF PUBLICATIONS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>TABLE IV TOP</head><label>IV</label><figDesc></figDesc><table><row><cell>10 COAUTHORS ON FUZZING</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>TABLE V SUMMARIES</head><label>V</label><figDesc>OF THE TYPICAL FUZZERS</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE VI TYPICAL</head><label>VI</label><figDesc>FUZZERS AND THEIR PROBLEM DOMAINSThe meaning of the symbols in table is as follows: 1) Seeds generation and selection Ý: The fuzzer can automatically generate seeds or adopt some seed selection algorithm.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>https://fuzzinginfo.files.wordpress.com/2012/05/cmiller-csw-2010.pdf.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors thank the anonymous reviewers for their valuable comments that have helped improve this paper.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This work was supported by the National Natural Science Foundation of China (NSFC) under Grant U1713212 and Grant 91418206 and the Key Research Program of Frontier Sciences, Chinese Academy of Sciences, under Grant QYZDJ-SSW-JSC036.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Violating assumptions with fuzzing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Oehlert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security Privacy</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="58" to="62" />
			<date type="published" when="2005-03">Mar. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An empirical study of the reliability of UNIX utilities</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fredriksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>So</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="32" to="44" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fuzz revisited: A re-examination of the reliability of UNIX utilities and services</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. Comput. Sci., Univ. Wisconsin-Madison</title>
		<imprint>
			<date type="published" when="1268">1268. 1995</date>
			<pubPlace>Madison, WI, USA, Tech</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An empirical study of the robustness of windows NT applications using random testing</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">E</forename><surname>Forrester</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th Conf. USENIX Windows Syst. Symp</title>
		<meeting>4th Conf. USENIX Windows Syst. Symp<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An empirical study of the robustness of MacOS applications using random testing</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cooksey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop Random Test</title>
		<meeting>Int. Workshop Random Test</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="46" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Random testing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hamlet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Encyclopedia of Software Engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="970" to="978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Silver bullet talks with Bart Miller</title>
		<author>
			<persName><forename type="first">G</forename><surname>Mcgraw</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security Privacy</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="6" to="8" />
			<date type="published" when="2014-09">Sep. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Experiences with model inference assisted fuzzing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Viide</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Conf. USENIX Workshop Offensive Technol</title>
		<meeting>Conf. USENIX Workshop Offensive Technol<address><addrLine>Art</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">IKE vulnerability discovery based on fuzzing</title>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Security Commun. Netw</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="889" to="901" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Structurized grammar-based fuzz testing for programs with highly structured inputs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Security Commun. Netw</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1319" to="1330" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Securing native XML database-driven web applications from XQuery injection vulnerabilities</title>
		<author>
			<persName><forename type="first">N</forename><surname>Palsetia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Deepa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">A</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Thilagam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Pais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">122</biblScope>
			<biblScope unit="page" from="93" to="109" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Automated evaluation of syntax error recovery</title>
		<author>
			<persName><forename type="first">M</forename><surname>De Jonge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th</title>
		<meeting>27th</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="322" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Systematic bug finding and fault localization enhanced with input data tracking</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Demott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Enbody</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">F</forename><surname>Punch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Security</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="130" to="157" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SAGE: Whitebox fuzzing for security testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queue</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
		<ptr target="https://github.com/google/syzkaller" />
		<title level="m">Syzkaller-Linux Kernel Fuzzer</title>
		<imprint>
			<date type="published" when="2016-07-12">Jul. 12, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">SunDew: Systematic automated security testing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Babic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th ACM SIGSOFT Int. SPIN Symp. Model Checking Softw</title>
		<meeting>24th ACM SIGSOFT Int. SPIN Symp. Model Checking Softw<address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The evolving art of fuzzing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Demott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DEF CON Conf</title>
		<meeting>DEF CON Conf</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Fuzzing: The state of the art</title>
		<author>
			<persName><forename type="first">R</forename><surname>Mcnally</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Gerhardy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<publisher>DTIC Document</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Network protocol fuzz testing for information systems and applications: A survey and taxonomy</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Munea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multimed. Tools Appl</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="issue">22</biblScope>
			<biblScope unit="page" from="14745" to="14757" />
			<date type="published" when="2016-11">Nov. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Procedures for Performing Systematic Reviews</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kitchenham</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004">2004</date>
			<pubPlace>Keele Univ., NICTA, Keele, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Analyzing the past to prepare for the future: Writing a literature review</title>
		<author>
			<persName><forename type="first">J</forename><surname>Webster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">T</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MIS Quart</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scheduling blackbox mutational fuzzing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gottlieb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2013 ACM SIGSAC Conf. Comput. Commun. Security</title>
		<meeting>2013 ACM SIGSAC Conf. Comput. Commun. Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="511" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A taint based approach for smart fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bekrar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bekrar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Groz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 5th Int. Conf. Softw. Test. Verification Validation</title>
		<meeting>IEEE 5th Int. Conf. Softw. Test. Verification Validation</meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012</date>
			<biblScope unit="page" from="818" to="825" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Fuzzing the ActionScript virtual machine</title>
		<author>
			<persName><forename type="first">G</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th ACM SIGSAC Symp</title>
		<meeting>8th ACM SIGSAC Symp<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="457" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fuzzing and delta-debugging SMT solvers</title>
		<author>
			<persName><forename type="first">R</forename><surname>Brummayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int. Workshop Satisfiability Modulo Theories</title>
		<meeting>7th Int. Workshop Satisfiability Modulo Theories</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Taming compiler fuzzers</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 34th ACM SIGPLAN Conf. Program. Lang. Design Implementation</title>
		<meeting>34th ACM SIGPLAN Conf. Program. Lang. Design Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="197" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">AFL</title>
		<author>
			<persName><forename type="first">American</forename><surname>Fuzzy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lop</forename></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl/" />
		<imprint>
			<date type="published" when="2016-07-12">Jul. 12, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Genetic algorithm in code coverage guided fuzz testing</title>
		<author>
			<persName><forename type="first">E</forename><surname>Jääskelä</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dept. Comput. Sci. Eng., Univ. Oulu</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic and lightweight grammar generation for fuzz testing</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D.-H</forename><surname>Bae</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Security</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Protocol state fuzzing of TLS implementations</title>
		<author>
			<persName><forename type="first">J</forename><surname>De Ruiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th USENIX Security Symp</title>
		<meeting>24th USENIX Security Symp</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="193" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An empirical study of the reliability of UNIX utilities</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Fredriksen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>So</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="32" to="44" />
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Trinity: A linux system call fuzz tester</title>
		<author>
			<persName><forename type="first">D</forename><surname>Jones</surname></persName>
		</author>
		<ptr target="http://codemonkey.org.uk/projects/trinity/" />
		<imprint>
			<date type="published" when="2016-07-12">Jul. 12, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">XSS PEEKER: Dissecting the XSS exploitation techniques and fuzzing mechanisms of blackbox web application scanners</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bazzoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Criscione</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Maggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Zanero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st IFIP Int. Conf. Inf. Security Privacy</title>
		<meeting>31st IFIP Int. Conf. Inf. Security Privacy<address><addrLine>Ghent, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06-01">May 30-Jun. 1, 2016</date>
			<biblScope unit="volume">471</biblScope>
			<biblScope unit="page" from="243" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">LigRE: Reverseengineering of control and data flow models for black-box XSS detection</title>
		<author>
			<persName><forename type="first">F</forename><surname>Duchène</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Richier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Groz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Working Conf. Reverse Eng</title>
		<meeting>20th Working Conf. Reverse Eng</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="252" to="261" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Flayer: Exposing application internals</title>
		<author>
			<persName><forename type="first">W</forename><surname>Drewry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st USENIX Workshop Offensive Technol</title>
		<meeting>1st USENIX Workshop Offensive Technol<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06">Aug. 6, 2007</date>
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">TaintScope: A checksum-aware directed fuzzing tool for automatic software vulnerability detection</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Security Privacy</title>
		<meeting>IEEE Symp. Security Privacy</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="497" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Taint-based directed whitebox fuzzing</title>
		<author>
			<persName><forename type="first">V</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 31st Int. Conf. Softw. Eng</title>
		<meeting>IEEE 31st Int. Conf. Softw. Eng</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="474" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Automated whitebox fuzz testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Netw. Distrib. Syst. Security Symp</title>
		<meeting>Netw. Distrib. Syst. Security Symp<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-10-13">Feb. 10-13, 2008</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Symbolic execution for software testing: Three decades later</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="82" to="90" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Pin: Building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Valgrind: A framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 28th ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>28th ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="89" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">A framework for file format fuzzing with genetic algorithms</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L J</forename><surname>Seagle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
			<pubPlace>Knoxville, TN, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Univ. Tennessee</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. dissertation</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Dynamic binary analyzer for scanning vulnerabilities with taint analysis</title>
		<author>
			<persName><forename type="first">Y.-H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-W</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-H</forename><surname>Eom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T.-M</forename><surname>Chung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multimed. Tools Appl</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="2301" to="2320" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">DTA++: Dynamic taint analysis with targeted control-flow propagation</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Netw. Distrib. Syst. Security Symp</title>
		<meeting>Netw. Distrib. Syst. Security Symp<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-09">Feb. 6-9, 2011</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Finding software vulnerabilities by smart fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Bekrar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Bekrar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Groz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th IEEE Int. Conf. Softw. Test. Verification Validation</title>
		<meeting>4th IEEE Int. Conf. Softw. Test. Verification Validation</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="427" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">BUZZ: Testing context-dependent policies in stateful networks</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tobioka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Symp</title>
		<meeting>USENIX Symp</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="275" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Optimizing seed selection for fuzzing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Rebert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd USENIX Security Symp</title>
		<meeting>23rd USENIX Security Symp<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="861" to="875" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Turning programs against each other: High coverage fuzz-testing using binary-code mutation and dynamic slicing</title>
		<author>
			<persName><forename type="first">U</forename><surname>Kargén</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Shahmehri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Joint Meeting Found</title>
		<meeting>10th Joint Meeting Found<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="782" to="792" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Fuzzing the font parser of compound documents</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 4th IEEE Int. Conf. Cyber Security Cloud Comput</title>
		<meeting>4th IEEE Int. Conf. Cyber Security Cloud Comput<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">Jun. 26-28, 2017</date>
			<biblScope unit="page" from="237" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Skyfire: Data-driven seed generation for fuzzing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Security Privacy</title>
		<meeting>IEEE Symp. Security Privacy</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="579" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Program-adaptive mutational fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Security Privacy</title>
		<meeting>IEEE Symp. Security Privacy</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="725" to="741" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Formal analysis of the effectiveness and predictability of random testing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z Z</forename><surname>Iqbal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int. Symp. Softw</title>
		<meeting>19th Int. Symp. Softw<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-12-16">Jul. 12-16, 2010</date>
			<biblScope unit="page" from="219" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Feedback-directed random test generation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Softw. Eng</title>
		<meeting>Int. Conf. Softw. Eng</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="75" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Feedbackcontrolled random test generation</title>
		<author>
			<persName><forename type="first">K</forename><surname>Yatoh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sakamoto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Ishikawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Honiden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Softw</title>
		<meeting>Int. Symp. Softw<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07-12">2015. Jul. 12-17, 2015</date>
			<biblScope unit="page" from="316" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title/>
		<author>
			<persName><surname>Ffmpeg</surname></persName>
		</author>
		<ptr target="http://samples.ffmpeg.org/" />
		<imprint>
			<date type="published" when="2016-12-15">Dec. 15, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Google</forename><surname>Webp</surname></persName>
		</author>
		<author>
			<persName><surname>Developers</surname></persName>
		</author>
		<ptr target="https://developers.google.com/speed/webp/docs/cwebp" />
		<imprint>
			<date type="published" when="2016-12-15">Dec. 15, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Prospex: Protocol specification extraction</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th IEEE Symp</title>
		<meeting>30th IEEE Symp</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="110" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Adaptive random testing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">K</forename><surname>Mak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Annu</title>
		<meeting>Annu</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3321</biblScope>
			<biblScope unit="page" from="320" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Adaptive random testing: An illusion of effectiveness?</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int. Symp. Softw</title>
		<meeting>20th Int. Symp. Softw<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">Jul. 17-21, 2011</date>
			<biblScope unit="page" from="265" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Effective file format fuzzing-thoughts techniques and results</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jurczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Black Hat Eur. Conf</title>
		<meeting>Black Hat Eur. Conf<address><addrLine>London, U.K</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Efficient file fuzz testing using automated analysis of binary file format</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">H</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Archit</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="259" to="268" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Checksum-aware fuzzing combined with dynamic taint analysis and symbolic execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Security</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Mining input grammars from dynamic taints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Höschele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st IEEE/ACM Int. Conf. Autom. Softw. Eng</title>
		<meeting>31st IEEE/ACM Int. Conf. Autom. Softw. Eng</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="720" to="725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Steelix: Program-state based binary fuzzing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chandramohan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-W</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Joint Meeting Found</title>
		<meeting>11th Joint Meeting Found<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="627" to="637" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">A new fuzzing technique using niche genetic algorithm</title>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Mater. Res</title>
		<imprint>
			<biblScope unit="volume">756</biblScope>
			<biblScope unit="page" from="4050" to="4058" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">A new fuzzing method using multi data samples combination</title>
		<author>
			<persName><forename type="first">X</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Atwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="881" to="888" />
			<date type="published" when="2011-05">May 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Fuzzing the rust typechecker using CLP (T)</title>
		<author>
			<persName><forename type="first">K</forename><surname>Dewey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hardekopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th IEEE/ACM Int. Conf. Autom. Softw. Eng</title>
		<meeting>30th IEEE/ACM Int. Conf. Autom. Softw. Eng<address><addrLine>Lincoln, NE, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-09-13">Nov. 9-13, 2015</date>
			<biblScope unit="page" from="482" to="493" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Language fuzzing using constraint logic programming</title>
		<author>
			<persName><forename type="first">K</forename><surname>Dewey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hardekopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th ACM/IEEE Int. Conf. Autom. Softw. Eng</title>
		<meeting>29th ACM/IEEE Int. Conf. Autom. Softw. Eng<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="725" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Towards analyzing the input validation vulnerabilities associated with android system services</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Xiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st Annu</title>
		<meeting>31st Annu<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Many-core compiler fuzzing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Lidbury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Lascu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Donaldson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 36th ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>36th ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="65" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">H-Fuzzing: A new heuristic method for fuzzing data generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Parallel Computing</title>
		<editor>
			<persName><forename type="first">E</forename><surname>Altman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Shi</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="32" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">CONFU: Configuration fuzzing testing framework for software vulnerability detection</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Kaiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Secure Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="41" to="55" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Making malory behave maliciously: Targeted fuzzing of android execution environments</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Triller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Pradel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 39th Int. Conf. Softw. Eng</title>
		<meeting>39th Int. Conf. Softw. Eng<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="300" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Semi-valid input coverage for fuzz testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tsankov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Dashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Basin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Softw</title>
		<meeting>Int. Symp. Softw</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Synthesizing program input grammars</title>
		<author>
			<persName><forename type="first">O</forename><surname>Bastani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 38th ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>38th ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="95" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Dynamically discovering likely memory layout to perform accurate fuzzing</title>
		<author>
			<persName><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1180" to="1194" />
			<date type="published" when="2016-09">Sep. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Swarm testing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Softw</title>
		<meeting>Int. Symp. Softw<address><addrLine>Minneapolis, MN, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">Jul. 15-20, 2012</date>
			<biblScope unit="page" from="78" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Generating focused random tests using directed swarm testing</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Alipour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gopinath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Christi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int. Symp. Softw</title>
		<meeting>25th Int. Symp. Softw<address><addrLine>Saarbrücken, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">Jul. 18-20, 2016</date>
			<biblScope unit="page" from="70" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">High-coverage symbolic patch testing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">D</forename><surname>Marinescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int. Workshop Model Checking Softw</title>
		<meeting>19th Int. Workshop Model Checking Softw<address><addrLine>Oxford, U.K.</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">Jul. 23-24, 2012</date>
			<biblScope unit="volume">7385</biblScope>
			<biblScope unit="page" from="7" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Automated support for classifying software failure reports</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podgurski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 25th Int. Conf. Softw. Eng</title>
		<meeting>25th Int. Conf. Softw. Eng<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="465" to="475" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Tree-based methods for classifying software failures</title>
		<author>
			<persName><forename type="first">P</forename><surname>Francis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Minch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Podgurski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th Int. Symp. Softw. Rel. Eng</title>
		<meeting>15th Int. Symp. Softw. Rel. Eng<address><addrLine>Saint-Malo, Bretagne, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-02-05">Nov. 2-5, 2004</date>
			<biblScope unit="page" from="451" to="462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<ptr target="https://www.nccgroup.trust/uk/our-research/research-insights-" />
	</analytic>
	<monogr>
		<title level="m">Modern Security Vulnerability Discovery</title>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
			<biblScope unit="volume">9</biblScope>
		</imprint>
		<respStmt>
			<orgName>NCC Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">modern-security-vulnerabilitydiscovery</note>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Address-Sanitizer: A fast address sanity checker</title>
		<author>
			<persName><forename type="first">K</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Potapenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Annu. Tech. Conf</title>
		<meeting>USENIX Annu. Tech. Conf<address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">Jun. 13-15, 2012</date>
			<biblScope unit="page" from="309" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Hercules: Reproducing crashes in real-world application binaries</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">T</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">B</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rubinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 37th IEEE Int. Conf. Softw. Eng</title>
		<meeting>37th IEEE Int. Conf. Softw. Eng</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="891" to="901" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">A smart fuzzer for ×86 executables</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Martignoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Paleari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd Int</title>
		<meeting>3rd Int</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Dowsing for overflows: A guided fuzzer to find buffer boundary violations</title>
		<author>
			<persName><forename type="first">I</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Slowinska</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Neugschwandtner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 22th USENIX Security Symp</title>
		<meeting>22th USENIX Security Symp<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">Aug. 14-16, 2013</date>
			<biblScope unit="page" from="49" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">SOK: (State of) The art of war: Offensive techniques in binary analysis</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp</title>
		<meeting>IEEE Symp</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="138" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Compositional dynamic test generation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 34th Annu. ACM SIGPLAN-SIGACT Symp. Principles Program. Lang</title>
		<meeting>34th Annu. ACM SIGPLAN-SIGACT Symp. Principles Program. Lang<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="47" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Higher-order test generation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd ACM SIG-PLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>32nd ACM SIG-PLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="258" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">RWset: Attacking path explosion in constraint-based test generation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Boonstoppel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th Int. Conf. Tools Algorithms Construction Anal. Syst</title>
		<meeting>14th Int. Conf. Tools Algorithms Construction Anal. Syst<address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04-06">Mar. 29-Apr. 6, 2008</date>
			<biblScope unit="volume">4963</biblScope>
			<biblScope unit="page" from="351" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Efficient state merging in symbolic execution</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kinder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bucur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 33rd ACM SIGPLAN Conf. Program</title>
		<meeting>33rd ACM SIGPLAN Conf. Program<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Lang. Des. Implementation</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="193" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 8th USENIX Symp. Operating Syst. Des. Implementation</title>
		<meeting>8th USENIX Symp. Operating Syst. Des. Implementation<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-08-10">Dec. 8-10, 2008</date>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Automatic partial loop summarization in dynamic test generation</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Luchaup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Softw</title>
		<meeting>Int. Symp. Softw<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="23" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Heuristics for scalable dynamic test generation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Burnim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd IEEE/ACM Int. Conf. Autom. Softw</title>
		<meeting>23rd IEEE/ACM Int. Conf. Autom. Softw<address><addrLine>Eng., L&apos;Aquila, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">Sep. 15-19, 2008</date>
			<biblScope unit="page" from="443" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Coverage-based greybox fuzzing as Markov chain</title>
		<author>
			<persName><forename type="first">M</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V.-T</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGSAC Conf. Comput. Commun. Security</title>
		<meeting>ACM SIGSAC Conf. Comput. Commun. Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1032" to="1043" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">DeepFuzz: Triggering vulnerabilities deeply hidden in binaries</title>
		<author>
			<persName><forename type="first">K</forename><surname>Böttinger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Eckert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Conf. Detection Intrusions Malware Vulnerability Assessment</title>
		<meeting>13th Int. Conf. Detection Intrusions Malware Vulnerability Assessment<address><addrLine>San Sebastián, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-07-08">Jul. 7-8, 2016</date>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Using test case reduction and prioritization to improve symbolic execution</title>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Alipour</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Softw</title>
		<meeting>Int. Symp. Softw<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">Jul. 21-26, 2014</date>
			<biblScope unit="page" from="160" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">CUTE: A concolic unit testing engine for C</title>
		<author>
			<persName><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th Eur. Softw. Eng. Conf. 13th ACM SIGSOFT Int. Symp. Found. Softw. Eng</title>
		<meeting>10th Eur. Softw. Eng. Conf. 13th ACM SIGSOFT Int. Symp. Found. Softw. Eng<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">S2E: A platform for invivo multi-path analysis of software systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Chipounov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 16th Int. Conf. Archit. Support Program</title>
		<meeting>16th Int. Conf. Archit. Support Program<address><addrLine>Newport Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-05-11">Mar. 5-11, 2011</date>
			<biblScope unit="page" from="265" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">A smart fuzzing method for detecting heap-based vulnerabilities in executable codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mouzarani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sadeghiyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zolfaghari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Security Commun. Netw</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">18</biblScope>
			<biblScope unit="page" from="5098" to="5115" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Grammar-based whitebox fuzzing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kiezun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Y</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>29th ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="206" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Proving memory safety of floating-point computations by combining static and dynamic program analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kinder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 19th Int. Symp. Softw</title>
		<meeting>19th Int. Symp. Softw<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-12-16">Jul. 12-16, 2010</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Achieving high coverage for floating-point code via unconstrained programming</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 38th ACM SIGPLAN Conf. Program</title>
		<meeting>38th ACM SIGPLAN Conf. Program<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Lang. Des. Implementation</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="306" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Bit-level taint analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Yadegari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 14th IEEE Int. Working Conf. Source Code Anal. Manipulation</title>
		<meeting>14th IEEE Int. Working Conf. Source Code Anal. Manipulation<address><addrLine>Victoria, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">Sep. 28-29, 2014</date>
			<biblScope unit="page" from="255" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st IEEE Symp. Security Privacy</title>
		<meeting>31st IEEE Symp. Security Privacy<address><addrLine>Berleley/Oakland, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010">May 16-19, 2010</date>
			<biblScope unit="page" from="317" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Random testing: Theoretical results and practical implications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Z</forename><surname>Iqbal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="258" to="277" />
			<date type="published" when="2012-03">Mar. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Billions and billions of constraints: Whitebox fuzz testing in production</title>
		<author>
			<persName><forename type="first">E</forename><surname>Bounimova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Molnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 35th Int. Conf. Softw. Eng</title>
		<meeting>35th Int. Conf. Softw. Eng<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013">May 18-26, 2013</date>
			<biblScope unit="page" from="122" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<analytic>
		<title level="a" type="main">VUzzer: Application-aware evolutionary fuzzing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Annu. Netw. Distrib. Syst. Security Symp</title>
		<meeting>24th Annu. Netw. Distrib. Syst. Security Symp<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-03-01">Feb. 26-Mar. 1, 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">Directed incremental symbolic execution</title>
		<author>
			<persName><forename type="first">S</forename><surname>Person</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rungta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Khurshid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>32nd ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-04-08">Jun. 4-8, 2011</date>
			<biblScope unit="page" from="504" to="515" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<analytic>
		<title level="a" type="main">Caiipa: Automated large-scale mobile app testing through contextual fuzzing</title>
		<author>
			<persName><forename type="first">C.-J</forename><forename type="middle">M</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Annu. Int. Conf. Mobile Comput. Netw</title>
		<meeting>20th Annu. Int. Conf. Mobile Comput. Netw</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="519" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">On designing an efficient distributed black-box fuzzing system for mobile devices</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">W</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Ramanujam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">P T</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 10th ACM Symp</title>
		<meeting>10th ACM Symp</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="31" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<monogr>
		<title level="m" type="main">Discover Unknown Vulnerabilities, Peach, Peach Fuzzer</title>
		<author>
			<persName><forename type="first">Peach</forename><surname>Fuzzer</surname></persName>
		</author>
		<ptr target="http://www.peachfuzzer.com/" />
		<imprint>
			<date type="published" when="2016-07-13">Jul. 13, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">eFuzz: A fuzzer for DLMS/COSEM electricity meters</title>
		<author>
			<persName><forename type="first">H</forename><surname>Dantas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Erkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Doerr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hallie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Van Der Bij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2nd Workshop Smart Energy Grid Security</title>
		<meeting>2nd Workshop Smart Energy Grid Security<address><addrLine>Scottsdale, AZ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Honggfuzz</forename><surname>Honggfuzz By Google</surname></persName>
		</author>
		<ptr target="https://google.github.io/honggfuzz/" />
		<imprint>
			<date type="published" when="2016-07-13">Jul. 13, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<monogr>
		<ptr target="http://www.beyondsecurity.com/dynamic_fuzzing_testing_embedded_device_security_assurance_402_ethernet" />
		<title level="m">Dynamic Testing (Fuzzing) on the ISASecure EDSA Certification 402 Ethernet by beSTORM, beSTORM</title>
		<imprint>
			<date type="published" when="2016">Jul. 19. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Github</forename><surname>Mozillasecurity/Funfuzz</surname></persName>
		</author>
		<ptr target="https://github.com/MozillaSecurity/funfuzz" />
		<imprint>
			<date type="published" when="2016-12-16">Dec. 16, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">Finding and understanding bugs in C compilers</title>
		<author>
			<persName><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 32nd ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>32nd ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="283" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Differential testing for software</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Mckeeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digit. Tech. J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="100" to="107" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<monogr>
		<title/>
		<author>
			<persName><surname>Csmith</surname></persName>
		</author>
		<ptr target="https://embed.cs.utah.edu/csmith/.Ac-cessedon" />
		<imprint>
			<date type="published" when="2016-12-16">Dec. 16, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">Fuzzing with code fragments</title>
		<author>
			<persName><forename type="first">C</forename><surname>Holler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Herzig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zeller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21th USENIX Security Symp</title>
		<meeting>21th USENIX Security Symp<address><addrLine>Bellevue, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-08-10">Aug. 8-10, 2012</date>
			<biblScope unit="page" from="445" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b120">
	<analytic>
		<title level="a" type="main">MongoDB&apos;s JavaScript fuzzer</title>
		<author>
			<persName><forename type="first">R</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="43" to="47" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b121">
	<analytic>
		<title level="a" type="main">IFuzzer: An evolutionary interpreter fuzzer using genetic programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Veggalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eur</title>
		<meeting>Eur</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9878</biblScope>
			<biblScope unit="page" from="581" to="601" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b122">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Project</forename><surname>Springfield</surname></persName>
		</author>
		<author>
			<persName><surname>Springfield</surname></persName>
		</author>
		<ptr target="https://www.microsoft.com/en-us/springfield/" />
		<imprint>
			<date type="published" when="2017-04-15">Apr. 15, 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b123">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName><forename type="first">N</forename><surname>Stephens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23nd Annu. Netw. Distrib. Syst. Security Symp</title>
		<meeting>23nd Annu. Netw. Distrib. Syst. Security Symp<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">Feb. 21-24, 2016</date>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b124">
	<analytic>
		<title/>
		<ptr target="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2016/june/project-triforce-run-afl" />
	</analytic>
	<monogr>
		<title level="j">Project Triforce: Run AFL on Everything!</title>
		<imprint>
			<date type="published" when="2016">Jul. 13. 2016</date>
		</imprint>
	</monogr>
	<note>TriforceAFL. [Online]. Available</note>
</biblStruct>

<biblStruct xml:id="b125">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Github</forename><surname>Winafl</surname></persName>
		</author>
		<ptr target="https://github.com/ivanfratric/winafl" />
		<imprint>
			<date type="published" when="2016-12-16">Dec. 16, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b126">
	<monogr>
		<author>
			<persName><forename type="first">Fuzzing</forename><surname>Afl Filesystem</surname></persName>
		</author>
		<ptr target="http://events.linuxfoundation.org/sites/events/files/slides/" />
		<title level="m">AFL%20filesystem%20fuzzing%2C%20 Vault%202016_0.pdf</title>
		<imprint>
			<date type="published" when="2016-07">2016. 2016. Jul. 13. 2016</date>
		</imprint>
	</monogr>
	<note>Oracle Linux and VM Development</note>
</biblStruct>

<biblStruct xml:id="b127">
	<analytic>
		<title level="a" type="main">QuickFuzz: An automatic random fuzzer for common file formats</title>
		<author>
			<persName><forename type="first">G</forename><surname>Grieco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Ceresa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Buiras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Haskell</title>
		<meeting>Int. Symp. Haskell</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="13" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b128">
	<analytic>
		<title level="a" type="main">Node.Fz: Fuzzing the serverside event-driven architecture</title>
		<author>
			<persName><forename type="first">J</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Thekumparampil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th Eur. Conf. Comput. Syst</title>
		<meeting>12th Eur. Conf. Comput. Syst<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="145" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b129">
	<analytic>
		<title level="a" type="main">Dfuzzer: A D-bus service fuzzing tool</title>
		<author>
			<persName><forename type="first">M</forename><surname>Marhefka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Müller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 7th Int. Conf. Softw. Test. Verification Validation Workshops</title>
		<meeting>IEEE 7th Int. Conf. Softw. Test. Verification Validation Workshops</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="383" to="389" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b130">
	<analytic>
		<title level="a" type="main">Droid-FF: The first android fuzzing framework</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joseph</surname></persName>
		</author>
		<ptr target="http://conference.hitb.org/hitbsecconf2016ams/sessions/hitb-lab-droid-ff-the-first-android-fuzzing-framework/" />
	</analytic>
	<monogr>
		<title level="m">Proc. Hack Box Security Conf</title>
		<meeting>Hack Box Security Conf<address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Online</note>
</biblStruct>

<biblStruct xml:id="b131">
	<analytic>
		<title level="a" type="main">Testing of memory leak in android applications</title>
		<author>
			<persName><forename type="first">H</forename><surname>Shahriar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>North</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Mawangi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 15th Int. Symp. High-Assurance Syst. Eng</title>
		<meeting>IEEE 15th Int. Symp. High-Assurance Syst. Eng</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="176" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b132">
	<analytic>
		<title level="a" type="main">DroidFuzzer: Fuzzing the android apps with intent-filter tag</title>
		<author>
			<persName><forename type="first">H</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf</title>
		<meeting>Int. Conf</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b133">
	<analytic>
		<title level="a" type="main">Intent fuzzer: Crafting intents of death</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sasnauskas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Joint Int. Workshop Dyn</title>
		<meeting>Joint Int. Workshop Dyn</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b134">
	<analytic>
		<title level="a" type="main">Exploiting the saturation effect in automatic random testing of android applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Amalfitano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Amatucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Fasolino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tramontana</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kowalczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Memon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Proc. 2nd ACM Int. Conf. Mobile Softw. Eng. Syst</title>
		<imprint>
			<biblScope unit="page" from="33" to="43" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b135">
	<monogr>
		<title/>
		<author>
			<persName><surname>Openrce/Sulley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Github</forename><surname>Sulley</surname></persName>
		</author>
		<ptr target="https://github.com/OpenRCE/sulley" />
		<imprint>
			<date type="published" when="2016-07-12">Jul. 12, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b136">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Github</forename><surname>Boofuzz</surname></persName>
		</author>
		<ptr target="https://github.com/jtpereyda/boofuzz" />
		<imprint>
			<date type="published" when="2016-07-23">Jul. 23, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b137">
	<analytic>
		<title level="a" type="main">Systematic fuzzing and testing of TLS libraries</title>
		<author>
			<persName><forename type="first">J</forename><surname>Somorovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2016 ACM SIGSAC Conf. Comput. Commun. Security</title>
		<meeting>2016 ACM SIGSAC Conf. Comput. Commun. Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1492" to="1504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b138">
	<analytic>
		<title level="a" type="main">The advantages of block-based protocol analysis for security testing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Aitel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Immunity Inc</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="349" to="352" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b139">
	<analytic>
		<title level="a" type="main">Preventing DoS attacks in NGN networks with proactive specification-based fuzzing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Rontti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">M</forename><surname>Juuso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Takanen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Commun. Mag</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="164" to="170" />
			<date type="published" when="2012-09">Sep. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b140">
	<analytic>
		<title level="a" type="main">T-Fuzz: Model-based fuzzing for robustness testing of telecommunication protocols</title>
		<author>
			<persName><forename type="first">W</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Svensson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">E</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Almgren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Gulisano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 7th Int. Conf. Softw. Test. Verification Validation</title>
		<meeting>IEEE 7th Int. Conf. Softw. Test. Verification Validation</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="323" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b141">
	<analytic>
		<title level="a" type="main">SecFuzz: Fuzz-testing security protocols</title>
		<author>
			<persName><forename type="first">P</forename><surname>Tsankov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">T</forename><surname>Dashti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 7th Int</title>
		<meeting>7th Int<address><addrLine>Zurich, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b142">
	<analytic>
		<title level="a" type="main">SNOOZE: Toward a Stateful NetwOrk prOtocol fuzZEr</title>
		<author>
			<persName><forename type="first">G</forename><surname>Banks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Felmetsger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">C</forename><surname>Almeroth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Kemmerer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Inf. Security</title>
		<meeting>Int. Conf. Inf. Security</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">4176</biblScope>
			<biblScope unit="page" from="343" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b143">
	<analytic>
		<title level="a" type="main">KiF: A stateful SIP fuzzer</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Abdelnur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>State</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Festor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st Int</title>
		<meeting>1st Int</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="47" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b144">
	<analytic>
		<title level="a" type="main">Advanced fuzzing in the VoIP space</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Abdelnur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>State</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Festor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Virol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="64" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b145">
	<analytic>
		<title level="a" type="main">Manipulating semantic values in kernel data structures: Attack assessments and implications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Venkataramani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 43rd Annu</title>
		<meeting>43rd Annu</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b146">
	<monogr>
		<title level="m" type="main">Trinity: A Linux System Call Fuzzer</title>
		<author>
			<persName><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
		<ptr target="http://codemonkey.org.uk/projects/trinity/" />
		<imprint>
			<date type="published" when="2016-07-12">2016. Jul. 12, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b147">
	<analytic>
		<title/>
		<author>
			<persName><surname>Github-Cr</surname></persName>
		</author>
		<ptr target="https://github.com/Cr4sh/ioctlfuzzer" />
	</analytic>
	<monogr>
		<title level="j">IOCTL</title>
		<imprint>
			<date type="published" when="2016">Jul. 13. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b148">
	<analytic>
		<title level="a" type="main">kAFL: Hardware-assisted feedback fuzzing for OS kernels</title>
		<author>
			<persName><forename type="first">S</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th USENIX Security Symp</title>
		<meeting>26th USENIX Security Symp<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="167" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b149">
	<analytic>
		<title level="a" type="main">CAB-Fuzz: Practical concolic testing techniques for COTS operating systems</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">Y</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Annu. Tech. Conf</title>
		<meeting>USENIX Annu. Tech. Conf<address><addrLine>Santa Clara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="689" to="701" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b150">
	<monogr>
		<title level="m" type="main">QEMU/KEMU USB-Fuzzing Framework, hucktech, Firmware Security</title>
		<imprint>
			<date type="published" when="2016-08">Feb. 8, 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b151">
	<analytic>
		<title level="a" type="main">Lowering the USB fuzzing barrier by transparent two-way emulation</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Tonder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Engelbrecht</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Workshop Offensive Technol</title>
		<meeting>USENIX Workshop Offensive Technol</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b152">
	<analytic>
		<title level="a" type="main">VDF: Targeted evolutionary fuzz testing of virtual devices</title>
		<author>
			<persName><forename type="first">A</forename><surname>Henderson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int. Symp. Res. Attacks Intrusions Defenses</title>
		<meeting>20th Int. Symp. Res. Attacks Intrusions Defenses<address><addrLine>Atlanta, GA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="3" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b153">
	<analytic>
		<title level="a" type="main">Library for Coverage-Guided Fuzz Testing</title>
	</analytic>
	<monogr>
		<title level="j">LLVM</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b154">
	<analytic>
		<title level="a" type="main">A modbus/TCP fuzzer for testing internetworked industrial systems</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Voyiatzis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Katsigiannis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Koubias</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 20th Conf. Emerg. Technol. Factory Autom</title>
		<meeting>IEEE 20th Conf. Emerg. Technol. Factory Autom</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b155">
	<analytic>
		<title level="a" type="main">A tool to analyze potential I/O attacks against PCs</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">L</forename><surname>Sang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Nicomette</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Deswarte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security Privacy</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="60" to="66" />
			<date type="published" when="2014-03">Mar. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b156">
	<analytic>
		<title level="a" type="main">Development of intelligent digital certificate fuzzer tool</title>
		<author>
			<persName><forename type="first">B</forename><surname>Chandrasekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Ramesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sajeev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Mohanty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Shobha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Cryptogr. Security Privacy</title>
		<meeting>Int. Conf. Cryptogr. Security Privacy<address><addrLine>Wuhan, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="126" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b157">
	<analytic>
		<title level="a" type="main">Gaslight: A comprehensive fuzzing architecture for memory forensics frameworks</title>
		<author>
			<persName><forename type="first">A</forename><surname>Case</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S.-J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ramanujam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">G</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Iii</forename></persName>
		</author>
		<idno>pp. S86-S93</idno>
	</analytic>
	<monogr>
		<title level="j">Digit. Investigation</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b158">
	<analytic>
		<title level="a" type="main">MemorySanitizer: Fast detector of uninitialized memory use in C++</title>
		<author>
			<persName><forename type="first">E</forename><surname>Stepanov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Serebryany</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Annu</title>
		<meeting>13th Annu<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07-11">Feb. 7-11, 2015</date>
			<biblScope unit="page" from="46" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b159">
	<analytic>
		<title level="a" type="main">Protocol state machines and session languages: Specification, implementation, and security flaws</title>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">D</forename><surname>Ruiter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schubert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Security Privacy Workshops</title>
		<meeting>IEEE Security Privacy Workshops</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="125" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b160">
	<analytic>
		<title level="a" type="main">An evolutionary computing approach for hunting buffer overflow vulnerabilities: A case of aiming in dim light</title>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Mounier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eur. Conf. Comput. Netw. Defense</title>
		<meeting>Eur. Conf. Comput. Netw. Defense</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="37" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b161">
	<analytic>
		<title level="a" type="main">As-If infinitely ranged integer model</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Dannenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 21st Int</title>
		<meeting>IEEE 21st Int</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="91" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b162">
	<analytic>
		<title level="a" type="main">IntScope: Automatically detecting integer overflow vulnerability in X86 binary using symbolic execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Netw. Distrib. Syst. Security Symp</title>
		<meeting>Netw. Distrib. Syst. Security Symp</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b163">
	<analytic>
		<title level="a" type="main">Fuzzing E-mail filters with generative grammars and n-gram analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Palka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mccoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop Offensive Technol</title>
		<meeting>Workshop Offensive Technol</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b164">
	<analytic>
		<title level="a" type="main">A smart fuzzing method for detecting heap-based buffer overflow in executable codes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mouzarani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sadeghiyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zolfaghari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 21st Pacific Rim Int. Symp. Dependable Comput</title>
		<meeting>IEEE 21st Pacific Rim Int. Symp. Dependable Comput</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="42" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b165">
	<analytic>
		<title level="a" type="main">CRAXfuzz: Target-aware symbolic fuzz testing</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Yeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 39th Annu</title>
		<meeting>IEEE 39th Annu</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="460" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b166">
	<analytic>
		<title level="a" type="main">Software crash analysis for automatic exploit generation on binary programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">K</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">L</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">W</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="270" to="289" />
			<date type="published" when="2014-03">Mar. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b167">
	<analytic>
		<title level="a" type="main">LAVA: Large-scale automated vulnerability addition</title>
		<author>
			<persName><forename type="first">B</forename><surname>Dolan-Gavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. Security Privacy</title>
		<meeting>IEEE Symp. Security Privacy</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b168">
	<analytic>
		<title level="a" type="main">SimFuzz: Test case similarity directed deep fuzzing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Syst. Softw</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="102" to="111" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b169">
	<analytic>
		<title level="a" type="main">Differential testing for software</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Mckeeman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digit. Tech. J</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="100" to="107" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b170">
	<analytic>
		<title level="a" type="main">Application of domain-aware binary fuzzing to aid android virtual machine testing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kyle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leather</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Franke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Butcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Monteith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th ACM SIGPLAN/SIGOPS Int. Conf. Virtual Execution Environ</title>
		<meeting>11th ACM SIGPLAN/SIGOPS Int. Conf. Virtual Execution Environ<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b171">
	<analytic>
		<title level="a" type="main">Code coverage of adaptive random testing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-C</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Wong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="226" to="237" />
			<date type="published" when="2013-03">Mar. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b172">
	<analytic>
		<title level="a" type="main">Application of a failure driven test profile in random testing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-C</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="179" to="192" />
			<date type="published" when="2009-03">Mar. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b173">
	<analytic>
		<title level="a" type="main">A novel evolutionary approach for adaptive random testing</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">F</forename><surname>Tappenden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="619" to="633" />
			<date type="published" when="2009-12">Dec. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b174">
	<analytic>
		<title level="a" type="main">Clustering deviations for black box regression testing of database applications</title>
		<author>
			<persName><forename type="first">E</forename><surname>Rogstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Rel</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="18" />
			<date type="published" when="2016-03">Mar. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b175">
	<analytic>
		<title level="a" type="main">Coverage-directed differential testing of JVM implementations</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 37th ACM SIGPLAN Conf. Program. Lang. Des. Implementation</title>
		<meeting>37th ACM SIGPLAN Conf. Program. Lang. Des. Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="85" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b176">
	<analytic>
		<title level="a" type="main">Static program analysis as a fuzzing aid</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shastry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 20th Int. Symp. Res. Attacks Intrusions Defenses</title>
		<meeting>20th Int. Symp. Res. Attacks Intrusions Defenses<address><addrLine>Atlanta, GA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="26" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b177">
	<analytic>
		<title level="a" type="main">Model-based whitebox fuzzing for program binaries</title>
		<author>
			<persName><forename type="first">V.-T</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 31st IEEE/ACM Int. Conf. Autom. Softw. Eng</title>
		<meeting>31st IEEE/ACM Int. Conf. Autom. Softw. Eng<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="543" to="553" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b178">
	<analytic>
		<title level="a" type="main">Metamorphic testing for cybersecurity</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="48" to="55" />
			<date type="published" when="2016-06">Jun. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b179">
	<analytic>
		<title level="a" type="main">Fault-based testing without the need of oracles</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">H</forename><surname>Tse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b180">
	<analytic>
		<title level="a" type="main">How effectively does metamorphic testing alleviate the oracle problem?</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-C</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="22" />
			<date type="published" when="2014-01">Jan. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b181">
	<analytic>
		<title level="a" type="main">Metamorphic testing: A review of challenges and opportunities</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2018-01">Jan. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b182">
	<analytic>
		<title level="a" type="main">Eris: A tool for combinatorial testing of the linux system call interface</title>
		<author>
			<persName><forename type="first">B</forename><surname>Garn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Simos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 7th Int. Conf. Softw. Test. Verification Validation Workshops</title>
		<meeting>IEEE 7th Int. Conf. Softw. Test. Verification Validation Workshops</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="58" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b183">
	<analytic>
		<title level="a" type="main">Static exploration of taint-style vulnerabilities found by fuzzing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shastry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Maggi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th USENIX Workshop Offensive Technol</title>
		<meeting>11th USENIX Workshop Offensive Technol<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b184">
	<analytic>
		<title level="a" type="main">GRT: Program-analysis-guided random testing (T)</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gmeiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 30th</title>
		<meeting>30th<address><addrLine>Lincoln, NE, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-09-13">Nov. 9-13, 2015</date>
			<biblScope unit="volume">2015</biblScope>
			<biblScope unit="page" from="212" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b185">
	<analytic>
		<title level="a" type="main">Using metamorphic testing to improve dynamic symbolic execution</title>
		<author>
			<persName><forename type="first">E</forename><surname>Alatawi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Søndergaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Australas</title>
		<meeting>24th Australas</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="38" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b186">
	<analytic>
		<title level="a" type="main">Efficient fuzz testing leveraging input, code, and execution</title>
		<author>
			<persName><forename type="first">N</forename><surname>Havrikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 39th Int. Conf. Softw. Eng</title>
		<meeting>39th Int. Conf. Softw. Eng<address><addrLine>Buenos Aires, Argentina</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017">May 20-28, 2017</date>
			<biblScope unit="volume">2017</biblScope>
			<biblScope unit="page" from="417" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b187">
	<analytic>
		<title level="a" type="main">Learn&amp;Fuzz: Machine learning for input fuzzing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Peleg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null<address><addrLine>Urbana, IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-11-03">Oct. 30-Nov. 3, 2017</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="50" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b188">
	<analytic>
		<title level="a" type="main">Fuzzing binaries with Lévy flight swarms</title>
		<author>
			<persName><forename type="first">K</forename><surname>Böttinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP J. Inf. Security</title>
		<imprint>
			<biblScope unit="volume">2016</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2016-11">Nov. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b189">
	<analytic>
		<title level="a" type="main">Hunting bugs with levy flight foraging</title>
		<author>
			<persName><forename type="first">K</forename><surname>Böttinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Security Privacy Workshops</title>
		<meeting>IEEE Security Privacy Workshops</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="111" to="117" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b190">
	<analytic>
		<title level="a" type="main">KameleonFuzz: Evolutionary fuzzing for black-box XSS detection</title>
		<author>
			<persName><forename type="first">F</forename><surname>Duchene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-L</forename><surname>Richier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Groz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Conf. Data Appl. Security Privacy</title>
		<meeting>ACM Conf. Data Appl. Security Privacy</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b191">
	<analytic>
		<title level="a" type="main">XSS vulnerability detection using model inference assisted evolutionary fuzzing</title>
		<author>
			<persName><forename type="first">F</forename><surname>Duchene</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Groz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Richier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE 5th Int. Conf. Softw. Test. Verification Validation</title>
		<meeting>IEEE 5th Int. Conf. Softw. Test. Verification Validation</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="815" to="817" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b192">
	<analytic>
		<title level="a" type="main">NetworkProfiler: Towards automatic fingerprinting of Android apps</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tongaonkar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Conf. Comput. Commun</title>
		<meeting>IEEE Int. Conf. Comput. Commun</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="809" to="817" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
