<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computationally Private Randomizing Polynomials and Their Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Benny</forename><surname>Applebaum</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<address>
									<country>Technion</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Yuval</forename><surname>Ishai</surname></persName>
							<email>yuvali@cs.technion.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<address>
									<country>Technion</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eyal</forename><surname>Kushilevitz</surname></persName>
							<email>eyalk@cs.technion.ac.il</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<address>
									<country>Technion</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computationally Private Randomizing Polynomials and Their Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B9B3F6C3CC3BD9065236A545CB8ED39E</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.3" ident="GROBID" when="2023-07-27T10:05+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Randomizing polynomials allow to represent a function f (x) by a low-degree randomized mapping f (x, r) whose output distribution on an input x is a randomized encoding of f (x). It is known that any function f in ⊕L/poly (and in particular in NC 1 ) can be efficiently represented by degree-3 randomizing polynomials. Such a degree-3 representation gives rise to an NC 0 4 representation, in which every bit of the output depends on only 4 bits of the input.</p><p>In this paper, we study the relaxed notion of computationally private randomizing polynomials, where the output distribution of f (x, r) should only be computationally indistinguishable from a randomized encoding of f (x). We construct degree-3 randomizing polynomials of this type for every polynomial-time computable function, assuming the existence of a cryptographic pseudorandom generator (PRG) in ⊕L/poly. (The latter assumption is implied by most standard intractability assumptions used in cryptography.) This result is obtained by combining a variant of Yao's garbled circuit technique with previous "informationtheoretic" constructions of randomizing polynomials.</p><p>We then present the following applications:</p><p>• Relaxed assumptions for cryptography in NC 0 . Assuming a PRG in ⊕L/poly, the existence of an arbitrary public-key encryption, commitment, or signature scheme implies the existence of such a scheme in NC 0 4 . Previously, one needed to assume the existence of such schemes in ⊕L/poly or similar classes.</p><p>• New parallel reductions between cryptographic primitives. We show that even some relatively complex cryptographic primitives, including (stateless) symmetric encryption and digital signatures, are NC 0 -reducible to a PRG. No parallel reductions of this type were previously known, even in NC.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>To what extent can one simplify the task of computing a function f by settling for computing some (possibly randomized) encoding of its output? The study of this question was initiated in the context of secure multi-party computation <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref>, and has recently found applications to parallel constructions of cryptographic primitives <ref type="bibr" target="#b0">[1]</ref>. In this paper we consider a relaxed variant of this question and present some new constructions and cryptographic applications.</p><p>The above question can be formally captured by the following notion. We say that a function f (x, r) is a randomized encoding of a function f (x), if its output distribution depends only on the output of f . More precisely, we require that: <ref type="bibr" target="#b0">(1)</ref> given f (x, r) one can efficiently recover f (x), and (2) given f (x) one can efficiently sample from the distribution of f (x, r) induced by a uniform choice of r.</p><p>This notion of randomized encoding defines a nontrivial relaxation of the usual notion of computing, and thus gives rise to the following question: Can we encode "complex" functions f by "simple" functions f ? This question is motivated by the fact that in many cryptographic applications, f can be securely used as a substitute for f <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b0">1]</ref>. For instance, if f is a one-way function then so is f . It should be noted that different applications motivate different interpretations of the term "simple" above. In the context of multi-party computation, one is typically interested in minimizing the algebraic degree of f , viewing it as a vector of multivariate polynomials over a finite field. In this context, f was referred to as a representation of f by randomizing polynomials <ref type="bibr" target="#b16">[17]</ref>. In other contexts it is natural to view f as a function over binary strings and attempt to minimize its parallel time complexity <ref type="bibr" target="#b0">[1]</ref>. From here on, we will refer to f as a "randomized encoding" of f (or simply "encoding" for short) except when we wish to stress that we are interested in minimizing the degree.</p><p>It was shown in <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18]</ref> that every function f in ⊕L/poly can be efficiently represented by degree-3 randomizing polynomials over GF <ref type="bibr" target="#b1">(2)</ref>. <ref type="foot" target="#foot_0">1</ref> (The class ⊕L/poly contains L/poly and NC 1 and is contained in NC <ref type="foot" target="#foot_1">2</ref> . In a non-uniform setting it also contains NL/poly <ref type="bibr" target="#b29">[30]</ref>.) Moreover, every degree-3 encoding can in turn be converted into an NC 0 encoding with locality 4, namely one in which every bit of the output depends on only 4 bits of the input <ref type="bibr" target="#b0">[1]</ref>. A major question left open by the above results is whether every polynomial-time computable function admits an encoding in NC 0 .</p><p>In this work we consider a relaxed notion of computationally private randomized encodings, where requirement <ref type="bibr" target="#b1">(2)</ref> above is relaxed to allow sampling from a distribution which is computationally indistinguishable from f (x, r). As it turns out, computationally private encodings are sufficient for most applications. Thus, settling the latter question for the relaxed notion may be viewed as a second-best alternative.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.">Overview of Results and Techniques</head><p>We construct a computationally private encoding in NC 0 for every polynomial-time computable function, assuming the existence of a "minimal" cryptographic pseudorandom generator (PRG) <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b30">31]</ref>, namely one that stretches its seed by just one bit, in ⊕L/poly. 2 We refer to the latter assumption as the "Easy PRG" (EPRG) assumption. (This assumption can be slightly relaxed, e.g., to also be implied by the existence of a PRG in NL/poly; see Remark 4.13.) We note that EPRG is a very mild assumption. In particular, it is implied by most concrete intractability assumptions commonly used in cryptography, such as ones related to factoring, discrete logarithm, or lattice problems. It is also implied by the existence in ⊕L/poly of a one-way permutation or, using <ref type="bibr" target="#b15">[16]</ref>, of any one-way function whose "entropy" can be efficiently computed. The NC 0 encoding we obtain under the EPRG assumption has degree 3 and locality 4. Its size is nearly linear in the circuit size of the encoded function.</p><p>The construction consists of three steps. The first step is an NC 0 implementation of one-time symmetric encryption using a minimal PRG as an oracle. (Such an encryption allows to encrypt a single message whose length may be polynomially larger than the key. Since our PRG extends its seed by just one bit, it cannot be directly used to encrypt long messages.) The second and main step of the construction relies on a variant of Yao's garbled circuit technique <ref type="bibr" target="#b31">[32]</ref> to obtain an encoding in NC 0 which uses one-time symmetric encryption as an oracle. Finally, using the EPRG assumption and <ref type="bibr" target="#b0">[1]</ref>, we apply a final step of "information-theoretic" encoding to obtain an encoding in NC 0 with degree 3 and locality 4.</p><p>The above result gives rise to several types of cryptographic applications, discussed below.</p><p>1.1.1. Relaxed assumptions for cryptography in NC 0 . The question of minimizing the parallel time complexity of cryptographic primitives has been the subject of an extensive body of research (see <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b0">1]</ref> and references therein). Pushing parallelism to the extreme, it is natural to ask whether one can implement cryptographic primitives in NC 0 . While it was known that few primitives, including pseudorandom functions <ref type="bibr" target="#b11">[12]</ref>, cannot even be implemented in AC 0 <ref type="bibr" target="#b19">[20]</ref>, no similar negative results were known for other primitives.</p><p>Very recently, it was shown in <ref type="bibr" target="#b0">[1]</ref> that the existence of most cryptographic primitives in NC 0 follows from their existence in higher complexity classes such as ⊕L/poly, which is typically a very mild assumption. This result was obtained by combining the results on (information-theoretic) randomized encodings mentioned above with the fact that the security of most cryptographic primitives is inherited by their randomized encoding.</p><p>Using our construction of computationally private encodings, we can further relax the sufficient assumptions for cryptographic primitives in NC 0 . The main observation is that the security of most primitives is also inherited by their computationally private encoding. This is the case even for relatively "sophisticated" primitives such as publickey encryption, digital signatures, commitments, and noninteractive zero-knowledge proofs. Thus, given that these primitives at all exist,<ref type="foot" target="#foot_2">3</ref> their existence in NC 0 follows from the EPRG assumption, namely from the existence of a PRG in complexity classes such as ⊕L/poly or NL/poly. Previously (using <ref type="bibr" target="#b0">[1]</ref>), the existence of each of these primitives in NC 0 would only follow from the assumption that this par-ticular primitive can be implemented in the above classes, a seemingly stronger assumption than EPRG.</p><p>It should be noted that we cannot obtain a similar result for some other primitives, such as one-way permutations and collision-resistant hash functions. The results for these primitives obtained in <ref type="bibr" target="#b0">[1]</ref> rely on certain regularity properties of the encoding that are lost in the transition to computational privacy.</p><p>1.1.2. Parallel reductions between cryptographic primitives. The results of <ref type="bibr" target="#b0">[1]</ref> also give rise to new NC 0 reductions between cryptographic primitives. (Unlike the results discussed in Section 1.1.1 above, here we consider unconditional reductions that do not rely on unproven assumptions.) In particular, known NC 1 -reductions from PRG to one-way permutations <ref type="bibr" target="#b12">[13]</ref> or even to more general types of one-way functions <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b28">29]</ref> can be encoded into NC 0reductions. However, these NC 0 -reductions crucially rely on the very simple structure of the NC 1 -reductions from which they are derived. In particular, it is not possible to use the results of <ref type="bibr" target="#b0">[1]</ref> for encoding general NC 1 -reductions (let alone polynomial-time reductions) into NC 0 -reductions.</p><p>As a surprising application of our technique, we get a general "compiler" that converts an arbitrary (polynomialtime) reduction from a primitive P to a PRG into an NC 0reduction from P to a PRG. This applies to all primitives P that are known to be equivalent to a one-way function, and whose security is inherited by their computationallyprivate encoding. In particular, we conclude that symmetric encryption, 4 commitment, and digital signatures are all NC 0 -reducible to a minimal PRG (hence also to a one-way permutation or more general types of one-way functions).</p><p>No parallel reductions of this type were previously known, even in NC. The known construction of commitment from a PRG <ref type="bibr" target="#b20">[21]</ref> requires a linear-stretch PRG (expanding an n bits n + Ω(n) bits), which is not known to be reducible in parallel to a minimal PRG. Other primitives, such as symmetric encryption and signatures, were not even known to be reducible in parallel to a polynomial-stretch PRG. For instance, the only previous parallel construction of symmetric encryption from a "low-level" primitive is based on the parallel PRF construction of <ref type="bibr" target="#b22">[23]</ref>. This yields an NC 1 -reduction from symmetric encryption to synthesizers, a stronger primitive than a PRG. Thus, we obtain better parallelism and at the same time rely on a weaker primitive. The price we pay is that we cannot generally guarantee parallel decryption. (See Section 5.2 for further discussion.) <ref type="bibr" target="#b3">4</ref> By symmetric encryption we refer to (probabilistic) stateless encryption for multiple messages, where the parties do not maintain any state information other than the key. If parties are allowed to maintain synchronized states, symmetric encryption can be easily reduced in NC 0 to a PRG.</p><p>An interesting feature of the new reductions is their nonblack-box use of the underlying PRG. That is, the "code" of the NC 0 -reduction we get (implementing P using an oracle to a PRG) depends on the code of the PRG. This should be contrasted with most known reductions in cryptography, which make a black-box use of the underlying primitive. In particular, this is the case for the abovementioned NC 0reductions based on <ref type="bibr" target="#b0">[1]</ref>. (See <ref type="bibr" target="#b24">[25]</ref> for a thorough taxonomy of reductions in cryptography.) 1.1.3. Application to secure computation. The notion of randomizing polynomials was originally motivated by the goal of minimizing the round complexity of secure multiparty computation <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b7">8]</ref>. The main relevant observations made in <ref type="bibr" target="#b16">[17]</ref> were that: (1) the round complexity of most general protocols from the literature is related to the degree of the function being computed; and (2) if f is represented by a vector f of degree-d randomizing polynomials, then the secure computation of f can be reduced to that of securely computing some deterministic degree-d function f which is closely related to f . This reduction from f to f is fully non-interactive, in the sense that it involves only local computation on the outputs received from f and does not require additional rounds of interaction.</p><p>A useful corollary of our results is that under the EPRG assumption, the task of securely computing an arbitrary polynomial-time computable function f reduces (non-interactively) to that of securely computing a related degree-3 function f . This reduction is only computationally secure. Thus, even if the underlying protocol for f is secure in an information-theoretic sense, the resulting protocol for f will only be computationally secure. (In contrast, previous constructions of randomizing polynomials maintained information-theoretic security, but only efficiently applied to restricted function classes such as ⊕L/poly.) This reduction gives rise to new, conceptually simpler, constant-round protocols for general functions. For instance, a combination of our result with the classical "BGW protocol" <ref type="bibr" target="#b2">[3]</ref> gives a simpler, and in some cases more efficient, alternative to the constant-round protocol of <ref type="bibr" target="#b1">[2]</ref> (though relies on a stronger assumption).</p><p>Organization. Following some preliminaries (Section 2), in Section 3 we review previous notions of randomized encoding and define our new notion of computationally private encoding. In Section 4 we construct a computationally private encoding in NC 0 for every polynomial-time computable function. Finally, applications of this construction are discussed in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries</head><p>Probability notation. We let U n denote a random variable uniformly distributed over {0, 1} n . If X is a probability dis-tribution, or a random variable, we write x ← X to indicate that x is a sample taken from X. The statistical distance between discrete probability distributions Y and Y , denoted SD(Y, Y ), is defined as the maximum, over all functions A, of the </p><formula xml:id="formula_0">distinguishing advantage | Pr[A(Y ) = 1] -Pr[A(Y ) = 1]|. A function ε(•) is said to be negligi- ble if ε(n) &lt; n -c</formula><formula xml:id="formula_1">(Y n ) = 1] -Pr[A n (Y n ) = 1]| is negligi- ble.</formula><p>Circuits. We define a boolean circuit C as a directed acyclic graph with labeled, ordered vertices of the following types:</p><p>(1) input vertices, each labeled with a literal x i or xi and having fan-in 0; (2) gate vertices, labeled with one of the boolean functions AND,OR and having fan-in 2; (3) output vertices, labeled "output" and having fan-in 1 and fanout 0. The edges of the circuit are referred to as wires. A wire that outgoes from an input vertex is called an input wire, and a wire that enters an output vertex is called an output wire. Any input x ∈ {0, 1} n assigns a unique value to each wire in the natural way. The output value of C, denoted C(x), contains the values of the output wires according to the given predefined order. The size of a circuit, denoted |C|, is the number of wires in C, and its depth is the maximum distance from an input to an output (i.e. the length of the longest directed path in the graph).</p><p>NC i -reductions. A circuit with an oracle access to a function g : {0, 1} * → {0, 1} * is a circuit that contains, in addition to the bounded fan-in OR, AND gates, special oracle gates with unbounded fan-in that compute the function g. We say that f : {0, 1} * → {0, 1} * is NC i reducible to g, and write f ∈ NC i [g], if f can be computed by a uniform family of polynomial size, O(log i n) depth circuits with oracle gates to g. (Oracle gates are treated the same as AND/OR gates when defining depth.) Note that if f ∈ NC i [g] and g ∈ NC j then f ∈ NC i+j .</p><p>Locality and degree. We say that f is c-local if each of its output bits depends on at most c input bits. For a constant c, the non-uniform class NC 0 c includes all c-local functions. We will sometimes view the binary alphabet as the finite field F = GF(2), and say that a function f has degree d if each of its output bits can be expressed as a multivariate polynomial of degree (at most) d in the input bits.</p><p>Complexity classes. For brevity, we assume all complexity classes to be polynomial-time uniform by default. For instance, NC 0 refers to the class of functions admitting uniform NC 0 circuits. We let NL/poly (resp., ⊕L/poly) denote the class of boolean functions computed by NL (resp., ⊕L) Turing machines taking a uniform advice. We extend boolean complexity classes, such as NL/poly and ⊕L/poly, to include non-boolean functions by letting the representation include l(n) log-space Turing machines, one for each output, taking the same uniform advice. Similarly, we denote by P the class of functions that can be computed in polynomial time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Randomized Encodings</head><p>We now review the notions of randomized encoding and randomizing polynomials from <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b0">1]</ref>, and introduce the new computationally private variant discussed in this paper. The following definition is from <ref type="bibr" target="#b0">[1]</ref>. Definition 3.1 (Randomized encoding) Let f : {0, 1} n → {0, 1} l be a function. We say that a function f : {0, 1} n × {0, 1} m → {0, 1} s is a δ-correct, ε-private randomized encoding of f , if it satisfies the following:</p><p>• δ-correctness. There exists an algorithm B, called a decoder, such that for any input</p><formula xml:id="formula_2">x ∈ {0, 1} n , Pr[B( f (x, U m )) = f (x)] ≤ δ.</formula><p>• ε-privacy. There exists a randomized algorithm S, called a simulator, such that for any</p><formula xml:id="formula_3">x ∈ {0, 1} n , SD(S(f (x)), f (x, U m )) ≤ ε.</formula><p>We refer to the second input of f as its random input, and to m, s as the randomness complexity and the output complexity of f respectively. The overall complexity (or complexity) of f is defined to be m + s.</p><p>We say that f is a representation (or encoding) of f by degree-d randomizing polynomials if each of its output bits can be computed by a multivariate polynomial over GF(2) of degree at most d in the inputs. Definition 3.1 naturally extends to infinite functions f : {0, 1} * → {0, 1} * . In this case, the parameters l, m, s, δ, ε are all viewed as functions of the input length n, and the algorithms B, S receive 1 n as an additional input. By default, we require f to be computable in poly(n) time whenever f is. In particular, both m(n) and s(n) are polynomially bounded. We also require both the decoder and the simulator algorithms to be efficient.</p><p>Several variants of randomized encodings were considered in <ref type="bibr" target="#b0">[1]</ref>. Correctness (resp., privacy) is said to be perfect when δ = 0 (resp. ε = 0) or statistical when δ(n) (resp. ε(n)) is negligible. In order to preserve the security of some primitives (such as pseudorandom generators or one-way permutations) even perfect correctness and privacy might not suffice and additional requirements should be introduced. An encoding is said to be balanced if it admits a perfectly private simulator S such that S(U l ) ≡ U s .</p><p>It is said to be stretch preserving if s = l + m. We say that f is a statistical randomized encoding of f if it is both statistically correct and statistically private, and that it is a perfect randomized encoding if it is perfectly correct and private, balanced, and stretch preserving. In this work, we abandon the information theoretic setting and relax the privacy requirement to be computational. That is, we require the ensembles S(1 n , f n (x)) and fn (x, U m(n) ) to be computationally indistinguishable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.2 (Computational randomized encoding)</head><formula xml:id="formula_4">Let f = {f n : {0, 1} n → {0, 1} l(n) } n∈N be a function family. We say that the function fam- ily f = { fn : {0, 1} n × {0, 1} m(n) → {0, 1} s(n) } n∈N is a computational randomized encoding of f (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>or computational encoding for short), if it satisfies the following requirements:</head><p>• Statistical correctness. There exists a polynomialtime decoder B, such that for any n and any input</p><formula xml:id="formula_5">x ∈ {0, 1} n , Pr[B(1 n , fn (x, U m(n) )) = f n (x)] ≤ δ(n),</formula><p>for some negligible function δ(n). • Computational privacy. There exists a probabilistic polynomial-time simulator S, such that for any family of strings {x n } n∈N where</p><formula xml:id="formula_6">|x n | = n, we have S(1 n , f n (x n )) c ≡ fn (x n , U m(n) ).</formula><p>We will also refer to perfectly correct computational encodings, where the statistical correctness requirement is strengthened to perfect correctness. In fact, our main construction yields a perfectly correct encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 3.3</head><p>The above definition uses n both as an input length parameter and as a cryptographic "security parameter" quantifying computational privacy. When describing our construction, it will be convenient to use a separate parameter k for the latter, where computational privacy will be guaranteed as long as k ≥ n for some constant &gt; 0.</p><p>The function classes SREN and PREN were introduced in <ref type="bibr" target="#b0">[1]</ref> to capture the power of statistical and perfect randomized encodings in NC 0 . We define a similar class CREN .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 3.4 (The classes CREN, SREN, PREN)</head><p>The class CREN (resp., SREN , PREN ) is the class of functions admitting a computational (resp., statistical, perfect) randomized encoding in NC 0 .</p><p>It follows from the definitions that PREN ⊆ SREN ⊆ CREN . Moreover, it is known that ⊕L/poly ⊆ PREN and NL/poly ⊆ SREN <ref type="bibr" target="#b0">[1]</ref>.</p><p>We end this section by considering the following intuitive composition property: Suppose we encode f by g, and then view g as a single-argument function and encode it again. Then, the resulting function (parsed appropriately) is an encoding of f . The following lemma was stated in <ref type="bibr" target="#b0">[1]</ref> for the statistical and perfect variants of randomized encodings; we extend it here to the computational variant. Lemma 3.5 (Composition) Let g(x, r) be a computational encoding of f (x) and h((x, r), r ) a computational encoding of g((x, r)), viewing the latter as a single-argument function. Then, the function h (x, (r, r )) def = h((x, r), r ) is a computational encoding of f (x) whose random inputs are (r, r ). Moreover, if g, h are perfectly correct then so is h . Proof sketch: A decoder for h is obtained by composing the decoders of h and g. Specifically, given an output y h of h (i.e., y h = h (x, (r, r )) = h((x, r), r ) for some x, r, r ), it first decodes y g = g(x, r) by invoking the decoder of h on y h , and then decodes y f = f (x) by invoking the decoder of g on y g . This decoder is perfectly (resp., statistically) correct if both the decoders of h and g are perfectly (resp., statistically) correct. To prove computational privacy, we again compose the computationally private simulators of g and h, this time in an opposite order. Specifically, on input y f = f (x), the simulator of h first invokes the simulator of g on y f , obtaining a simulated string y g , and then invokes the simulator of h on y g . The computational privacy of this simulator follows from that of the simulators of g, h by a standard hybrid argument.</p><p>It follows as a special case that the composition of a computational encoding with a perfect or a statistical encoding is a computational encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 3.6</head><p>It is known that any f ∈ PREN (resp., f ∈ SREN ) admits a perfect (resp., statistical) encoding of degree 3 and locality 4 <ref type="bibr" target="#b0">[1]</ref>. The same holds for the class CREN , since we can encode a function f ∈ CREN by a computational encoding in NC 0 and then encode the resulting function using a perfect encoding of degree 3 and locality 4 (promised by the fact that NC 0 ⊆ PREN). By Lemma 3.5, the result is a computational encoding for f of degree 3 and locality 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Computational Encoding in NC 0 for Every Efficiently Computable Function</head><p>In this section we construct a perfectly correct computational encoding of degree 3 and locality 4 for every efficiently computable function. Our construction consists of three steps. In Section 4.1, we describe an NC 0 implementation of one-time symmetric encryption using a minimal PRG as an oracle (i.e., a PRG that stretches its seed by just one bit). In Section 4.2 we describe the main step of the construction, in which we encode an arbitrary circuit using an NC 0 circuit which uses one-time symmetric encryption as an oracle. This step is based on a variant of Yao's garbled circuit technique <ref type="bibr" target="#b31">[32]</ref>. Combining the first two steps, we get a computational encoding in NC 0 with an oracle to a mini-mal PRG. Finally, in Section 4.3, we derive the main result by relying on the existence of an "easy PRG".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">From PRG to One-Time Encryption</head><p>An important tool in our construction is a one-time symmetric encryption; that is, a (probabilistic) private-key encryption that is semantically secure <ref type="bibr" target="#b14">[15]</ref> for encrypting a single message. We describe an NC 0 -reduction from such an encryption to a minimal PRG, stretching its seed by a single bit. We start by defining one-time symmetric encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 4.1 (One-time symmetric encryption) A onetime symmetric encryption scheme is a pair (E, D), of probabilistic polynomial-time algorithms satisfying the following conditions:</head><p>• Correctness: For every k-bit key e and for every plaintext m ∈ {0, 1} * , the algorithms E, D satisfy D e (E e (m)) = m.</p><p>• Security: For every polynomial-size circuit family {A k }, every polynomials p(•) and (•), all sufficiently large k's and every plaintexts x, y ∈ {0, 1} (k) , it holds that</p><formula xml:id="formula_7">|Pr[A k (E U k (x)) = 1]-Pr[A k (E U k (y)) = 1]| &lt; 1 p(k)</formula><p>where the probabilities are taken over the random choice of the key and the coin tosses of E.</p><p>The integer k serves as the security parameter of the scheme.</p><p>The above definition enables to securely encrypt polynomially long messages under short keys. This is an important feature that will be used in our garbled circuit construction described in Section 4.2. In fact, it would suffice for our purposes to encrypt messages of some fixed polynomial <ref type="foot" target="#foot_3">5</ref> length, say (k) = k 2 . This could be easily done in NC 0 if we had oracle access to a PRG with a corresponding stretch. Given such a PRG G, the encryption can be defined by E e (m) = G(e) ⊕ m and the decryption by D e (c) = G(e)⊕c. However, we would like to base our construction on a PRG with a minimal stretch.</p><p>From the traditional "sequential" point of view, such a minimal PRG is equivalent to a PRG with an arbitrary polynomial stretch (cf. <ref type="bibr" target="#b9">[10,</ref><ref type="bibr">Thm. 3.3.3]</ref>). In contrast, this is not known to be the case with respect to parallel reductions. It is not even known whether a linear-stretch PRG is NCreducible to a minimal PRG (see <ref type="bibr" target="#b28">[29]</ref> for some relevant negative results). Thus, a minimal PRG is a more conservative assumption from the point of view of parallel cryptography.</p><p>Moreover, unlike a PRG with linear stretch, a minimal PRG is reducible in parallel to one-way permutations and other types of one-way functions <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b0">1]</ref>.</p><p>The above discussion motivates a direct parallel construction of one-time symmetric encryption using a minimal PRG. We present such an NC 0 construction below. Construction 4.2 (From PRG to one-time symmetric encryption) Let G be a minimal PRG that stretches its input by a single bit, let e be a k-bit key, and let m be a (k + l)-bit plaintext. Define the probabilistic encryption algorithm E e (m, (r 1 , . . . , r l-1 )) We use a hybrid argument to derive a contradiction. Fix some k. For a string m of length k + l(k) we define for 0 ≤ i ≤ l(k) the distributions H i (m) in the following way. The distribution H 0 (m) is defined to be E r0 (m, (r 1 , . . . , r l-1 )) where r i ← U k+i . For 1 ≤ i ≤ l(k), the distribution H i (m) is defined exactly as H i-1 (m) only that the string G(r i-1 ) is replaced with a random string w i-1 , which is one bit longer than r i-1 (that is, w i-1 ← U k+i ). Observe that for every m ∈ {0, 1} k+l(k) , all the l(k) strings of the hybrid H l(k) (m) are distributed uniformly and independently (each of them is the result of XOR with a fresh random string w i ). Therefore, in particular,</p><formula xml:id="formula_8">def = (G(e) ⊕ r 1 , G(r 1 ) ⊕ r 2 , . . . , G(r l-2 ) ⊕ r l-1 , G(r l-1 ) ⊕ m),</formula><formula xml:id="formula_9">H l(k) (x k ) ≡ H l(k) (y k ). Since H 0 (x k ) ≡ E e (x k ) as well as H 0 (y k ) ≡ E e (y k ), it follows that our distinguisher A k distinguishes, w.l.o.g., between H l(k) (x k ) and H 0 (x k )</formula><p>with at least ε(k)/2 advantage. Then, since there are l(k) hybrids, there must be</p><formula xml:id="formula_10">1 ≤ i ≤ l(k) such that the neighbor- ing hybrids, H i-1 (x k ), H i (x k ), can be distinguished by A k with ε(k)</formula><p>2l(k) advantage. We now show how to use A k to distinguish a randomly chosen string from an output of the pseudorandom generator. Given a string z of length k + i (that is either sampled from G(U k+i-1 ) or from U k+i ), we uniformly choose the strings r j ∈ {0, 1} k+j for j = 1, . . . , l(k) -1. We feed A k with the sample (r 1 , . . . , r i-1 , z ⊕ r i , G(r i ) ⊕ r i+1 , . . . , G(r l(k)-1 )⊕x k ). If z is a uniformly chosen string then the above distribution is equivalent to H i (x k ). On the other hand, if z is drawn from G(U i ) then the result is distributed exactly as H i-1 (x k ), since each of the first i -1 entries of H i-1 (x k ) is distributed uniformly and independently of the remaining entries (each of these entries was XOR-ed with a fresh and unique random w j ). Hence, we constructed an adversary that breaks the PRG with nonnegligible advantage ε (k)  2l(k) , deriving a contradiction. Since the encryption algorithm described in Construction 4.2 is indeed an NC 0 circuit with oracle access to a minimal PRG, we get the following lemma. Lemma 4. <ref type="bibr" target="#b3">4</ref> Let G be a PRG. Then, there exists one-time symmetric encryption scheme (E, D) in which the encryp-</p><formula xml:id="formula_11">tion function E is in NC 0 [G].</formula><p>Note that the decryption algorithm of the above construction is sequential. This issue will be further discussed later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">From One-Time Encryption to Computational Encoding</head><p>Let f = {f n : {0, 1} n → {0, 1} l(n) } n∈N be a polynomial-time computable function, computed by the uniform circuit family {C n } n∈N . We use a one-time symmetric encryption scheme (E, D) as a black box to encode f by a perfectly correct computational encoding f = { fn } n∈N . Each fn will be an NC 0 circuit with an oracle access to the encryption algorithm E, where the latter is viewed as a function of the key, the message, and its random coin tosses. This construction uses a variant of Yao's garbled circuit technique <ref type="bibr" target="#b31">[32]</ref>. Our notation and terminology for this section borrow from previous presentations of Yao's construction in <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b18">19</ref>]. 6   Notation. Denote by x = (x 1 , . . . , x n ) the input for f n . Let k = k(n) be a security parameter which may be set to n ε for an arbitrary positive constant ε (see Remark 3.3). Let Γ(n) denote the number of gates in C n . For every 1 ≤ i ≤ |C n |, denote by b i (x) the value of the i-th wire induced by the input x; when x is clear from the context we simply use b i to denote the wire's value.</p><p>We would like to garble the circuit C n evaluated on an input x such that values obtained on all wires other than output wires are never revealed. In order to do this, our encoding fn (x, (r, W )) consists of random inputs of two types:</p><p>6 Security proofs for variants of this construction were given implicitly in <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b18">19]</ref> in the context of secure computation. However, they cannot be directly used in our context for different reasons. In particular, the analysis of <ref type="bibr" target="#b18">[19]</ref> relies on a special form of symmetric encryption and does not achieve perfect correctness, while that of <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b27">28]</ref> relies on a linear-stretch PRG.</p><p>|C n | bits (referred to as masks) denoted r 1 , . . . , r |Cn| corresponding to the |C n | wires of C n , and |C n | pairs of strings (referred to as signals) W 0 i , W 1 i ∈ {0, 1} 2k again in correspondence with the |C n | wires. We use c i to denote the value of wire i masked by r i ; namely, c i = b i ⊕ r i . The encoding fn (x, (r, W )) will reveal the masked value, c i , of every wire but will hide the masks r i 's of all the wires except of the output wires. This way, the real values (b i 's) of non-output wires will remain hidden. The signal W 0 i represents the value 0 on wire i and the signal W 1 i represents the value 1 on this wire. We refer to the signal W bi i , that corresponds to the real value of the wire, as an on-path signal and to the other signal W 1-bi i as an off-path signal. We view each string W b i as if it is broken into two equal-size parts denoted W b,0 i , W b,1 i . The encoding will enable computation of the on-path signal and masked value of each wire, but will hide the offpath signals. Since the on-path signals and off-path signals are distributed identically, the knowledge of an on-path signal W bi i does not reveal the value b i . To compute the onpath signals and masked bits, we add to our encoding a garbled truth table for every gate. The table maps the on-path labels and masked bits of the input wires of a gate into the on-path labels and masked bits of the output wires of this gate, and thus enables a bottom-to-top computation of these values. Namely, for each of the four possible inputs to a gate α, β ∈ {0, 1} we encrypt the corresponding signals and masked bits of the gate's output wires, where the keys of the encryption are the corresponding on-path signals of the input wires.</p><p>We view the encoding fn as the concatenation of O(|C n |) functions. In particular, we specify several entries for each gate and for each input and output wire. In what follows ⊕ denotes bitwise-xor on strings; when we want to emphasize that the operation is applied to single bits we will usually denote it by either + or -. We use • to denote concatenation. Construction 4.5 Let C n be a circuit that computes f n . Then, we define fn (x, (r, W )) to be the concatenation of the following functions.</p><p>Input wires: For an input wire i, labeled by a literal , which is either some variable x u or its negation, we append the function W i • ( + r i ).</p><p>Gates: Let t ∈ [Γ(n)] be a gate that computes the function g ∈ {AND, OR} with input wires i, j and output wires y 1 , . . . , y m . We associate with this gate 4 functions that are referred to as gate labels. Specifically, for each of the 4 choices of a i , a j ∈ {0, 1}, we define a corresponding function. This function can be thought of as the entry that is indexed by (a i , a j ) in the garbled truth table of the gate. It is defined as follows:</p><formula xml:id="formula_12">Q ai,aj t (r, W ) def = E W a i -r i ,a j i ⊕W a j -r j ,a i j ( W g(ai-ri,aj -rj ) y1 • (g(a i -r i , a j -r j ) + r y1 ) • . . . • W g(ai-ri,aj -rj ) ym • (g(a i -r i , a j -r j ) + r ym ) ),</formula><p>where E is a one-time symmetric encryption algorithm. That is, the signals and the masked bits of all the output wires of this gate are encrypted under a key that depends on the signals of the input wires of the gate. Note that Q ai,aj t depends only on the random inputs. We refer to the label Q ci,cj t that is indexed by the masked bits of the input wires as an on-path label, and to the other three labels as the offpath labels. Output wires: For each output wire i of the circuit, we add the mask of this wire r i .</p><p>It is not hard to verify that fn is in NC 0 [E]. In particular, observe that a term of the form W i , where is a literal, is a 3-local function that each of its bits depends on and the corresponding bits of W 1 i and W 0 i . Similarly, the keys that are used in the encryptions are 8-local functions, and the encrypted messages are 6-local functions.</p><p>We will now analyze the complexity of fn . For each wire the construction uses O(k) random bits, in addition each invocation of the encryption uses poly(k) random bits. Since there are Let µ(n), s(n) be the randomness complexity and the output complexity of fn respectively. We claim that the function family f = { fn : {0, 1} n × {0, 1} µ(n) → {0, 1} s(n) } n∈N defined above is indeed a computationally randomized encoding of the family f . We start with perfect correctness.</p><formula xml:id="formula_13">O(|C n |) invocations, the randomness complex- ity is O(|C n |) • poly(k) = O(|C n | • n ε )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4.6 (Perfect correctness)</head><p>There exists a polynomial time decoder algorithm B such that for every n ∈ N and every x ∈ {0, 1} n and (r,</p><formula xml:id="formula_14">W ) ∈ {0, 1} µ(n) , it holds that B(1 n , fn (x, (r, W ))) = f n (x).</formula><p>Proof: Let α = fn (x, (r, W )) for some x ∈ {0, 1} n and (r, W ) ∈ {0, 1} µ (n) . Given α we show how to efficiently compute the on-path signal W bi i and masked value c i of every wire i in the circuit. In particular, by obtaining c i for an output wire i, we can retrieve the mask r i from α and compute the corresponding output bit of f n (x), i.e., output b i = c ir i . (Recall that the masks of the output wires are given explicitly as part of α.) The on-path signals and the masked values of every wire are computed by scanning the circuit from bottom to top.</p><p>For an input wire i the desired value, W bi i • c i , is given as part of α. Next, consider a wire y that goes out of a gate t, and assume that we have already computed the desired values of the input wires i, j of this gate. We use the masked bits c i , c j of the input wires, to select the onpath label Q ci,cj t of the gate t (and ignore the other 3 offpath labels of this gate). Consider this label as in Equation (4.1); recall that this cipher was encrypted under the key To argue computational privacy we need to prove the following lemma, whose proof is deferred to Appendix A.</p><formula xml:id="formula_15">W ci-ri,cj i ⊕ W cj -rj ,ci j = W bi,cj i ⊕ W bj ,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 4.7 (Computational privacy) There exists a probabilistic polynomial-time simulator S, such that for any family of strings {x</head><formula xml:id="formula_16">n } n∈N , |x n | = n, it holds that S(1 n , f n (x n )) c ≡ fn (x n , U µ(n) ).</formula><p>Remark 4.8 (Information-theoretic variant) Construction 4.5 can be instantiated with a perfect (informationtheoretic) encryption scheme, yielding a perfectly private randomized encoding. (The privacy proof given in Appendix A can be easily modified to treat this case.) However, in such an encryption the key must be as long as the encrypted message <ref type="bibr" target="#b26">[27]</ref>. It follows that the wires' signal length grows exponentially with their distance from the outputs, rendering the construction efficient only for NC 1 circuits. This information-theoretic variant of the garbled circuit construction was previously suggested in <ref type="bibr" target="#b17">[18]</ref>. We will use it in Section 4.3 for obtaining a computational encoding with a parallel decoder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Main Results</head><p>Combining Lemmas 4.6, 4.7, and 4.4 we get an NC 0 encoding of any efficiently computable function using an oracle to a minimal PRG. Theorem 4.9 Suppose f is computed by a uniform family {C n } of polynomial-size circuits. Let G be a (minimal) PRG. Then, f admits a perfectly correct computational encoding</p><formula xml:id="formula_17">f in NC 0 [G]. The complexity of f is O(|C n | • n ε ) (for an arbitrary constant ε &gt; 0).</formula><p>We turn to the question of eliminating the PRG oracles. We follow the natural approach of replacing each oracle with an NC 0 implementation. (A more general but less direct approach will be described in Remark 4.13.) Using [1, Theorem 6.2], a minimal PRG in NC 0 is implied by a PRG in PREN , and in particular by a PRG in NC 1 or even ⊕L/poly. Thus, we can base our main theorem on the following "easy PRG" assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assumption 4.10 (Easy PRG (EPRG))</head><p>There exists a PRG in ⊕L/poly.</p><p>As discussed in Section 1.1, EPRG is a very mild assumption. In particular, it is implied by most standard cryptographic intractability assumptions, and is also implied by the existence in ⊕L/poly of one-way permutations and other types of one-way functions.</p><p>Combining Theorem 4.9 with the EPRG assumption, we get a computational encoding in NC 0 for every efficiently computable function. To optimize its parameters we apply a final step of perfect encoding, yielding a computational encoding with degree 3 and locality 4 (see Remark 3.6). Thus, we get the following main theorem. Proof: Let f (x) be a function in BPP. It follows that there exists a function f (x, z) ∈ P such that for every x ∈ {0, 1} n it holds that Pr z [f (x, z) = f (x)] ≤ 2 -n . Let f ((x, z), r) be the NC 0 computational encoding of f promised by Theorem 4.11. It follows that f (x, (z, r))</p><formula xml:id="formula_18">def = f ((x, z), r) is a computational encoding of f in NC 0 .</formula><p>Conversely, suppose f ∈ CREN and let f be an NC 0 computational encoding of f . A BPP algorithm for f can be obtained by first computing ŷ = f (x, r) on a random r and then invoking the decoder on ŷ to obtain the output y = f (x) with high probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 4.13 (Relaxing the EPRG assumption)</head><p>The EPRG assumption is equivalent to the existence of a PRG in NC 0 or in PREN . It is possible to base Theorem 4.11 on a seemingly more liberal assumption by taking an alternative approach that does not rely on a perfect encoding. The idea is to first replace each PRG oracle with an implementation G from some class C, and only then apply a (perfectly correct) statistical encoding to the resulting NC 0 [G] circuit. Thus, we need G to be taken from a class C such that NC 0 [C] ⊆ SREN . It follows from <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b0">1]</ref> that the class NL/poly satisfies this property (and furthermore, functions in NL/poly admit a statistical NC 0 encoding with perfect correctness). Thus, we can replace ⊕L/poly in the EPRG assumption with NL/poly.</p><p>On the parallel complexity of the decoder. As we shall see in Section 5, it is sometimes useful to obtain a computational encoding whose decoder is also parallelized. By the description of the decoder of Construction 4.5, it follows that if the circuit computing f is an NC i circuit then the decoder is in NC i [D], where D is the decryption algorithm. Thus, if D is in NC j we obtain a parallel decoder in NC i+j . Unfortunately, we cannot use the parallel symmetric encryption scheme of Construction 4.2 for this purpose because of its sequential decryption.</p><p>We can get around this problem by strengthening the EPRG assumption. Suppose we have a polynomial-stretch PRG in NC 1 . (This is implied by some standard cryptographic assumptions, see <ref type="bibr" target="#b23">[24]</ref>.) In such a case, we can obtain a one-time symmetric encryption scheme (E, D) (for messages of a fixed polynomial length) in which both E and D are in NC 1 . To encrypt a message we simply apply the generator to the key and mask the result with the plaintext message; decryption is implemented analogously. Our goal is to turn this into a scheme ( Ê, D) in which the encryption Ê is in NC 0 and the decryption is still in NC 1 . We achieve this by applying to (E, D) the encoding given by the information-theoretic variant of the garbled circuit construction (see Remark 4.8 or <ref type="bibr" target="#b17">[18]</ref>). That is, Ê is a (perfectly correct and private) NC 0 encoding of E, and D is obtained by composing D with the decoder of the information-theoretic garbled circuit. (The resulting scheme ( Ê, D) is still a secure encryption scheme, see <ref type="bibr" target="#b0">[1]</ref> or Example 5.1.) Since the symmetric encryption employed by the information-theoretic garbled circuit is in NC 0 , its decoder can be implemented in NC 1 [NC 0 ] = NC 1 . Thus, D is also in NC 1 . Combining this encryption scheme with Construction 4.5, we get a computational encoding of a function f ∈ NC i with encoding in NC 0 and decoding in NC i+1 . Summarizing, we have the following: Claim 4.14 Suppose there exists a PRG with polynomial stretch in NC 1 (i.e., a PRG that stretches k bits into k c bits for some c &gt; 1). Then, every function f ∈ NC i admits a perfectly-correct computational encoding in NC 0 whose decoder is in NC i+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Applications</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Relaxed Assumptions for Cryptography in NC 0</head><p>In <ref type="bibr" target="#b0">[1]</ref> it was shown that, under relatively mild assumptions, many cryptographic tasks can be implemented in NC 0 . This was proved by arguing that: (1) the security of most primitives is inherited by their statistical or perfect randomized encoding; and (2) perfect or statistical encodings can be obtained for functions in relatively high complexity classes such as NC 1 , ⊕L/poly or NL/poly. Thus, if a primitive P can be computed in these classes, then it can also be computed in NC 0 .</p><p>In this work, we consider primitives whose security is also inherited by their computational encoding. (In some cases we will need to rely on perfect correctness, which we get "for free" in our main construction.) It follows from Theorem 4.11 that, under the EPRG assumption, any such primitive P can be computed in NC 0 if it exists at all (i.e., can be computed in polynomial time).</p><p>Some primitives, such as collision resistant hash functions and one-way permutations, do not respect computational encoding. However, many others do. These include public-key encryption, symmetric encryption, <ref type="foot" target="#foot_4">7</ref> commitments, <ref type="foot" target="#foot_5">8</ref> signatures, message authentication schemes (MACs), and non-interactive zero knowledge proofs (NIZK). (See <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref> for detailed definitions of these cryptographic primitives.) In all these cases, we can replace the sender (i.e., the encrypting party, committing party, signer or prover, according to the case) with its computational encoding and let the receiver (the decrypting party or verifier) use the decoding algorithm to translate the output of the new sender to an output of the original one. The security of the resulting scheme reduces to the security of the original one by using the efficient simulator. These reductions are analogous to those given in <ref type="bibr" target="#b0">[1]</ref> for the case of statistical encoding. For completeness, we sketch below the construction and security proof for the case of public-key encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 5.1 (Public-key encryption)</head><p>Suppose that E = (G, E, D) is a (probabilistic) public-key encryption scheme, where G is a key-generation algorithm generating a pair (e, d) of encryption and decryption keys, E(e, m, r) is the encryption function that encrypts the message m using the key e and randomness r, and D(d, y) is the decryption function that decrypts the cipher y using the decryption key d. The encryption function E should be semantically secure as in Definition 4.1, except that here the distinguisher is also given the public key e. Let Ê be a randomized encoding of <ref type="figure">E,</ref> and<ref type="figure">let D(d, ŷ</ref>) <ref type="figure">d,</ref><ref type="figure">B(ŷ)</ref>) be the composition of D with the decoder B of the encoding Ê. We argue that the scheme Ê def = (G, Ê, D) is also a public-key encryption scheme. The efficiency and correctness of Ê are guaranteed by the efficiency of the encoding and its correctness. The security of Ê reduces to that of E using the efficient simulator S of Ê. This is ar-gued as follows. Given a distinguisher Â which efficiently distinguishes between encryptions under Ê of messages x, x , we obtain a similar distinguisher A for E by letting A(e, y) = Â(e, S(y)). By computational privacy, if y is a random encryption of m under E with a key e, then S(y) is computationally indistinguishable from a random encryption of m under Ê with the same key e. It follows that if Â has a non-negligible advantage distinguishing between encryptions of x and x , then so does A.</p><formula xml:id="formula_19">def = D(</formula><p>A transformation as above can be used to construct an NC 0 sender, but does not promise anything concerning the parallel-time complexity of the receiver. In the following, we argue that 1) for some primitives the parallel complexity at the receiver's end can also be improved, and 2) for other primitives, we can implement the sender in NC 0 without substantial increase in the parallel complexity of the receiver.</p><p>Consider first the case of commitment. As argued in <ref type="bibr" target="#b0">[1]</ref>, in this case we can also improve the complexity at the receiver's end to AC 0 . Indeed, the sender can decommit by sending its random coins, and the receiver needs only to emulate the computation of the sender and compare it with the message it received in the commit stage. Thus, the receiver can be implemented as an NC 0 circuit with a single unbounded fan-in AND gate. Such a commitment scheme can then be used to implement coin flipping over the phone <ref type="bibr" target="#b3">[4]</ref> between an NC 0 circuit and an AC 0 circuit.</p><p>We summarize some consequences of the EPRG assumption obtained so far.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 5.2 Suppose that the EPRG assumption holds. Then,</head><p>• If there exists a public-key encryption (resp., NIZK) scheme, then there exists such a scheme in which the encryption (prover) algorithm is in NC 0 4 . • There exists a stateless symmetric encryption scheme (resp., digital signature or MAC) in which the encryption (signing) algorithm is in NC 0 4 . • There exists a commitment scheme (resp., coin-flipping protocol) in which the sender (first party) is in NC 0 4 and the receiver (second party) is in AC 0 .</p><p>Note that the existence of all the above primitives, except of public-key encryption and NIZK, does not require any additional assumption other than EPRG. This is a consequence of the fact that they all can be constructed (in polynomial time) from a PRG (see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>). For these primitives, we obtain more general (unconditional) results in the next subsection. Theorem 5.2 reveals an interesting phenomenon. It appears that several cryptographic primitives can be implemented in NC 0 despite the fact that their standard construc-tions rely on pseudorandom functions (PRFs) <ref type="bibr" target="#b11">[12]</ref>, which cannot be computed even in AC 0 <ref type="bibr" target="#b19">[20]</ref>. For such primitives, we actually construct a sequential PRF from the PRG (as in <ref type="bibr" target="#b11">[12]</ref>), use it as a building block to obtain a sequential construction of the desired primitive (e.g., symmetric encryption), and finally reduce the parallel-time complexity of the resulting function using our machinery. Of course, the security of the PRF primitive itself is not inherited by its computational (or even perfect) encoding.</p><p>Parallelizing the receiver. As mentioned above, the computational encoding promised by Theorem 4.11 does not support parallel decoding. Thus, we get primitives in which the sender is in NC 0 but the receiver is not known to be in NC, even if we started with a primitive that has an NC receiver. The following theorem tries to partially remedy this state of affairs. Assuming the existence of a PRG with a good stretch in NC 1 , we can rely on Claim 4.14 to convert senderreceiver schemes in which both the receiver and the sender are in NC to ones in which the sender is in NC 0 and the receiver is still in NC. Theorem 5.3 Let X = (G, S, R) be a sender-receiver cryptographic scheme, where G is a key-generation algorithm, S ∈ NC s is the algorithm of the sender and R ∈ NC r is the algorithm of the receiver. Suppose X implements a primitive P whose security is respected by computational encoding. Suppose further that there exists a polynomialstretch PRG in NC 1 . Then there exists a scheme X = (G, Ŝ, R) that securely implements the same cryptographic task as X , and in which Ŝ ∈ NC 0 and R ∈ NC max{s+1,r} .</p><p>Proof: If there exists a polynomial-stretch PRG in NC 1 , then we can use Claim 4.14 and get a computational encoding Ŝ for S in NC 0 whose decoder B is in NC s+1 . As usual, the new receiver R uses B to decode the encoding, and then applies the original receiver R to the result. Thus, R is in NC max{s+1,r} .</p><p>Alternatively, it is possible to relax the above assumption to the existence of a linear-stretch PRG in NC 1 , at the cost of increasing the complexity of the receiver to NC max{s+2,r} .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Parallel Reductions between Cryptographic Primitives</head><p>In the previous section we showed that many cryptographic tasks can be performed in NC 0 if they can be performed at all, relying on the assumption that an easy PRG exists. Although EPRG is a very reasonable assumption, it is natural to ask what types of parallel reductions between primitives can be guaranteed unconditionally. In particular, such reductions would have consequences even if there exists a PRG in, say, NC 4 .</p><p>In this section, we consider the types of unconditional reductions that can be obtained using the machinery of Section 4. We focus on primitives that can be reduced to a PRG (equivalently, using <ref type="bibr" target="#b15">[16]</ref>, to a one-way function). We argue that for any such primitive F, its polynomial-time reduction to a PRG can be collapsed into an NC 0 -reduction to a PRG. More specifically, we present an efficient "compiler" that takes the code of an arbitrary PRG G and outputs a description of an NC 0 circuit C, having oracle access to a function G , such that for any (minimal) PRG G the circuit C[G ] implements F.</p><p>A compiler as above proceeds as follows. Given the code of G, it first constructs a code for an efficient implementation f of F. (In case we are given an efficient black-box reduction from F to a PRG, this code is obtained by plugging the code of G into this reduction.) Then, applying a constructive form of Theorem 4.9 to the code of f , the compiler obtains a code f of an NC 0 circuit which implements F by making an oracle access to a PRG. This code of f defines the required NC 0 reduction from F to a PRG, whose specification depends on the code of the given PRG G. Thus, the reduction makes a non-black-box use of the PRG primitive, even if the polynomial-time reduction it is based on is fully black-box.</p><p>Based on the above we can obtain the following informal "meta-theorem": Meta-Theorem 5. <ref type="bibr" target="#b3">4</ref> Let F be a cryptographic primitive whose security is respected by computational encoding. Suppose that F is polynomial-time reducible to a PRG. Then, F is NC 0 -reducible to a (minimal) PRG.</p><p>Since a minimal PRG can be reduced in NC 0 to one-way permutations or one-way functions with efficiently computable "entropy" (see <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b28">29]</ref>), the minimal PRG in the conclusion of the above theorem can be replaced by these primitives.</p><p>Instantiating F by concrete primitives, we get the following corollary:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Corollary 5.5 Let G be a PRG. Then,</head><p>• There exists a stateless symmetric encryption scheme (resp., digital signature or MAC) in which the encryption (signing) algorithm is in NC 0 [G]. • There exists a commitment scheme (resp., coin-flipping protocol) in which the sender (first party) is in NC 0 [G] and the receiver (second party) is in</p><formula xml:id="formula_20">AC 0 [G].</formula><p>Note that the last two items of Theorem 5.2 can be derived from the above corollary, up to the exact locality.</p><p>The above results can be used to improve the parallel complexity of some known reductions. For example, Naor <ref type="bibr" target="#b20">[21]</ref> shows a commitment scheme in which the sender is in NC 0 [LG], where LG is a linear-stretch PRG. By using his construction, we derive a commitment scheme in which the sender (respectively, the receiver) is in NC 0 [G] (respectively, AC 0 [G]) where G is a minimal PRG. Since it is not known how to NC-reduce a linear-stretch PRG to a minimal PRG, we get a nontrivial parallel reduction.</p><p>Other interesting examples arise in the case of primitives that are based on PRFs, such as MACs, symmetric encryption, and identification (see <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b10">11]</ref> for these and other applications of PRFs). Since the known construction of a PRF from a PRG is sequential <ref type="bibr" target="#b11">[12]</ref>, it was not known how to reduce these primitives in parallel to (even a polynomial-stretch) PRG. This fact motivated the study of parallel constructions of PRFs in <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24]</ref>. In particular, Naor and Reingold <ref type="bibr" target="#b22">[23]</ref> introduce a new cryptographic primitive called a synthesizer (SYNTH), and show that PRFs can be implemented in NC 1 [SYNTH]. This gives an NC 1 -reduction from cryptographic primitives such as symmetric encryption to synthesizers. By Corollary 5.5, we get that these primitives are in fact NC 0 -reducible to a PRG. Since (even a polynomial-stretch) PRG can be implemented in NC 0 [SYNTH] while synthesizers are not known to be even in NC[PRG], our results improve both the complexity of the reduction and the underlying assumption. It should be noted, however, that our reduction only improves the parallel-time complexity of the encrypting party, while the constructions of <ref type="bibr" target="#b22">[23]</ref> yield NC 1 -reductions on both ends. (A partial and conditional workaround is given by Theorem 5.3.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Secure Multi-Party Computation</head><p>Secure multi-party computation (MPC) allows several parties to evaluate a function of their inputs in a distributed way, so that both the privacy of their inputs and the correctness of the outputs are maintained. These properties should hold, to the extent possible, even in the presence of an adversary who may corrupt at most t parties. This is typically formalized by comparing the adversary's interaction with the real process, in which the uncorrupted parties run the specified protocol on their inputs, with an ideal function evaluation process in which a trusted party is employed. The protocol is said to be secure if whatever the adversary "achieves" in the real process it could have also achieved by corrupting the ideal process. A bit more precisely, it is required that for every adversary A interacting with the real process there is an adversary A interacting with the ideal process, such that outputs of these two interactions are indistinguishable from the point of view of an external environment. See, e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b10">11]</ref>, for more detailed and concrete definitions.</p><p>There is a variety of different models for secure computation. These models differ in the power of the adversary, the network structure, and the type of "environment" that tries to distinguish between the real process and the ideal process. In the information-theoretic setting, both the adversary and the distinguishing environment are computationally unbounded, whereas in the computational setting they are both bounded to probabilistic polynomial time.</p><p>The notion of randomizing polynomials was originally motivated by the goal of minimizing the round complexity of MPC. The motivating observation of <ref type="bibr" target="#b16">[17]</ref> was that the round complexity of most general protocols from the literature (e.g., those of <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b7">8]</ref>) is related to the degree of the function being computed. Thus, by reducing the task of securely computing f to that of securely computing some related low-degree function, one can obtain round-efficient protocols for f .</p><p>Randomizing polynomials (or low-degree randomized encodings) provide precisely this type of reduction. More specifically, suppose that the input x to f is distributed between the parties, who wish to all learn the output f (x). If f is represented by a vector f (x, r) of degree-d randomizing polynomials, then the secure computation of f can be noninteractively reduced to that of f , where the latter is viewed as a randomized function of x. This reduction only requires each party to invoke the decoder of f on its local output, obtaining the corresponding output of f . The secure computation of f , in turn, can be non-interactively reduced to that of a related deterministic function f of the same degree d. The idea is to let f (x, r 1 , . . . , r t+1 ) def = p(x, r 1 +. . .+r t+1 ) (where t is a bound on the number of corrupted parties), assign each input vector r j to a distinct player, and instruct it to pick it at random. (See <ref type="bibr" target="#b16">[17]</ref> for more details.) This second reduction step is also non-interactive. Thus, any secure protocol for f or f gives rise to a secure protocol for f with the same number of rounds. The non-interactive nature of the reduction makes it insensitive to almost all aspects of the security model.</p><p>Previous constructions of (perfect or statistical) randomizing polynomials <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b8">9]</ref> provided informationtheoretic reductions of the type discussed above. In particular, if the protocol used for evaluating f is informationtheoretically secure, then so is the resulting protocol for f . The main limitation of these previous reductions is that they efficiently apply only to restricted classes of functions, typically related to different log-space classes. This situation is remedied in the current work, where we obtain (under the EPRG assumption) a general secure reduction from a function f to a related degree-3 function f . The main price we pay is that the security of the reduction is no longer information-theoretic. Thus, even if the underlying protocol for f is secure in the information-theoretic sense, the resulting protocol for f will only be computationally secure.</p><p>Formulating the above using the terminology of reductions between secure functionalities (cf. <ref type="bibr" target="#b10">[11]</ref>), Theorem 4.11 has the following corollary. Theorem 5.6 Suppose the EPRG assumption holds. Let f (x) be an m-party functionality computed by a (uniform) circuit family of size s(n). Then, for any &gt; 0, there is a non-interactive, computationally (m -1)-secure reduction from f to either of the following two efficient functionalities:</p><p>• A randomized functionality f (x, r) of degree 3 (over GF(2)) with a random input and output of length</p><formula xml:id="formula_21">O(s(n) • n ) each; • A deterministic functionality f (x ) of degree 3 (over GF(2)) with input length O(m • s(n) • n ) and output length O(s(n) • n ).</formula><p>Both reductions are non-interactive in the sense that they involve a single call to f or f and no further interaction. They both apply regardless of whether the adversary is passive or active, adaptive or non-adaptive.</p><p>A high-level corollary of Theorem 5.6 is that computing arbitrary polynomial-time computable functionalities is as easy as computing degree-3 functionalities. Thus, when designing new MPC protocols, it suffices to consider degree-3 functionalities which are often easier to handle.</p><p>More concretely, Theorem 5.6 gives rise to new, conceptually simpler, constant-round protocols for general functionalities. For instance, a combination of this result with the "BGW protocol" <ref type="bibr" target="#b2">[3]</ref> gives a simpler alternative to the constant-round protocol of Beaver, Micali, and Rogaway <ref type="bibr" target="#b1">[2]</ref>. The resulting protocol will be more round-efficient, and in some cases (depending on the number of parties and the "easiness" of the PRG) even more communication-efficient than the protocol of <ref type="bibr" target="#b1">[2]</ref>. On the downside, Theorem 5.6 relies on a stronger assumption than the protocol from <ref type="bibr" target="#b1">[2]</ref> (an easy PRG vs. an arbitrary PRG).</p><p>An interesting open question, which is motivated mainly from the point of view of the MPC application, is to come up with an "arithmetic" variant of the construction. That is, given an arithmetic circuit C, say with addition and multiplication gates, construct a vector of computationally private randomizing polynomials of size poly(|C|) which makes a black-box use of the underlying field. The latter requirement means that the same polynomials should represent C over any field, ruling out the option of simulating arithmetic field operations by boolean operations. Such a result is known for weaker arithmetic models such as formulas and branching programs (see <ref type="bibr" target="#b8">[9]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Proof of Lemma 4.7</head><p>The simulator. We start with the description of the simulator S. Given 1 n and f n (x) for some x ∈ {0, 1} n , the simulator chooses for every wire i of the circuit C n a random string W bi i , and a random bit c i . For an input wire i, the simulator outputs W bi i •c i . For a gate t with input wires i, j and output wires y 1 , . . . y m the simulator computes the on-path label Q</p><formula xml:id="formula_22">ci,cj t = E W b i ,c j i ⊕W b j ,c i j (W by 1 y1 • c y1 • . . . • W by m ym • c ym )</formula><p>and sets the other three off-path labels of this gate to be encryptions of all-zeros strings of appropriate length under random keys; that is, for every two bits (a i , a j ) = (c i , c j ), the simulator chooses uniformly a k(n)-bit string R ai,aj and outputs</p><formula xml:id="formula_23">Q ai,aj l = E Ra i ,a j (0 |W by 1 y 1 •cy 1 •...•W by m ym •cy m | ).</formula><p>Finally, for an output wire i, the simulator outputs</p><formula xml:id="formula_24">r i = c i -b i (recall that b i is known since f n (x) is given).</formula><p>Since C n can be constructed in polynomial-time and since the encryption algorithm runs in polynomial time the simulator is also a polynomial-time algorithm. We refer to the gate labels constructed by the simulator as "fake" gate labels and to gate labels of fn as "real" gate labels.</p><p>Assume, towards a contradiction, that there exists a (nonuniform) polynomial-size circuit family {A n }, a polynomial p(•), and a string family {x n }, |x n | = n, such that A n distinguishes between the distributions S(1 n , f n (x n )) and fn (x n , U µ(n) ) with non-negligible advantage ε(n). We construct a sequence of hybrid distributions that depend on x n , and mix "real" gates labels and "fake" ones, such that one endpoint corresponds to the simulated output (in which all the gates have "fake" labels) and the other endpoint corresponds to fn (x n , U µ(n) ) (in which all the gates have real labels). If the extreme hybrids can be efficiently distinguished then there must be two neighboring hybrids that can be efficiently distinguished. We show that such a distinguisher can be used to break the encryption hence deriving a contradiction.</p><p>The hybrids H n t . First, fix n and let k = k(n). Next, we order the gates of C n in topological order. That is, if the gate t uses the output of gate t , then t &lt; t. Now, for every t = 0, . . . , Γ(n), we define the hybrid algorithm H n t that constructs "fake" labels for the first t gates and "real" labels for the rest of the gates: 1. For every wire i uniformly choose two k-bit strings W bi i , W </p><formula xml:id="formula_25">Q ci,cj t = E W b i ,c j i ⊕W b j ,c i j (W by 1 y1 •c y1 •. . .•W by m ym •c ym ),</formula><p>and for every choice of (a i , a j ) ∈ {0, 1} 2 that is different from (c i , c j ), uniformly choose a k-bit string R ai,aj and output Q ai,aj t = E Ra i ,a j (0 |W by 1</p><formula xml:id="formula_26">y 1 •cy 1 •...•W by m ym •cy m | ).</formula><p>4. For every gate t &gt; t, let g be the function that t computes (AND or OR), let i, j be the input wires of t and let y 1 , . . . y m be its output wires. Use x n to compute the value of b i (x n ), b j (x n ), and set r i = c ib i and r j = c jb j . For every choice of (a i , a j ) ∈ {0, 1} 2 , compute Q ai,aj t exactly as in Equation <ref type="formula">4</ref>.1, and output it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">For every output wire i compute b i and output r</head><formula xml:id="formula_27">i = c i -b i .</formula><p>First, observe that H n t runs in polynomial time (when x n is given). Second, note that this hybrid algorithm uses the string x n only when constructing real labels, that is in Step 4. Steps 1-3 can be performed without any knowledge on x n , and Step 5 requires only the knowledge of f n (x n ). Obviously, the algorithm H n Γ(n) is just a different description of the simulator S, and therefore S(1 n , f n (x n )) ≡ H n Γ(n) . We also claim that the second extreme hybrid, H n 0 coincides with the distribution of the "real" encoding, fn (x n , U µ(n) ). To see this note that (1) the strings W 0 i , W 1 i are chosen uniformly and independently by H n 0 , as they are in fn (x n , U µ(n) ); and</p><p>(2) since H n 0 chooses the c i 's uniformly and independently and sets r i = c ib i then the r i 's themselves are also distributed uniformly and independently exactly as they are in fn (x n , U µ(n) ). Since for every gate t the value of Q ai,aj t is a function of the random variables, and since it is computed by H n 0 in the same way as in fn (x n , U µ(n) ), we get that H n 0 ≡ fn (x n , U µ(n) ). Since A n can distinguish the extreme hybrids with nonnegligible advantage ε(n) and since the number of hybrids (i.e., the size of C n ) is polynomial in n, it follows that A n can also distinguish some neighboring hybrids with nonnegligible advantage; namely, there exists some 0 ≤ t ≤ Γ(n) -1 such that C n distinguishes between H n t and H n t+1 with advantage ε (n) ≥ ε(n)/Γ(n). We use A n , x n , t to construct an adversary that breaks the encryption E.</p><p>Let i, j be the input wires of the gate t, let y 1 , . . . , y m be the output wires of t, let g be the function that gate t computes, and let b i , b j , b y1 , . . . , b ym be the values of the corresponding wires induced by the input x n . For σ ∈ {0, 1}, define the distribution ensemble P n (σ) as the output distribution of the following random process:</p><p>• Uniformly choose the k-bit strings W bi i , W , set r i = c ib i , r j = c jb j , and for every choice of (a i , a j ) ∈ {0, 1} , c i , c j , c y1 , . . . , c ym , Q 0,0 t , Q 0,1 t , Q 1,0 t , Q 1,1 t ). The following claim reduces the indistinguishability of the distribution ensembles P n (0), P n (1) to the indistinguishability of the one-time symmetric encryption scheme.</p><p>Claim A. <ref type="bibr" target="#b0">1</ref> If E is a one-time symmetric encryption then the distribution ensembles P n (0) and P n (1) are computationally indistinguishable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof sketch:</head><p>Clearly, the ensembles P n (0) and P n (1) differ only in the off-path labels Q ai,aj t for (a i , a j ) = (c i , c j ). In P n (0) each of these entries is an all-zeros string that was encrypted under uniformly and independently chosen key R ai,aj . In the second distribution P n (1), the entry Q ai,aj t is an encryption of a "meaningful" message that was encrypted under the key W ai-ri,aj i ⊕ W aj -rj ,ai j , since (a i , a j ) = (c i , c j ) at least one of the strings W ai-ri,ai i , W aj -rj ,aj j is not given in the output of P n (1) as part of W bi i , W bj j . Also, each of the strings W ai-ri,aj i , W aj -rj ,ai j was chosen uniformly and it appears only in Q ai,aj t and not in any of the other gate labels, therefore the key W ai-ri,aj i ⊕ W aj -rj ,ai j is a uniformly chosen key that is not correlated with other entries of P n (1)'s output. So the difference between these two distributions amounts to the difference between three encryptions of zeros (in P n (0)) and three encryptions of some other strings in the same length as the zeros strings (in P n (1)), where in both cases the three encryptions are encrypted under three uniformly and independently chosen keys. The indistinguishability of such encryptions easily follows from the security of the encryption scheme.</p><p>We now show how to construct a non-uniform distinguisher A n for P n (0) and P n (1) from the distinguisher A n , and thus derive a contradiction to the previous claim. The adversary A n uses the output of P n (σ) to construct the hybrids H n t and H n t+1 , and then uses A n to distinguish between them. Given the output of P n , we invoke the algorithm H n t where the values of (W bi i , W , c i , c j , c y1 , . . . , c ym , Q 0,0 t , Q 0,1 t , Q 1,0 t , Q 1,1 t ) are set to the values given by P n . If P n (0) is invoked we get the distribution of H n t that is the gate t is "fake"; on the other hand, if P n (1) is invoked then the gate t is "real" and we get the distribution of H n t+1 . Note that P n does not output the off-path signals of the wires i and j (which is crucial for Claim A.1 to hold). However, we do not need these off-path signals to construct the rest of the distribution, since i and j are output wires of gates that precedes t and therefore are "fake" gates in which off-path signals are not encrypted. This is the reason for which we had to sort the gates. On the other hand, the process P n must output the off-path signals of the output wires of the gate y 1 , . . . , y m ; since these wires enter as inputs to another gate t &gt; t which is a "real" gate in both H n t and H n t+1 , and therefore uses the off-path signals of its input wires. Overall, we derive a contradiction to Claim A.1, which completes the privacy proof of Lemma 4.7.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>where r i ← U k+i serve as the coin tosses of E. The decryption algorithm D e (c 1 , . . . , c l-1 ) sets r 0 = e, r i = c i ⊕ G(r i-1 ) for i = 1, . . . , l, and outputs r l . The security of Construction 4.2 is proved via a standard hybrid argument. Lemma 4.3 The scheme (E, D) described in Construction 4.2 is a one-time symmetric encryption scheme. Proof: Construction 4.2 can be easily verified to satisfy the correctness requirement. We now sketch the security proof. Assume, towards a contradiction, that Construction 4.2 is not secure. It follows that there is a polynomial l(•) and two families of strings x = {x k } and y = {y k } where |x k | = |y k | = k + l(k), such that for infinitely many k's, the distribution ensembles E e (x k ) and E e (y k ) where e ← U k , can be distinguished by a polynomial size circuit family {A k } with non-negligible advantage ε(k).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>for an arbitrary constant ε &gt; 0. The output complexity is dominated by the gate labels, which are strings of length poly(k), since there are O(|C n |) such labels the output complexity is also O(|C n |) • poly(k), and thus the overall complexity of f is O(|C n | • n ε ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>ci j . Since we have already computed the values c i , c j , W bi i and W bj j , we can decrypt the label Q ci,cj t , (by applying the decryption algorithm D) and recover the encrypted string, that includes, in particular, the value W g(bi,bj ) y • (g(b i , b j ) + r y ), where g is the function that gate t computes. Since by definition b y = g(b i , b j ), the decrypted string contains the desired value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Theorem 4 . 11</head><label>411</label><figDesc>Suppose f is computed by a uniform family {C n } of polynomial-size circuits. Then, under the EPRG assumption, f admits a perfectly correct computational encoding f of degree 3, locality 4 and complexity O(|C n | • n ε ) (for an arbitrary constant ε &gt; 0). Corollary 4.12 Under the EPRG assumption, CREN = BPP.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>m ym , and the random bits c i , c j , c y1 , . . . , c ym .• If σ = 0 then set Q ci,cj t and the other three Q ai,aj t exactly as in Step 3 of H n t . • If σ = 1 then uniformly choose W 1-bi i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>for any c &gt; 0 and sufficiently large n. For two distribution ensembles Y = {Y n } and Y = {Y n }, we write Y ≡ Y if Y n and Y n are identically distributed,</figDesc><table><row><cell>and say that the two ensembles are statistically indistin-</cell></row><row><cell>guishable if SD(Y n , Y n ) is negligible in n. A weaker no-</cell></row><row><cell>tion of closeness between distributions is that of computa-tional indistinguishability: We write Y c ≡ Y if for every</cell></row><row><cell>polynomial-size circuit family {A n }, the distinguishing ad-</cell></row><row><cell>vantage | Pr[A n</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>For every input wire i output W bi i • c i . 3. For every gate t ≤ t with input wires i, j and output wires y 1 , . . . , y m output</figDesc><table><row><cell>1-bi i</cell><cell>and a random bit c i .</cell></row><row><cell>2.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>2 , set Q</figDesc><table><row><cell cols="3">H n t , that is:</cell><cell>ai,aj t</cell><cell cols="2">exactly as in Step 4 of</cell></row><row><cell>Q</cell><cell>a i ,a j t</cell><cell>= E W i a i -r i ,a j</cell><cell cols="2">j ⊕W a j -r j ,a i</cell><cell>(W</cell></row><row><cell cols="2">• Output</cell><cell cols="4">(W bi i , W j , W bj y1 , W by 1 y1 1-by 1</cell><cell>, . . . , W ym , by m</cell></row><row><cell cols="2">W ym 1-by m</cell><cell></cell><cell></cell><cell></cell></row></table><note><p>g(a i -r i ,a j -r j ) y 1 • g(ai -ri, aj -rj) + ry 1 • . . . • W g(a i -r i ,a j -r j ) ym • g(ai -ri, aj -rj) + ry m )</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>This result generalizes to arbitrary finite fields<ref type="bibr" target="#b17">[18]</ref> or even rings<ref type="bibr" target="#b8">[9]</ref>, allowing efficient degree-3 representations of various counting logspace classes.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>It is not known whether such a minimal PRG implies a PRG in the same class that stretches its seed by a linear or superlinear amount.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>This condition is redundant in the case of signatures and commitments, whose existence follows from the existence of a PRG. In Section 1.1.2 we will describe a stronger result for such primitives.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>Applying the construction to circuits with a bounded fan-out, even linear length would suffice.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_4"><p>See Footnote 4.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>In this work we refer to computationally hiding commitments. Computational encoding does not respect the security of statistically hiding commitments.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgment. We thank Omer Reingold for helpful discussions.</p></div>
			</div>


			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* Supported by grant no. 36/03 from the Israel Science Foundation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Cryptography in NC 0</title>
		<author>
			<persName><forename type="first">B</forename><surname>Applebaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 45st FOCS</title>
		<meeting>45st FOCS</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The round complexity of secure protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 22nd STOC</title>
		<meeting>of 22nd STOC</meeting>
		<imprint>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="503" to="513" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Completeness theorems for non-cryptographic fault-tolerant distributed computation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 20th STOC</title>
		<meeting>of 20th STOC</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Coin flipping by telephone: a protocol for solving impossible problems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="23" to="27" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">How to generate cryptographically strong sequences of pseudo-random bits</title>
		<author>
			<persName><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="850" to="864" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
	<note>Preliminary version in FOCS 82</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Security and composition of multiparty cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="143" to="202" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Universally composable security: A new paradigm for cryptographic protocols</title>
		<author>
			<persName><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 42st FOCS</title>
		<meeting>42st FOCS</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="136" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Multiparty unconditionally secure protocols (extended abstract)</title>
		<author>
			<persName><forename type="first">D</forename><surname>Chaum</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Crépeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 20th STOC</title>
		<meeting>of 20th STOC</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="11" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient multi-party computation over rings</title>
		<author>
			<persName><forename type="first">R</forename><surname>Cramer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Fehr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROCRYPT &apos;03</title>
		<meeting>EUROCRYPT &apos;03</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="596" to="613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography: Basic Tools</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<title level="m">Foundations of Cryptography: Basic Applications</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">How to construct random functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="792" to="807" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A hard-core predicate for all one-way functions</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Levin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st STOC</title>
		<meeting>21st STOC</meeting>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">How to play any mental game (extended abstract)</title>
		<author>
			<persName><forename type="first">O</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 19th STOC</title>
		<meeting>of 19th STOC</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. STOC &apos;82</title>
		<meeting>STOC &apos;82</meeting>
		<imprint>
			<date type="published" when="1984">1984</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="270" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A pseudorandom generator from any one-way function</title>
		<author>
			<persName><forename type="first">J</forename><surname>Håstad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Impagliazzo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1364" to="1396" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Randomizing polynomials: A new representation with applications to round-efficient secure computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 41st FOCS</title>
		<meeting>41st FOCS</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="294" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Perfect constant-round secure computation via perfect randomizing polynomials</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kushilevitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th ICALP</title>
		<meeting>29th ICALP</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="244" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A proof of Yao&apos;s protocol for secure two-party computation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Colloquium on Computational Complexity</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">063</biblScope>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Constant depth circuits, fourier transform, and learnability</title>
		<author>
			<persName><forename type="first">N</forename><surname>Linial</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Mansour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Nisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proc. 30th FOCS</title>
		<imprint>
			<date type="published" when="1989">1993. 1989</date>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="607" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Bit commitment using pseudorandomness</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Cryptology</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Privacy preserving auctions and mechanism design</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sumner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1st ACM Conference on Electronic Commerce</title>
		<meeting>1st ACM Conference on Electronic Commerce</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="129" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Synthesizers and their application to the parallel construction of pseudo-random functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proc. 36th FOCS</title>
		<imprint>
			<date type="published" when="1995">1999. 1995</date>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="336" to="375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Number-theoretic constructions of efficient pseudo-random functions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Preliminary version in Proc. 38th FOCS</title>
		<imprint>
			<date type="published" when="1997">2004. 1997</date>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="231" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Notions of reducibility between cryptographic primitives</title>
		<author>
			<persName><forename type="first">O</forename><surname>Reingold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vadhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC &apos;04</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2951</biblScope>
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">The Round Complexity of Secure Protocols</title>
		<author>
			<persName><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991-06">June 1991</date>
		</imprint>
		<respStmt>
			<orgName>MIT</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Communication theory of secrecy systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="page" from="28" to="32" />
			<date type="published" when="1949">1949</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">On garbled circuits and constant round secure function evaluation. CoPS Lab Technical Report 2003-02</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
		<respStmt>
			<orgName>University of North Texas</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On parallel pseudorandom generators</title>
		<author>
			<persName><forename type="first">E</forename><surname>Viola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">To appear in 20th IEEE Conference on Computational Complexity</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">NL/poly ⊆ ⊕L/poly</title>
		<author>
			<persName><forename type="first">A</forename><surname>Wigderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 9th Structure in Complexity Theory Conference</title>
		<meeting>9th Structure in Complexity Theory Conference</meeting>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="59" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Theory and application of trapdoor functions</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 23rd FOCS</title>
		<meeting>23rd FOCS</meeting>
		<imprint>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="80" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">How to generate and exchange secrets</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 27th FOCS</title>
		<meeting>27th FOCS</meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="162" to="167" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
